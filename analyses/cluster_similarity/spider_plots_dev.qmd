---
title: "Similarity analysis of mouse and human autism neuroanatomical clusters"
format: 
  html:
    embed-resources: true
    self-contained: true
    toc: true
editor: visual
---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      eval = TRUE)
```

```{r packages}
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(data.tree))
suppressPackageStartupMessages(library(RMINC))
suppressPackageStartupMessages(library(MRIcrotome))
suppressPackageStartupMessages(library(pheatmap))
suppressPackageStartupMessages(library(viridis))
suppressPackageStartupMessages(library(RColorBrewer))
suppressPackageStartupMessages(library(ggplotify))
suppressPackageStartupMessages(library(patchwork))
suppressPackageStartupMessages(library(grid))
suppressPackageStartupMessages(library(gridExtra))

```

```{r functions}
source("../../functions/buildSimilarityMatrix.R")
source("../../functions/tree_tools.R")
source("analysis_tools_v2.R")
```

# Analysis parameters

```{r parameters-general}
#Gene space
gene_space <- "average_latent_space"
# gene_space <- "input_space"
# gene_space<- "latent_space"

#Latent space ID
#Only used if gene_space == "latent_space"
latent_space_id <- 1

#Jacobians
# jacobians <- "absolute"
jacobians <- "relative"

#Thresholding method
# threshold_method <- "intensity"
threshold_method <- "topn"

#Threshold value
threshold <- 0.2
# threshold <- 0.1
# threshold <- 0.05


#Mask type
# mask_type <- "positive"
# mask_type <- "negative"

#Metric
metric <- "correlation"
```

The parameters chosen for this analysis are:

```{r parameters-table}
df_parameters <- tibble(Parameter = c("Gene space",
                                      "Jacobians",
                                      "Thresholding method",
                                      "Threshold",
                                      "Similarity metric"),
                        Value = c(gene_space,
                                  jacobians,
                                  threshold_method,
                                  threshold,
                                  metric))

knitr::kable(df_parameters)
```

# Full similarity matrices

## Similarity matrices from signed masks

```{r}
mat_sim_pos <- import_similarity_matrix(gene_space = gene_space,
                                        jacobians = jacobians,
                                        threshold_method = threshold_method,
                                        threshold = threshold,
                                        mask = "positive",
                                        latent_space_id = latent_space_id)

mat_sim_neg <- import_similarity_matrix(gene_space = gene_space,
                                        jacobians = jacobians,
                                        threshold_method = threshold_method,
                                        threshold = threshold,
                                        mask = "negative",
                                        latent_space_id = latent_space_id)
```

## Average similarity matrix

```{r}
mat_sim <- array(data = 0,
                 dim = c(dim(mat_sim_pos), 2))
mat_sim[,,1] <- mat_sim_pos
mat_sim[,,2] <- mat_sim_neg

mat_sim <- rowMeans(mat_sim, dims = 2, na.rm = TRUE)

colnames(mat_sim) <- colnames(mat_sim_pos)
rownames(mat_sim) <- rownames(mat_sim_pos)
```

# Similarity analysis for 5 clusters

## 5-cluster similarity matrix

```{r}
nk <- 5
```

We can start by setting the number of clusters to a specific value. I've chosen nk = `r nk`. The reduced similarity matrix is as follows:

```{r fig.width = 8, fig.height = 6}
col_selection <- str_detect(colnames(mat_sim), str_c("^", nk, "-"))
row_selection <- str_detect(rownames(mat_sim), str_c("^", nk, "-"))

mat_sim_nk <- mat_sim[row_selection, col_selection]  

pheatmap(mat_sim_nk, cluster_cols = F, cluster_rows = F)
```

## Similarity analysis for mouse 5-2 and human 5-1

### Slice series

```{r}
k_mouse <- 2
k_human <- 1
```

### Spider plots

```{r fig.width = 10, fig.height = 10}
nk_list <- list(mouse = nk, human = nk)
k_list <- list(mouse = k_mouse, human = k_human)

# spider_coarse <- plot_spider_chart(nk = nk_list, k = k_list,
#                                    spokes = "neuro-coarse", 
#                                    jacobians = jacobians, 
#                                    threshold_method = threshold_method, 
#                                    threshold = threshold,
#                                    plot_type = "spider",
#                                    save = FALSE, 
#                                    fig_width = 10, fig_height = 10)
# 
# spider_coarse_grob <- ggplotGrob(spider_coarse) %>% grid.force()
# 
# outfile <- str_c("SpiderPlotCoarse_nk_", nk, "_kmouse_", k_mouse, "_khuman_", k_human, ".pdf")
# pdf(file = outfile,
#     width = 8,
#     height = 8)
# print(spider_coarse)
# dev.off()
```

```{r}
spokes <- "neuro-coarse"
# spokes <- "neuro-mid"
datadir <- "../../data/"
nk <- nk_list
k <- k_list

if (spokes == "neuro-coarse") {
  infile <- file.path(datadir, "MouseHumanMatches_H10M09.csv")
} else if (spokes == "neuro-mid") {
  infile <- file.path(datadir, "MouseHumanMatches_H23M23.csv")
} else {
  stop("spokes must be one of {'neuro-coarse', 'neuro-mid'}")
}
df_spokes <- read_csv(infile, show_col_types = FALSE)
colnames(df_spokes) <- str_to_lower(colnames(df_spokes))
df_spokes <- df_spokes %>% 
  filter(!(name %in% c("White matter", "Ventricles")))

species <- c("mouse", "human")
cluster_fractions <- vector(mode = "list", length = length(species))
names(cluster_fractions) <- species
for (i in 1:length(species)) {
  
  if (species[[i]] == "mouse") {
    
    #Mouse DSURQE labels
    label_file <- file.path(datadir, "mouse/atlas/DSURQE_CCFv3_labels_200um.mnc")
    labels <- mincGetVolume(label_file)
    
    #Mouse definitions for DSURQE labels
    defs_file <- file.path(datadir, "mouse/atlas/DSURQE_40micron_R_mapping_long.csv")
    defs <- read_csv(defs_file, show_col_types = FALSE) %>% 
      select(name = Structure, label = Label)
    
    #Mouse hierarchy
    tree_file <- file.path(datadir, "mouse/expression/MouseExpressionTree_DSURQE.RData")
    load(tree_file)
    tree <- Clone(treeMouseExpr)
    rm(treeMouseExpr)
    
  } else {
    
    #Human labels for microarray sample
    label_file <- file.path(datadir, "human/expression/AHBA_microarray_labels_studyspace_1.0mm.mnc")
    labels <- mincGetVolume(label_file)
    
    #Human definitions for microarray sample labels
    defs_file <- file.path(datadir, "human/expression/AHBA_microarray_coordinates_mni_defs.csv")
    defs <- read_csv(defs_file, show_col_types = FALSE)
    
    #Human hierarchy
    tree_file <- file.path(datadir, "human/expression/HumanExpressionTree.RData")
    load(tree_file)
    tree <- Clone(treeHumanExpr)
    rm(treeHumanExpr)
    
  }
  
  df_species_frac_pos <- prepare_cluster_fractions(datadir = datadir, 
                                                   species = species[[i]],
                                                   structs = df_spokes[[species[[i]]]],
                                                   nk = nk[[species[[i]]]],
                                                   k = k[[species[[i]]]],
                                                   jacobians = jacobians,
                                                   mask = "positive",
                                                   threshold_method = threshold_method,
                                                   threshold = threshold,
                                                   tree = tree,
                                                   labels = labels,
                                                   defs = defs) %>% 
    mutate(sign = "positive")
  
  df_species_frac_neg <- prepare_cluster_fractions(datadir = datadir,
                                                   species = species[[i]],
                                                   structs = df_spokes[[species[[i]]]],
                                                   nk = nk[[species[[i]]]],
                                                   k = k[[species[[i]]]],
                                                   jacobians = jacobians,
                                                   mask = "negative",
                                                   threshold_method = threshold_method,
                                                   threshold = threshold,
                                                   tree = tree,
                                                   labels = labels,
                                                   defs = defs) %>% 
    mutate(sign = "negative",
           fvoxels_expr = -1*fvoxels_expr)
  
  cluster_fractions[[species[[i]]]] <- bind_rows(df_species_frac_pos,
                                                 df_species_frac_neg) %>% 
    mutate(species = species[[i]])
  
}

df_cluster_fractions <- prepare_spider_data(mouse = cluster_fractions[["mouse"]],
                                            human = cluster_fractions[["human"]],
                                            homologues = df_spokes)

tmp <- df_cluster_fractions %>% 
  select(species, sign, name, fvoxels_expr) %>% 
  pivot_wider(id_cols = c(name, species), names_from = sign, values_from = fvoxels_expr)

head(tmp)
```

```{r}
coord_radar <- function(theta = "x", start = 0, direction = 1, clip = "on") {
  theta <- match.arg(theta, c("x", "y"))
  r <- ifelse(theta == "x", "y", "x")
  ggproto(NULL, CoordPolar, theta = theta, r = r, start = start,
          direction = sign(direction), clip = clip,
          # This is the different bit
          is_linear = function(){TRUE})
}

```

```{r}
Adder <- ggproto("Adder", 
                 x = 0, 
                 add = function(self, n) {
                   self$x <- self$x + n
                   self$x
                   })

Adder
```

```{r}
coord_radar <- function (theta = "x", start = 0, direction = 1) 
{
  theta <- match.arg(theta, c("x", "y"))
  r <- if (theta == "x") 
    "y"
  else "x"

  #dirty
  rename_data <- function(coord, data) {
    if (coord$theta == "y") {
      plyr::rename(data, c("y" = "theta", "x" = "r"), warn_missing = FALSE)
    } else {
      plyr::rename(data, c("y" = "r", "x" = "theta"), warn_missing = FALSE)
    }
  }
  theta_rescale <- function(coord, x, scale_details) {
    rotate <- function(x) (x + coord$start) %% (2 * pi) * coord$direction
    rotate(scales::rescale(x, c(0, 2 * pi), scale_details$theta.range))
  }

  r_rescale <- function(coord, x, scale_details) {
    scales::rescale(x, c(0, 0.4), scale_details$r.range)
  }

  ggproto("CoordRadar", CoordPolar, theta = theta, r = r, start = start, 
          direction = sign(direction),
          is_linear = function(coord) TRUE,
          render_bg = function(self, scale_details, theme) {
            scale_details <- rename_data(self, scale_details)

            theta <- if (length(scale_details$theta.major) > 0)
              theta_rescale(self, scale_details$theta.major, scale_details)
            thetamin <- if (length(scale_details$theta.minor) > 0)
              theta_rescale(self, scale_details$theta.minor, scale_details)
            # thetafine <- seq(0, 2 * pi, length.out = 100)
            thetafine <- seq(0, 2 * pi, length.out = length(scale_details$theta.major))
            
            rfine <- c(r_rescale(self, scale_details$r.major, scale_details))

            # This gets the proper theme element for theta and r grid lines:
            #   panel.grid.major.x or .y
            majortheta <- paste("panel.grid.major.", self$theta, sep = "")
            minortheta <- paste("panel.grid.minor.", self$theta, sep = "")
            majorr     <- paste("panel.grid.major.", self$r,     sep = "")

            ggplot2:::ggname("grill", grid::grobTree(
              ggplot2:::element_render(theme, "panel.background"),
              if (length(theta) > 0) ggplot2:::element_render(
                theme, majortheta, name = "angle",
                x = c(rbind(0, 0.45 * sin(theta))) + 0.5,
                y = c(rbind(0, 0.45 * cos(theta))) + 0.5,
                id.lengths = rep(2, length(theta)),
                default.units = "native"
              ),
              if (length(thetamin) > 0) ggplot2:::element_render(
                theme, minortheta, name = "angle",
                x = c(rbind(0, 0.45 * sin(thetamin))) + 0.5,
                y = c(rbind(0, 0.45 * cos(thetamin))) + 0.5,
                id.lengths = rep(2, length(thetamin)),
                default.units = "native"
              ),

              ggplot2:::element_render(
                theme, majorr, name = "radius",
                x = rep(rfine, each = length(thetafine)) * sin(thetafine) + 0.5,
                y = rep(rfine, each = length(thetafine)) * cos(thetafine) + 0.5,
                id.lengths = rep(length(thetafine), length(rfine)),
                default.units = "native"
              )
            ))
          })
}
```

```{r fig.width = 6, fig.height = 6}
human_radar <- tmp %>% 
  filter(species == "human")

name_lvls <- levels(human_radar$name)
name_lvls <- c(" ", name_lvls)

human_radar$name <- as.character(human_radar$name)
human_radar_dummy <- filter(human_radar, name == "Cerebellar nuclei")
human_radar_dummy$name <- " "
human_radar <- rbind(human_radar, human_radar_dummy)
human_radar$name <- factor(human_radar$name, levels = name_lvls)

mouse_radar <- tmp %>% 
  filter(species == "mouse")

name_lvls <- levels(mouse_radar$name)
name_lvls <- c(" ", name_lvls)

mouse_radar$name <- as.character(mouse_radar$name)
mouse_radar_dummy <- filter(mouse_radar, name == "Cerebellar nuclei")
mouse_radar_dummy$name <- " "
mouse_radar <- rbind(mouse_radar, mouse_radar_dummy)
mouse_radar$name <- factor(mouse_radar$name, levels = name_lvls)

dat_radar <- bind_rows(human_radar, mouse_radar)
ggplot(dat_radar, aes(x = name, ymin = negative, ymax = positive, group = species, fill = species, col = species)) + 
  geom_ribbon(alpha = 0.1) + 
  # coord_radar(start = -pi*(1/4)) + 
    coord_radar(start = -pi*(1/8)) +
  # coord_radar(start = 0) + 
  scale_x_discrete(expand = expansion()) + 
  scale_y_continuous(breaks = seq(-1, 1, by = 0.5), limits = c(-1, 1)) + 
  labs(x = NULL) + 
  theme_bw() +
  theme(axis.ticks.x = element_blank(),
        axis.line.x = element_blank())
```

```{r fig.width = 4, fig.height = 4}
ggplot(dat_radar, aes(x = name, ymin = negative, ymax = positive, group = species, fill = species, col = species)) + 
  geom_ribbon(alpha = 0.1) + 
  coord_polar(start = -pi*(1/4)) + 
  scale_x_discrete(expand = expansion()) + 
  scale_y_continuous(breaks = seq(-1, 1, by = 0.5), limits = c(-1, 1)) + 
  theme_bw()
```

```{r}
tmp2 %>% 
  ggplot(aes(x = name, ymin = negative, ymax = positive, group = 1)) + 
  geom_ribbon() + 
  coord_radar(start = -pi*(1/4)) + 
  scale_x_discrete(expand = expansion()) + 
  scale_y_continuous(breaks = seq(-1, 1, by = 0.5), limits = c(-1, 1)) + 
  theme_bw()
```

```{r}
tmp %>% 
  filter(species == "human") %>% 
  ggplot(aes(x = name, ymin = negative, ymax = positive, group = 1)) + 
  geom_ribbon() +
  coord_radar() + 
  scale_y_continuous(breaks = seq(-1, 1, by = 0.5), limits = c(-1, 1)) + 
  theme_bw()
```

```{r}
tmp <- df_cluster_fractions %>% 
  select(species, sign, name, fvoxels_expr) %>% 
  filter(species == "human", sign == "positive") %>% 
  mutate(x = as.numeric(name),
         y = fvoxels_expr)

tmp
```

```{r}
coord_straightpolar <- function(theta = 'x', start = 0, direction = 1, clip = "on") {
  theta <- match.arg(theta, c("x", "y"))
  r <- if (theta == "x") 
    "y"
  else "x"
  ggproto(NULL, CoordPolar, theta = theta, r = r, start = start,
          direction = sign(direction), clip = clip,
          # This is the different bit
          is_linear = function(){TRUE})
}
```

```{r}
ggplot(tmp, aes(x = name, y = y, group = 1)) + 
  # geom_line() + 
  geom_area() + 
  coord_straightpolar() +
  # coord_polar() + 
  scale_y_continuous(breaks = seq(-1, 1, by = 0.2), limits = c(-1, 1))
```

```{r}
library(fmsb)

human_radar <- tmp %>% 
  filter(species == "human") %>% 
  select(name, human_max = positive, human_min = negative) %>% 
  mutate(Max = 1, Min = -1) %>% 
  column_to_rownames("name") %>% 
  as.matrix() %>% 
  t() %>% 
  as.data.frame()
 
human_radar_test <- human_radar[c("Max", "Min", "human_max"),]
radarchart(human_radar_test)
```

```{r}
nsteps <- 8
breaks <- seq(-1, 1, length.out = nsteps+1)
breaks_labels <- round(breaks, 2)
radarchart(df = human_radar_test,
           axistype = 1,
           seg = nsteps,
           pcol = "#00AFBB", 
           pfcol = scales::alpha("#00AFBB", 0.5),
           cglcol = "grey", cglty = 1,
           vlcex = 0.7, vlabels = colnames(human_radar_test),
           caxislabels = breaks_labels)
```

```{r}
df <- human_radar_test
maxmin <- TRUE
title <- ""
centerzero <- FALSE
seg <- 4

function (df, axistype = 0, seg = 4, pty = 16, pcol = 1:8, plty = 1:6, 
    plwd = 1, pdensity = NULL, pangle = 45, pfcol = NA, cglty = 3, 
    cglwd = 1, cglcol = "navy", axislabcol = "blue", title = "", 
    maxmin = TRUE, na.itp = TRUE, centerzero = FALSE, vlabels = NULL, 
    vlcex = NULL, caxislabels = NULL, calcex = NULL, paxislabels = NULL, 
    palcex = NULL, ...) 
{
    if (!is.data.frame(df)) {
        cat("The data must be given as dataframe.\n")
        return()
    }
    if ((n <- length(df)) < 3) {
        cat("The number of variables must be 3 or more.\n")
        return()
    }
    if (maxmin == FALSE) {
        dfmax <- apply(df, 2, max)
        dfmin <- apply(df, 2, min)
        df <- rbind(dfmax, dfmin, df)
    }
    plot(c(-1.2, 1.2), c(-1.2, 1.2), type = "n", frame.plot = FALSE, 
        axes = FALSE, xlab = "", ylab = "", main = title, asp = 1)
    theta <- seq(90, 450, length = n + 1) * pi/180
    theta <- theta[1:n]
    xx <- cos(theta)
    yy <- sin(theta)
    CGap <- ifelse(centerzero, 0, 1)
    for (i in 0:seg) {
        polygon(xx * (i + CGap)/(seg + CGap), yy * (i + CGap)/(seg + 
            CGap), lty = cglty, lwd = cglwd, border = cglcol)
        if (axistype == 1 | axistype == 3) 
            CAXISLABELS <- paste(i/seg * 100, "(%)")
        if (axistype == 4 | axistype == 5) 
            CAXISLABELS <- sprintf("%3.2f", i/seg)
        if (!is.null(caxislabels) & (i < length(caxislabels))) 
            CAXISLABELS <- caxislabels[i + 1]
        if (axistype == 1 | axistype == 3 | axistype == 4 | axistype == 
            5) {
            if (is.null(calcex)) 
                text(-0.05, (i + CGap)/(seg + CGap), CAXISLABELS, 
                  col = axislabcol)
            else text(-0.05, (i + CGap)/(seg + CGap), CAXISLABELS, 
                col = axislabcol, cex = calcex)
        }
    }
    if (centerzero) {
        arrows(0, 0, xx * 1, yy * 1, lwd = cglwd, lty = cglty, 
            length = 0, col = cglcol)
    }
    else {
        arrows(xx/(seg + CGap), yy/(seg + CGap), xx * 1, yy * 
            1, lwd = cglwd, lty = cglty, length = 0, col = cglcol)
    }
    PAXISLABELS <- df[1, 1:n]
    if (!is.null(paxislabels)) 
        PAXISLABELS <- paxislabels
    if (axistype == 2 | axistype == 3 | axistype == 5) {
        if (is.null(palcex)) 
            text(xx[1:n], yy[1:n], PAXISLABELS, col = axislabcol)
        else text(xx[1:n], yy[1:n], PAXISLABELS, col = axislabcol, 
            cex = palcex)
    }
    VLABELS <- colnames(df)
    if (!is.null(vlabels)) 
        VLABELS <- vlabels
    if (is.null(vlcex)) 
        text(xx * 1.2, yy * 1.2, VLABELS)
    else text(xx * 1.2, yy * 1.2, VLABELS, cex = vlcex)
    series <- length(df[[1]])
    SX <- series - 2
    if (length(pty) < SX) {
        ptys <- rep(pty, SX)
    }
    else {
        ptys <- pty
    }
    if (length(pcol) < SX) {
        pcols <- rep(pcol, SX)
    }
    else {
        pcols <- pcol
    }
    if (length(plty) < SX) {
        pltys <- rep(plty, SX)
    }
    else {
        pltys <- plty
    }
    if (length(plwd) < SX) {
        plwds <- rep(plwd, SX)
    }
    else {
        plwds <- plwd
    }
    if (length(pdensity) < SX) {
        pdensities <- rep(pdensity, SX)
    }
    else {
        pdensities <- pdensity
    }
    if (length(pangle) < SX) {
        pangles <- rep(pangle, SX)
    }
    else {
        pangles <- pangle
    }
    if (length(pfcol) < SX) {
        pfcols <- rep(pfcol, SX)
    }
    else {
        pfcols <- pfcol
    }
    for (i in 3:series) {
        xxs <- xx
        yys <- yy
        scale <- CGap/(seg + CGap) + (df[i, ] - df[2, ])/(df[1, 
            ] - df[2, ]) * seg/(seg + CGap)
        if (sum(!is.na(df[i, ])) < 3) {
            cat(sprintf("[DATA NOT ENOUGH] at %d\n%g\n", i, df[i, 
                ]))
        }
        else {
            for (j in 1:n) {
                if (is.na(df[i, j])) {
                  if (na.itp) {
                    left <- ifelse(j > 1, j - 1, n)
                    while (is.na(df[i, left])) {
                      left <- ifelse(left > 1, left - 1, n)
                    }
                    right <- ifelse(j < n, j + 1, 1)
                    while (is.na(df[i, right])) {
                      right <- ifelse(right < n, right + 1, 1)
                    }
                    xxleft <- xx[left] * CGap/(seg + CGap) + 
                      xx[left] * (df[i, left] - df[2, left])/(df[1, 
                        left] - df[2, left]) * seg/(seg + CGap)
                    yyleft <- yy[left] * CGap/(seg + CGap) + 
                      yy[left] * (df[i, left] - df[2, left])/(df[1, 
                        left] - df[2, left]) * seg/(seg + CGap)
                    xxright <- xx[right] * CGap/(seg + CGap) + 
                      xx[right] * (df[i, right] - df[2, right])/(df[1, 
                        right] - df[2, right]) * seg/(seg + CGap)
                    yyright <- yy[right] * CGap/(seg + CGap) + 
                      yy[right] * (df[i, right] - df[2, right])/(df[1, 
                        right] - df[2, right]) * seg/(seg + CGap)
                    if (xxleft > xxright) {
                      xxtmp <- xxleft
                      yytmp <- yyleft
                      xxleft <- xxright
                      yyleft <- yyright
                      xxright <- xxtmp
                      yyright <- yytmp
                    }
                    xxs[j] <- xx[j] * (yyleft * xxright - yyright * 
                      xxleft)/(yy[j] * (xxright - xxleft) - xx[j] * 
                      (yyright - yyleft))
                    yys[j] <- (yy[j]/xx[j]) * xxs[j]
                  }
                  else {
                    xxs[j] <- 0
                    yys[j] <- 0
                  }
                }
                else {
                  xxs[j] <- xx[j] * CGap/(seg + CGap) + xx[j] * 
                    (df[i, j] - df[2, j])/(df[1, j] - df[2, j]) * 
                    seg/(seg + CGap)
                  yys[j] <- yy[j] * CGap/(seg + CGap) + yy[j] * 
                    (df[i, j] - df[2, j])/(df[1, j] - df[2, j]) * 
                    seg/(seg + CGap)
                }
            }
            if (is.null(pdensities)) {
                polygon(xxs, yys, lty = pltys[i - 2], lwd = plwds[i - 
                  2], border = pcols[i - 2], col = pfcols[i - 
                  2])
            }
            else {
                polygon(xxs, yys, lty = pltys[i - 2], lwd = plwds[i - 
                  2], border = pcols[i - 2], density = pdensities[i - 
                  2], angle = pangles[i - 2], col = pfcols[i - 
                  2])
            }
            points(xx * scale, yy * scale, pch = ptys[i - 2], 
                col = pcols[i - 2])
        }
    }
}
```

```{r}
# df_cluster_fractions <- df_cluster_fractions %>% 
#   unite(col = "group_id",
#         species, cluster_id, sign,
#         sep = "-",
#         remove = FALSE)
```
