---
title: "Biological pathway modules associated with mouse clusters"
author: "Antoine Beauchamp"
date: "`r Sys.Date()`"
output: html_document
---

# Initialization

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r packages}
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(grid))
suppressPackageStartupMessages(library(gridExtra))
suppressPackageStartupMessages(library(patchwork))
suppressPackageStartupMessages(library(ggalluvial))
suppressPackageStartupMessages(library(pheatmap))
suppressPackageStartupMessages(library(rcartocolor))
suppressPackageStartupMessages(library(RColorBrewer))
suppressPackageStartupMessages(library(viridis))
suppressPackageStartupMessages(library(viridisLite))
```

```{r environment}
SRCPATH <- Sys.getenv("SRCPATH")
PROJECTPATH <- Sys.getenv("PROJECTPATH")

if (PROJECTPATH == "") {
  PROJECTPATH <- "/projects/abeauchamp/Projects/MouseHumanMapping/Paper_ClusteringAutism/main"
  Sys.setenv(PROJECTPATH = PROJECTPATH)
}

if (SRCPATH == "") {
  SRCPATH <- "/projects/abeauchamp/Projects/MouseHumanMapping/Paper_ClusteringAutism/main/src"
  Sys.setenv(SRCPATH = SRCPATH)
}
```

```{r functions}
source(file.path(SRCPATH, "analysis.R"))
```

```{r params}
# Max number of clusters
nk_max <- 10

# Database versions
stringdb_version <- "12.0"
bader_version <- "2023"
stringdb_threshold <- 950

# Output directory
output_dir <- paste("StringDB", stringdb_version, "Bader", bader_version, stringdb_threshold, sep = "_")
output_dir <- file.path("outputs", "mouse_cluster_pathways", output_dir, "")
if (!(dir.exists(output_dir))) {dir.create(output_dir, recursive = TRUE)}
```

```{r import-pathway-enrichment}
# Base directory for pathway data files
pathways_dir <- file.path(PROJECTPATH, "data/mouse/enrichment/")
pathways_dir <- file.path(pathways_dir, 
                          paste("StringDB", stringdb_version, 
                                "Bader", bader_version, 
                                sep = "_"))
pathways_dir <- file.path(pathways_dir, "NeighbourhoodEnrichment")
pathways_dir <- file.path(pathways_dir, stringdb_threshold)

if (length(list.files(pathways_dir)) == 0) {
  stop("No files in specified directory")
}

# Prefix for pathway data files
pathways_file_prefix <- "NewBader_enrichment_clusterneighbourhood_vs_brain_all"

# Pathway IDs for pre-selected pathway set
if (bader_version == "2020") {
  pathway_ids <- c("ADHERENS JUNCTIONS INTERACTIONS%REACTOME%R-HSA-418990.2",
                   "AXON GUIDANCE%REACTOME DATABASE ID RELEASE 71%422475",
                   "CA2+ PATHWAY%REACTOME DATABASE ID RELEASE 71%4086398",
                   "CHROMATIN ORGANIZATION%REACTOME DATABASE ID RELEASE 71%4839726",
                   "GAP JUNCTION TRAFFICKING AND REGULATION%REACTOME%R-HSA-157858.1",
                   "GENE EXPRESSION (TRANSCRIPTION)%REACTOME DATABASE ID RELEASE 71%74160",
                   "GENERIC TRANSCRIPTION PATHWAY%REACTOME%R-HSA-212436.9",
                   "LONG-TERM POTENTIATION%REACTOME DATABASE ID RELEASE 71%9620244",
                   "MAPK FAMILY SIGNALING CASCADES%REACTOME DATABASE ID RELEASE 71%5683057",
                   "MTOR SIGNALLING%REACTOME%R-HSA-165159.5",
                   "PROTEIN-PROTEIN INTERACTIONS AT SYNAPSES%REACTOME DATABASE ID RELEASE 71%6794362",
                   "SIGNALING BY ERBB2%REACTOME DATABASE ID RELEASE 71%1227986",
                   "SIGNALING BY ERBB4%REACTOME DATABASE ID RELEASE 71%1236394",
                   "SIGNALING BY HEDGEHOG%REACTOME DATABASE ID RELEASE 71%5358351",
                   "SIGNALING BY GPCR%REACTOME%R-HSA-372790.4",
                   "SIGNALING BY NOTCH%REACTOME DATABASE ID RELEASE 71%157118",
                   "SIGNALING BY VEGF%REACTOME DATABASE ID RELEASE 71%194138",
                   "SIGNALING BY WNT%REACTOME%R-HSA-195721.5",
                   "TIGHT JUNCTION INTERACTIONS%REACTOME DATABASE ID RELEASE 71%420029",
                   "TRANSMISSION ACROSS CHEMICAL SYNAPSES%REACTOME%R-HSA-112315.5")
} else if (bader_version == "2023") {
  pathway_ids <- c("ADHERENS JUNCTIONS INTERACTIONS%REACTOME DATABASE ID RELEASE 38%418990",
                   "AXON GUIDANCE%REACTOME%R-HSA-422475.7",
                   "CA2+ PATHWAY%REACTOME%R-HSA-4086398.4",
                   "CHROMATIN ORGANIZATION%REACTOME DATABASE ID RELEASE 38%4839726",
                   "GAP JUNCTION TRAFFICKING AND REGULATION%REACTOME%R-HSA-157858.2",
                   "GENE EXPRESSION (TRANSCRIPTION)%REACTOME%R-HSA-74160.8",
                   "GENERIC TRANSCRIPTION PATHWAY%REACTOME%R-HSA-212436.12",
                   "LONG-TERM POTENTIATION%REACTOME DATABASE ID RELEASE 38%9620244",
                   "MAPK FAMILY SIGNALING CASCADES%REACTOME%R-HSA-5683057.4",
                   "MTOR SIGNALLING%REACTOME%R-HSA-165159.7",
                   "PROTEIN-PROTEIN INTERACTIONS AT SYNAPSES%REACTOME DATABASE ID RELEASE 38%6794362",
                   "SIGNALING BY ERBB2%REACTOME DATABASE ID RELEASE 38%1227986",
                   "SIGNALING BY ERBB4%REACTOME DATABASE ID RELEASE 38%1236394",
                   "SIGNALING BY GPCR%REACTOME DATABASE ID RELEASE 38%372790",
                   "SIGNALING BY HEDGEHOG%REACTOME DATABASE ID RELEASE 38%5358351",
                   "SIGNALING BY NOTCH%REACTOME%R-HSA-157118.6",
                   "SIGNALING BY VEGF%REACTOME%R-HSA-194138.3",
                   "SIGNALING BY WNT%REACTOME DATABASE ID RELEASE 38%195721",
                   "TIGHT JUNCTION INTERACTIONS%REACTOME DATABASE ID RELEASE 38%420029",
                   "TRANSMISSION ACROSS CHEMICAL SYNAPSES%REACTOME%R-HSA-112315.7")
} else {
  stop()
}

# Import mouse pathway enrichment files
# Iterate over cluster solutions
list_pathways <- vector(mode = "list", length = nk_max-1)
names(list_pathways) <- 2:nk_max
for (nk in 2:nk_max) {
  
  # Iterate over cluster number
  list_pathways[[as.character(nk)]] <- vector(mode = "list", length = nk)
  for (k in 1:nk) {
    pathways_file <- paste(pathways_file_prefix, nk, k, stringdb_threshold, sep = "_")
    pathways_file <- paste0(pathways_file, ".csv")
    pathways_file <- file.path(pathways_dir, pathways_file)
    list_pathways[[as.character(nk)]][[k]] <- read_csv(pathways_file, show_col_types = FALSE)  
    
    list_pathways[[as.character(nk)]][[k]] <- list_pathways[[as.character(nk)]][[k]] %>% 
      mutate(NLQ = -log10(adj.P.Val))
  }
  
  # Combine clusters per solution
  list_pathways[[as.character(nk)]] <- list_pathways[[as.character(nk)]] %>% 
    reduce(.f = bind_rows) %>% 
    rename(pathway = Title,
           k = cluster) %>% 
    mutate(nk = nk) %>% 
    unite(col = "cluster_id", nk, k, 
          sep = "-", remove = FALSE)
  
}
```

```{r pathway-info}
df_pathway_info <- list_pathways[[1]] %>% 
  filter(ID %in% pathway_ids) %>% 
  select(ID, pathway) %>% 
  distinct() %>% 
  arrange(pathway)

# Create pathway acronyms
df_pathway_info[["acronym"]] <- c(
  "AJI", "AG", "Ca2+", "CO",
  "GJTR", "GE", "GTP", "LTP",
  "MAPK", "MTOR", "PPIS", "ERBB2",
  "ERBB4", "GPCR", "HEDGEHOG", "NOTCH",
  "VEGF", "WNT", "TJI", "TACS"
)
```


# Enrichment analysis of pre-selected pathways

## Pathway enrichment polar plots

```{r generate-polar-plots}
# Polar plot labels
polar_plot_lvls <- c(" ", df_pathway_info[["pathway"]])

# Create polar plot data frames
list_polar_plots <- vector(mode = "list", length = length(list_pathways))
names(list_polar_plots) <- names(list_pathways)
for (i in 1:length(list_polar_plots)) {
  
  df_pathways_nk <- list_pathways[[i]] %>% 
    filter(pathway %in% df_pathway_info[["pathway"]])
  
  df_polar_plot_tmp <- df_pathways_nk %>% 
    mutate(pathway = as.character(pathway)) %>% 
    filter(pathway == polar_plot_lvls[length(polar_plot_lvls)]) %>% 
    mutate(pathway = " ")
  
  list_polar_plots[[i]] <- df_pathways_nk %>% 
    bind_rows(df_polar_plot_tmp) %>% 
    mutate(pathway = factor(pathway, levels = polar_plot_lvls))
  
}

# Polar plot graphical parameters
nspokes <- length(polar_plot_lvls) - 1
theta_start <- -(2*pi)/nspokes
breaks_start <- 0
E_breaks_step <- 5
q_breaks_step <- 1

# Polar plot palette
polar_palette <- carto_pal(n = 12, name = "Bold")

# Enrichment and q-value clamping thresholds
E_threshold <- 30
q_threshold <- 10

# Iterate over clusters
for (i in 1:length(list_polar_plots)) {
  
  # Radial labels
  E_max <- ceiling(max(list_polar_plots[[i]][["E"]]))
  q_max <- ceiling(max(list_polar_plots[[i]][["NLQ"]]))
  
  E_max <- ifelse(E_max > E_threshold, E_threshold, E_max)
  q_max <- ifelse(q_max > q_threshold, q_threshold, q_max)
  
  E_breaks_end <- E_max - E_max %% E_breaks_step + E_breaks_step
  q_breaks_end <- q_max - q_max %% q_breaks_step + q_breaks_step
  
  E_polar_breaks <- seq(breaks_start, E_breaks_end, by = E_breaks_step)
  q_polar_breaks <- seq(breaks_start, q_breaks_end, by = q_breaks_step)
  
  E_polar_labels <- tibble(pathway = polar_plot_lvls[2],
                           breaks = E_polar_breaks)
  
  q_polar_labels <- tibble(pathway = polar_plot_lvls[2],
                           breaks = q_polar_breaks)
  
  df_polar_plot <- list_polar_plots[[i]] %>% 
    select(k, pathway, E, NLQ) %>% 
    mutate(E = ifelse(E > E_threshold, E_threshold, E),
           NLQ = ifelse(NLQ > q_threshold, q_threshold, NLQ),
           k = factor(k))
  
  # Enrichment polar plot
  E_polar_plot <- ggplot(df_polar_plot, 
                         aes(x = pathway, 
                             ymin = 0, ymax = E, 
                             group = k, 
                             fill = k, 
                             col = k)) + 
    geom_ribbon(alpha = 0.2) + 
    geom_text(data = E_polar_labels,
              inherit.aes = FALSE,
              mapping = aes(x = pathway,
                            y = breaks,
                            label = breaks)) +
    coord_radar(start = theta_start, clip = "off") + 
    scale_x_discrete(expand = expansion()) + 
    scale_y_continuous(breaks = E_polar_breaks) +
    scale_fill_manual(values = polar_palette[1:(i+1)]) +
    scale_colour_manual(values = polar_palette[1:(i+1)]) +
    labs(x = NULL,
         fill = "k",
         col = "k") + 
    theme_bw()
  
  # -log10(q) polar plot
  q_polar_plot <- ggplot(df_polar_plot, 
                         aes(x = pathway, 
                             ymin = 0, ymax = NLQ, 
                             group = k, 
                             fill = k, 
                             col = k)) + 
    geom_ribbon(alpha = 0.2) + 
    geom_text(data = q_polar_labels,
              inherit.aes = FALSE,
              mapping = aes(x = pathway,
                            y = breaks,
                            label = breaks)) +
    coord_radar(start = theta_start, clip = "off") + 
    scale_x_discrete(expand = expansion()) + 
    scale_y_continuous(breaks = q_polar_breaks) +
    scale_fill_manual(values = polar_palette[1:(i+1)]) +
    scale_colour_manual(values = polar_palette[1:(i+1)]) +
    labs(x = NULL,
         fill = "k",
         col = "k") + 
    theme_bw()
  
  # Collect both polar plots
  polar_plot <- (E_polar_plot | q_polar_plot) +
    plot_layout(guides = "collect") &
    theme(axis.ticks.x = element_blank(),
          axis.line.x = element_blank(),
          axis.text.x = element_text(size = 6),
          axis.text.y = element_blank(),
          axis.ticks.y = element_blank(),
          axis.title.y = element_blank(),
          panel.border = element_blank(),
          legend.position = "bottom")
  
  # Write to file
  outfile <- paste0("pathways_preselected_polar_nk_", names(list_polar_plots)[i], ".pdf")
  outfile <- file.path(output_dir, outfile)
  pdf(file = outfile,
      width = unit(12, "in"),
      height = unit(6, "in"))
  print(polar_plot)
  dev.off()
  
}
```


## Pathway enrichment Sankey plots

```{r import-clusters}
# Import mouse clusters
cluster_file <- file.path(PROJECTPATH, "data/mouse/derivatives/v3/107/clusters/resolution_0.2/clusters.csv")
df_clusters <- read_csv(cluster_file, show_col_types = FALSE)
colnames(df_clusters) <- c("ID", str_c("nk", 2:nk_max))

# Convert mouse clusters to long format
df_clusters_long <- df_clusters %>% 
  pivot_longer(cols = -ID, names_to = "nk_name", values_to = "k") %>% 
  mutate(nk = str_remove(nk_name, "nk"),
         nk = as.numeric(nk),
         nk = factor(nk),
         k = factor(k))
```

```{r generate-sankey-plots}
# Iterate over pathways
for (i in 1:length(pathway_ids)) {
  
  # Filter for given pathway in each cluster
  list_pathway_i <- vector(mode = "list", length = length(list_pathways))
  for (j in 1:length(list_pathway_i)) {
    list_pathway_i[[j]] <- list_pathways[[j]] %>% 
      filter(ID == pathway_ids[i])
  }
  
  # Reduce all cluster enrichment for pathway i into one df
  df_pathway_i <- list_pathway_i %>% 
    bind_rows() %>% 
    select(-ID) %>% 
    mutate(nk = factor(nk, levels = 2:nk_max),
           k = factor(k, levels = 1:nk_max),
           E = ifelse(E > E_threshold, E_threshold, E)) %>% 
    right_join(df_clusters_long, by = c("nk", "k"))
  
  # Generate Sankey plot
  p_sankey_pathway <- ggplot(df_pathway_i, 
                             aes(x = nk, 
                                 stratum = k,
                                 fill = E,
                                 alluvium = ID)) + 
    geom_flow(stat = "alluvium", aes.flow = "forward") + 
    geom_stratum() + 
    scale_fill_gradientn(colors = brewer.pal(n = 9, name = "OrRd")[3:9],
                         limits = c(0, E_threshold)) + 
    labs(x = "Number of clusters",
         y = "Number of models",
         fill = "Enrichment (clamped)",
         title = unique(df_pathway_i[["pathway"]])) + 
    theme_bw() + 
    theme(panel.grid.major.x = element_blank())
  
  # Output file name
  outfile <- "pathways_preselected_sankey_" %>%
    str_c(df_pathway_i %>% 
            pull(pathway) %>% 
            unique() %>% 
            str_to_lower() %>% 
            str_remove_all("[()]") %>% 
            str_replace_all(" ", "_")) %>% 
    str_c(".pdf")
  outfile <- file.path(output_dir, outfile)
  
  # Export plot
  pdf(file = outfile,
      width = unit(10, "inch"),
      height = unit(5, "inch"))
  print(p_sankey_pathway)
  dev.off()
  
}
```


## Pathway enrichment heatmaps

### Mouse-human cluster similarity

```{r}
# POND-MICe and HBN-MICe pipeline outputs
param_ids <- c("375", "861")
names(param_ids) <- param_ids

# Similarity pipeline directory
pipeline_dir <- file.path(PROJECTPATH, "data/cross_species/v3/")

# Import similarity values
list_similarity <- map(.x = param_ids, 
                       .f = import_similarity, 
                       pipeline_dir = pipeline_dir)

# Import similarity permutations
list_permutations <- map(.x = param_ids, 
                         .f = import_similarity_permutations,
                         pipeline_dir = pipeline_dir)

# Evaluate significance
list_significance <- map2(.x = list_similarity, 
                          .y = list_permutations, 
                          .f = compute_similarity_significance, 
                          off_diag = 1)

list_significance <- map(.x = list_significance,
                         .f = function(x) {mutate(x, significant = pval < 0.05)})
```


### Enrichment heatmaps

```{r pathways-heatmap-E-proc}
# Reduce all pathway data frames into one
df_pathways_all <- bind_rows(list_pathways)

# Filter for cluster solutions with nk >= 4
df_pathways_nk_gt4 <- df_pathways_all %>% 
  filter(nk >= 4)

# Cluster order 
cluster_lvls <- df_pathways_nk_gt4 %>% 
  select(nk, k, cluster_id) %>% 
  distinct() %>% 
  arrange(nk, k) %>% 
  pull(cluster_id)

# Filter for desired pathways
# Compute normalized enrichment per pathway
df_pathways_nk_gt4_subset <- df_pathways_nk_gt4 %>% 
  filter(pathway %in% df_pathway_info[["pathway"]]) %>% 
  mutate(cluster_id = factor(cluster_id, levels = cluster_lvls),
         pathway = factor(pathway, levels = df_pathway_info[["pathway"]])) %>% 
  group_by(pathway) %>% 
  mutate(E_norm = E/max(E),
         NLQ_norm = NLQ/max(NLQ)) %>% 
  ungroup() %>% 
  mutate(E_norm = ifelse(is.nan(E_norm), 0, E_norm),
         NLQ_norm = ifelse(is.nan(NLQ_norm), 0, NLQ_norm))

# Convert pathway data frame into matrix 
mat_pathways_nk_gt4_subset <- df_pathways_nk_gt4_subset %>% 
  select(pathway, cluster_id, E_norm) %>% 
  pivot_wider(id_cols = pathway, 
              names_from = cluster_id, 
              values_from = E_norm) %>% 
  column_to_rownames("pathway") %>% 
  as.matrix()
```

```{r pathways-heatmap-E-clust}
# Generate clustered heatmap
pheatmap_out <- pheatmap(mat = mat_pathways_nk_gt4_subset,
                         cluster_col = FALSE,
                         cluster_rows = TRUE,
                         clustering_distance_rows = "euclidean",
                         cutree_rows = 4, 
                         silent = TRUE)

# Extract pathway clustering outputs
pheatmap_pathway_lvls <- pheatmap_out[["tree_row"]][["labels"]]
pheatmap_pathway_order <- pheatmap_out[["tree_row"]][["order"]]
pathway_lvls_clustered <- pheatmap_pathway_lvls[pheatmap_pathway_order]
```

```{r}
df_pathway_hclust <- tibble(wcss = hclust_wcss(x = t(mat_pathways_nk_gt4_subset))) %>% 
  mutate(nk = 1:nrow(.))

pathway_scree_plot <- ggplot(df_pathway_hclust,
                             mapping = aes(nk, y = wcss)) + 
  geom_line() + 
  geom_point() + 
  scale_x_continuous(breaks = seq(1, 20, by = 1)) + 
  labs(x = "Number of clusters",
       y = "Within-cluster sum of squared distance") + 
  theme_bw() +
  theme(panel.grid.minor.x = element_blank())

outfile <- "pathways_preselected_cluster_E_scree_plot.pdf"
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = unit(8, "in"),
    height = unit(4, "in"))
print(pathway_scree_plot)
dev.off()
```

```{r pathways-heatmap-E-clust}
# Level at which to cut the dendrogram
hclust_kcut <- 10

# Obtain pathway cluster order at selected solution
df_pathway_hclust <- cutree(pheatmap_out[["tree_row"]], k = hclust_kcut) %>% 
  enframe(name = "pathway", value = "pathway_cluster") 

# Relevel pathways to follow dendrogram order
df_pathway_cluster_lvls <- df_pathway_hclust %>% 
  mutate(pathway = factor(pathway, levels = pathway_lvls_clustered)) %>% 
  arrange(pathway) %>% 
  select(pathway_cluster) %>% 
  distinct() %>% 
  mutate(pathway_cluster_new = 1:nrow(.))

df_pathway_hclust <- df_pathway_hclust %>% 
  left_join(df_pathway_cluster_lvls, by = "pathway_cluster") %>% 
  select(-pathway_cluster, pathway_cluster = pathway_cluster_new)

# Extract dendrogram from pheatmap object
pathways_dendrogram_grob <- pheatmap_out[["gtable"]][["grobs"]][[1]]
pathways_dendrogram_grob[["gp"]] <- gpar(lwd = 0.75)
```

```{r pathways-heatmap-E-human-match}
df_sim_pvals <- list_significance[[1]] %>% 
  rename(human_cluster_id = img1_cluster_id,
         human_nk = img1_nk,
         human_k = img1_k,
         mouse_cluster_id = img2_cluster_id,
         mouse_nk = img2_nk,
         mouse_k = img2_k)

df_sig_nk <- df_sim_pvals %>%
  group_by(mouse_nk, mouse_k) %>% 
  summarise(nsignificant = sum(significant),
            .groups = "drop") %>%
  mutate(has_match = ifelse(nsignificant > 0, TRUE, FALSE),
         dummy = "y") %>% 
  select(nk = mouse_nk, k = mouse_k, has_match, dummy) %>% 
  filter(nk >= 4) %>% 
  unite(col = "cluster_id", "nk", "k", 
        sep = "-", remove = FALSE) %>% 
  mutate(nk = factor(nk, levels = 4:nk_max),
         k = factor(k, levels = 1:nk_max),
         cluster_id = factor(cluster_id, levels = cluster_lvls))

human_match_heatmap <- ggplot(df_sig_nk,
                              mapping = aes(x = k, 
                                            y = dummy, 
                                            fill = has_match)) + 
  geom_tile(col = "grey50") +
  facet_grid(.~nk, scales = "free", space = "free") + 
  scale_x_discrete(expand = expansion()) + 
  scale_y_discrete(expand = expansion()) +
  scale_fill_manual(values = brewer.pal(n = 9, name = "PuBu")[c(1, 9)], 
                    labels = c("No", "Yes")) + 
  labs(fill = "Human match") + 
  theme_bw() +
  theme(axis.text = element_blank(),
        axis.title = element_blank(),
        axis.ticks = element_blank())
```

```{r pathways-heatmap-E-enrichment}
# Join pathway enrichment information with pathway clusters
df_pathways_heatmap <- df_pathways_nk_gt4_subset %>% 
  left_join(df_pathway_hclust, by = "pathway") %>% 
  mutate(pathway = factor(pathway, levels = pathway_lvls_clustered))

# Clamped enrichment
E_threshold <- 45
df_pathways_heatmap <- df_pathways_heatmap %>% 
  mutate(E_clamped = ifelse(E > E_threshold, E_threshold, E))

# Heatmap palette
heatmap_palette_cols <- c("white", brewer.pal(n = 9, name = "OrRd")[3:9])
heatmap_palette <- colorRampPalette(colors = heatmap_palette_cols)(255)

# Generate heatmap
pathways_heatmap <- ggplot(df_pathways_heatmap, 
                           aes(x = factor(k), 
                               y = fct_rev(pathway), 
                               fill = E_clamped)) + 
  geom_tile(col = "grey60") +
  facet_grid(pathway_cluster~nk, scales = "free", space = "free") + 
  scale_x_discrete(expand = expansion()) + 
  scale_y_discrete(expand = expansion(), 
                   position = "right") + 
  scale_fill_gradientn(colors = heatmap_palette) +
  labs(x = "Mouse cluster",
       y = "Biological pathway module",
       fill = "Enrichment") +
  theme_bw() +
  theme(strip.background = element_blank(),
        strip.text = element_blank())
```

```{r pathways-heatmap-E-patchwork}
heatmap_patchwork <- (human_match_heatmap / pathways_heatmap) +
  plot_layout(heights = c(0.06, 0.94), guides = "collect") &
  theme(plot.margin = margin(l = 0))

heatmap_patchwork_grob <- patchworkGrob(heatmap_patchwork)
```

```{r generate-pathways-heatmap-E}
# Plot layout
pathways_layout <- rbind(c(01, 02),
                         c(03, 02),
                         c(04, 02))

# Plot grid dimensions
pathways_widths <- c(0.05, 0.95)
pathways_heights <- c(0.11, 0.80, 0.09)

empty_rect_grob <- rectGrob(gp = gpar(fill = NA))

# Plot arrange grob
pathways_grob <- arrangeGrob(zeroGrob(),
                             heatmap_patchwork_grob,
                             pathways_dendrogram_grob,
                             zeroGrob(),
                             layout_matrix = pathways_layout,
                             widths = unit(pathways_widths, "npc"),
                             heights = unit(pathways_heights, "npc"))

# Plot dimensions
pathways_width_in <- 12
pathways_height_in <- 5

# Plot dimensions with units
pathways_width_in <- unit(pathways_width_in, "in")
pathways_height_in <- unit(pathways_height_in, "in")

# Export plot
outfile <- paste("pathways_preselected_cluster_heatmap_E_motifs", hclust_kcut, sep = "_")
outfile <- paste0(outfile, ".pdf")
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = pathways_width_in,
    height = pathways_height_in)
grid.draw(pathways_grob)
dev.off()
```

```{r generate-pathways-heatmap-E-norm}
# Generate heatmap
pathways_heatmap_norm <- ggplot(df_pathways_heatmap, 
                                aes(x = factor(k), 
                                    y = fct_rev(pathway), 
                                    fill = E_norm)) + 
  geom_tile(col = "grey60") +
  facet_grid(pathway_cluster~nk, scales = "free", space = "free") + 
  scale_x_discrete(expand = expansion()) + 
  scale_y_discrete(expand = expansion(), 
                   position = "right") + 
  scale_fill_gradientn(colors = heatmap_palette) +
  labs(x = "Mouse cluster",
       y = "Biological pathway module",
       fill = "Enrichment") +
  theme_bw() +
  theme(strip.background = element_blank(),
        strip.text = element_blank(),
        plot.margin = margin(l = 0))

heatmap_patchwork_norm <- (human_match_heatmap / pathways_heatmap_norm) +
  plot_layout(heights = c(0.06, 0.94), guides = "collect") &
  theme(plot.margin = margin(l = 0))

heatmap_patchwork_norm_grob <- patchworkGrob(heatmap_patchwork_norm)

# Plot arrange grob
pathways_norm_grob <- arrangeGrob(zeroGrob(),
                                  heatmap_patchwork_norm_grob,
                                  pathways_dendrogram_grob,
                                  zeroGrob(),
                                  layout_matrix = pathways_layout,
                                  widths = unit(pathways_widths, "npc"),
                                  heights = unit(pathways_heights, "npc"))

outfile <- paste("pathways_preselected_cluster_heatmap_E_norm_motifs", hclust_kcut, sep = "_")
outfile <- paste0(outfile, ".pdf")
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = pathways_width_in,
    height = pathways_height_in)
grid.draw(pathways_norm_grob)
dev.off()
```

### Significance heatmaps

```{r pathways-heatmap-q-proc}
# Convert pathway data frame into matrix 
mat_pathways_nk_gt4_subset <- df_pathways_nk_gt4_subset %>% 
  select(pathway, cluster_id, NLQ_norm) %>% 
  pivot_wider(id_cols = pathway, 
              names_from = cluster_id, 
              values_from = NLQ_norm) %>% 
  column_to_rownames("pathway") %>% 
  as.matrix()
```

```{r pathways-heatmap-q-wcss}
df_pathway_hclust <- tibble(wcss = hclust_wcss(x = t(mat_pathways_nk_gt4_subset))) %>% 
  mutate(nk = 1:nrow(.))

pathway_scree_plot <- ggplot(df_pathway_hclust,
                             mapping = aes(nk, y = wcss)) + 
  geom_line() + 
  geom_point() + 
  scale_x_continuous(breaks = seq(1, 20, by = 1)) + 
  labs(x = "Number of clusters",
       y = "Within-cluster sum of squared distance") + 
  theme_bw() +
  theme(panel.grid.minor.x = element_blank())

outfile <- "pathways_preselected_cluster_NLQ_scree_plot.pdf"
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = unit(8, "in"),
    height = unit(4, "in"))
print(pathway_scree_plot)
dev.off()
```

```{r pathways-heatmap-q-clust}
# Generate clustered heatmap
pheatmap_out <- pheatmap(mat = mat_pathways_nk_gt4_subset,
                         cluster_col = FALSE,
                         cluster_rows = TRUE,
                         clustering_distance_rows = "euclidean",
                         cutree_rows = 4, 
                         silent = TRUE)

# Extract pathway clustering outputs
pheatmap_pathway_lvls <- pheatmap_out[["tree_row"]][["labels"]]
pheatmap_pathway_order <- pheatmap_out[["tree_row"]][["order"]]
pathway_lvls_clustered <- pheatmap_pathway_lvls[pheatmap_pathway_order]

# Clustering order for pathway labels
# pathway_label_lvls_clustered <- df_pathway_labels %>% 
#   mutate(pathway = factor(pathway, levels = pathway_lvls_clustered)) %>% 
#   arrange(pathway) %>% 
#   pull(label)

# Level at which to cut the dendrogram
hclust_kcut <- 10

# Obtain pathway cluster order at selected solution
df_pathway_hclust <- cutree(pheatmap_out[["tree_row"]], k = hclust_kcut) %>% 
  enframe(name = "pathway", value = "pathway_cluster") 

# Relevel pathways to follow dendrogram order
df_pathway_cluster_lvls <- df_pathway_hclust %>% 
  mutate(pathway = factor(pathway, levels = pathway_lvls_clustered)) %>% 
  arrange(pathway) %>% 
  select(pathway_cluster) %>% 
  distinct() %>% 
  mutate(pathway_cluster_new = 1:nrow(.))

df_pathway_hclust <- df_pathway_hclust %>% 
  left_join(df_pathway_cluster_lvls, by = "pathway_cluster") %>% 
  select(-pathway_cluster, pathway_cluster = pathway_cluster_new)

# Extract dendrogram from pheatmap object
pathways_dendrogram_grob <- pheatmap_out[["gtable"]][["grobs"]][[1]]
pathways_dendrogram_grob[["gp"]] <- gpar(lwd = 0.75)
```

```{r generate-pathways-heatmap-q}
# Join pathway enrichment information with pathway clusters
df_pathways_heatmap <- df_pathways_nk_gt4_subset %>% 
  left_join(df_pathway_hclust, by = "pathway") %>% 
  mutate(pathway = factor(pathway, levels = pathway_lvls_clustered))

# Clamped enrichment
NLQ_threshold <- 30
df_pathways_heatmap <- df_pathways_heatmap %>% 
  mutate(NLQ_clamped = ifelse(NLQ > NLQ_threshold, NLQ_threshold, NLQ))

heatmap_palette_cols <- brewer.pal(n = 9, name = "OrRd")[2:9]
heatmap_palette <- colorRampPalette(colors = heatmap_palette_cols)(255)

# Generate heatmap
pathways_heatmap <- ggplot(df_pathways_heatmap, 
                           aes(x = factor(k), 
                               y = fct_rev(pathway), 
                               fill = NLQ_clamped)) + 
  geom_tile(col = "grey60") +
  facet_grid(pathway_cluster~nk, scales = "free", space = "free") + 
  scale_x_discrete(expand = expansion()) + 
  scale_y_discrete(expand = expansion(), 
                   position = "right") + 
  scale_fill_gradientn(colors = heatmap_palette,
                       limits = c(2, NLQ_threshold),
                       na.value = "grey95") +
  # scale_fill_distiller(palette = "OrRd",
  # direction = 1,
  # limits = c(2, NLQ_threshold),
  # na.value = "grey95") + 
  labs(x = "Mouse cluster",
       y = "Biological pathway module",
       fill = "-log10(q)") +
  theme_bw() +
  theme(strip.background = element_blank(),
        strip.text = element_blank())

heatmap_patchwork <- (human_match_heatmap / pathways_heatmap) +
  plot_layout(heights = c(0.06, 0.94), guides = "collect") &
  theme(plot.margin = margin(l = 0))

heatmap_patchwork_grob <- patchworkGrob(heatmap_patchwork)

# Plot layout
pathways_layout <- rbind(c(01, 02),
                         c(03, 02),
                         c(04, 02))

# Plot grid dimensions
pathways_widths <- c(0.05, 0.95)
pathways_heights <- c(0.11, 0.80, 0.09)

empty_rect_grob <- rectGrob(gp = gpar(fill = NA))

# Plot arrange grob
pathways_grob <- arrangeGrob(zeroGrob(),
                             heatmap_patchwork_grob,
                             pathways_dendrogram_grob,
                             zeroGrob(),
                             layout_matrix = pathways_layout,
                             widths = unit(pathways_widths, "npc"),
                             heights = unit(pathways_heights, "npc"))

# Plot dimensions
pathways_width_in <- 12
pathways_height_in <- 5

# Plot dimensions with units
pathways_width_in <- unit(pathways_width_in, "in")
pathways_height_in <- unit(pathways_height_in, "in")

# Export plot
outfile <- paste("pathways_preselected_cluster_heatmap_NLQ_motifs", hclust_kcut, sep = "_")
outfile <- paste0(outfile, ".pdf")
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = pathways_width_in,
    height = pathways_height_in)
grid.draw(pathways_grob)
dev.off()
```

```{r generate-pathways-heatmap-q-norm}
# Generate heatmap
pathways_heatmap_norm <- ggplot(df_pathways_heatmap, 
                                aes(x = factor(k), 
                                    y = fct_rev(pathway), 
                                    fill = NLQ_norm)) + 
  geom_tile(col = "grey60") +
  facet_grid(pathway_cluster~nk, scales = "free", space = "free") + 
  scale_x_discrete(expand = expansion()) + 
  scale_y_discrete(expand = expansion(), 
                   position = "right") + 
  scale_fill_gradientn(colors = heatmap_palette) +
  labs(x = "Mouse cluster",
       y = "Biological pathway module",
       fill = "-log10(q)") +
  theme_bw() +
  theme(strip.background = element_blank(),
        strip.text = element_blank(),
        plot.margin = margin(l = 0))

heatmap_patchwork_norm <- (human_match_heatmap / pathways_heatmap_norm) +
  plot_layout(heights = c(0.06, 0.94), guides = "collect") &
  theme(plot.margin = margin(l = 0))

heatmap_patchwork_norm_grob <- patchworkGrob(heatmap_patchwork_norm)

# Plot arrange grob
pathways_norm_grob <- arrangeGrob(zeroGrob(),
                                  heatmap_patchwork_norm_grob,
                                  pathways_dendrogram_grob,
                                  zeroGrob(),
                                  layout_matrix = pathways_layout,
                                  widths = unit(pathways_widths, "npc"),
                                  heights = unit(pathways_heights, "npc"))

outfile <- paste("pathways_preselected_cluster_heatmap_NLQ_norm_motifs", hclust_kcut, sep = "_")
outfile <- paste0(outfile, ".pdf")
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = pathways_width_in,
    height = pathways_height_in)
grid.draw(pathways_norm_grob)
dev.off()
```


# All pathways

What is the proper way to look at this? What am I looking for? For each cluster, what are the most enriched pathways? Maybe start with one cluster to figure out what it is that I want to do. 

```{r}
df_pathways_all_nk_geq4 <- df_pathways_all %>% 
  filter(nk >= 4)

nhighest <- 20

list_pathways_all_topn <- vector(mode = "list", length = length(cluster_lvls))
for (i in 1:length(list_pathways_all_topn)) {
  list_pathways_all_topn[[i]] <- df_pathways_all_nk_geq4 %>% 
    filter(cluster_id == cluster_lvls[i]) %>% 
    arrange(rank) %>% 
    head(n = nhighest)
}

df_pathways_all_topn <- bind_rows(list_pathways_all_topn)

top_pathway_lvls <- df_pathways_all_topn %>% 
  group_by(pathway) %>% 
  count() %>% 
  arrange(desc(n)) %>% 
  pull(pathway)

df_pathways_all_topn <- df_pathways_all_topn %>%
  mutate(pathway = factor(pathway, levels = top_pathway_lvls),
         k = factor(k),
         nk = factor(nk),
         cluster_id = factor(cluster_id, levels = cluster_lvls),
         NLQ = ifelse(NLQ > 20, 20, NLQ))

heatmap_topn_palette_cols <- carto_pal(n = 7, "BurgYl")
heatmap_topn_palette <- colorRampPalette(colors = heatmap_topn_palette_cols)(255)

pathways_heatmap_topn <- ggplot(df_pathways_all_topn,
                                aes(x = k, 
                                    y = fct_rev(pathway), 
                                    fill = NLQ)) + 
  geom_tile(col = "grey60") + 
  facet_grid(.~nk, scales = "free", space = "free") +
  scale_x_discrete(expand = expansion()) +
  scale_y_discrete(expand = expansion()) +
  scale_fill_gradientn(colors = heatmap_topn_palette,
                       limits = c(1.3, 20)) +
  labs(y = "Biological pathway module") + 
  theme_bw() +
  theme(axis.text = element_text(size = 6))

outfile <- paste("pathways_heatmap_top", nhighest, sep = "_")
outfile <- paste0(outfile, ".pdf")
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = unit(10, "in"),
    height = unit(20, "in"))
print(pathways_heatmap_topn)
dev.off()
```

This is a lot of pathways. Looking at the top 20 pathways in each cluster returns 165 pathways. I need to filter this down in some way. Two things I can think of: 
1. Look only at those clusters that have human matches. 
2. Some sort of thresholding based on the number of genes in a given pathway. Presumably the more general pathways will be associated with more genes. 


This should be contained in one of the hypergeometric distribution parameters. 
N is the background set, i.e. the set of all genes we're testing against. 
n is the number of genes in the cluster neighbourhood that are also in the background set. 
B is the number of genes in the target set, i.e. the set of genes associated with the given molecular pathway. I think this is the value I'm looking for. 
b is the number of genes in the cluster neighbourhood that are also in the target set. 

Something's weird with these values. Some of the pathways have B = 0, which means there are no genes in the set? And then we're running a test on that. That doesn't make sense. 

```{r}
B <- sort(df_pathways_all_nk_geq4[["B"]])
B_max <- max(B)
B_min <- 0
B_n <- 1e3
B_seq <- seq(B_min, B_max, length.out = B_n)
B_ecdf <- numeric(length(B_seq))
for (i in 1:B_n) {B_ecdf[i] <- sum(B <= B_seq[i])/length(B)}

tibble(B = B_seq,
       cdf = B_ecdf) %>% 
  ggplot(aes(x = B, y = cdf)) + 
  geom_line() + 
  geom_point(size = 0.5)
```

```{r}
B_threshold_p <- 0.9
B_threshold <- ceiling(B_seq[min(which(B_ecdf >= B_threshold_p))])

nhighest <- 20

df_pathways_all_topn_Bthres <- df_pathways_all_topn %>% 
  filter(B < B_threshold)

top_pathway_lvls <- df_pathways_all_topn_Bthres %>% 
  group_by(pathway) %>% 
  count() %>% 
  arrange(desc(n)) %>% 
  pull(pathway)

df_pathways_all_topn_Bthres <- df_pathways_all_topn_Bthres %>%
  mutate(pathway = factor(pathway, levels = top_pathway_lvls),
         k = factor(k),
         nk = factor(nk),
         cluster_id = factor(cluster_id, levels = cluster_lvls),
         NLQ = ifelse(NLQ > 20, 20, NLQ))

heatmap_topn_palette_cols <- carto_pal(n = 7, "BurgYl")
heatmap_topn_palette <- colorRampPalette(colors = heatmap_topn_palette_cols)(255)

pathways_heatmap_topn <- ggplot(df_pathways_all_topn_Bthres,
                                aes(x = k, 
                                    y = fct_rev(pathway), 
                                    fill = NLQ)) + 
  geom_tile(col = "grey60") + 
  facet_grid(.~nk, scales = "free", space = "free") +
  scale_x_discrete(expand = expansion()) +
  scale_y_discrete(expand = expansion()) +
  scale_fill_gradientn(colors = heatmap_topn_palette,
                       limits = c(1.3, 20)) +
  labs(y = "Biological pathway module") + 
  theme_bw() +
  theme(axis.text = element_text(size = 6))

outfile <- paste("pathways_heatmap_top", nhighest, "B_threshold", B_threshold_p, sep = "_")
outfile <- paste0(outfile, ".pdf")
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = unit(10, "in"),
    height = unit(20, "in"))
print(pathways_heatmap_topn)
dev.off()
```


## Analyzing gene set sizes

N is the background set, i.e. the set of all genes we're testing against. 
n is the number of genes in the cluster neighbourhood that are also in the background set. 
B is the number of genes in the target set, i.e. the set of genes associated with the given molecular pathway. I think this is the value I'm looking for. 
b is the number of genes in the cluster neighbourhood that are also in the target set. 


```{r}
# Reduce all pathway data frames into one
df_pathways_all <- bind_rows(list_pathways)

df_pathways_all
```

```{r}
df_pathways_all %>% 
  select(pathway, B) %>% 
  filter(pathway == "Developmental biology")
```

Why are these values not identical?

```{r}
unique(df_pathways_all$N)
```

The background set is also not the same??

The sets are changing size. Is this what we want? Why is this happening?

```{r}
suppressPackageStartupMessages(library(glue))

# Directory containing mouse cluster files
cluster_dir <- "/projects/jacob/ClusteringAutism_125Models_Mar2020/Data/Outputs/Clusters_Paper/"

GetValidGeneClusterList<-function(Cluster_Dir="Data/Outputs/Clusters",
                                  boot="N",
                                  boot_pick=nboot){
  
  if(boot=="Y"){
    cl <- read.csv(glue("{Cluster_Dir}/Boot/Clusters_{boot_pick}.csv"))
  } else {
    cl <- read.csv(glue("{Cluster_Dir}/Clusters.csv"))
  }
  
  cl <- cl %>% dplyr::mutate(Model=X)%>% dplyr::select(-X)
  
  # Get gene names
  cl$Gene <- sapply(strsplit(as.character(cl$Model),"\\("), "[[", 1)
  cl$Gene[cl$Gene=="Andr"] <- "Ar"
  cl$Gene[cl$Gene=="Caspr2"] <- "Cntnap2"
  cl$Gene[cl$Gene=="Dat"] <- "Slc6a3"
  cl$Gene[cl$Gene=="Mor"] <- "Oprm1"
  cl$Gene[cl$Gene=="Nl1"] <- "Nlgn1"
  cl$Gene[cl$Gene=="Nl3"] <- "Nlgn3"
  cl$Gene[cl$Gene=="Nrxn1a"] <- "Nrxn1"
  cl$Gene[cl$Gene=="Sert"] <- "Slc6a4"
  cl$Gene[cl$Gene=="Pcdh"] <- "Pcdhga3"
  cl$Gene[cl$Gene=="Chd7;En1Cre"] <- "Chd7"
  cl$Gene[cl$Gene=="Ube3a.2"] <- "Ube3a"
  cl$Gene[cl$Gene=="FusDelta14"] <- "Fus"
  cl$Gene[cl$Gene=="Nr1a"] <- "Nmdar1"
  cl$Gene[cl$Model=="itsn1(+/+);itsn2(-/-)"]<- "itsn2"
  cl$Gene[cl$Model=="Snf2H(+/+);Snf2L(-/-);emxcre"]<-"Snf2l"
  cl$Gene[cl$Gene=="Snf2L"] <- "Smarca1"
  cl$Gene[cl$Gene=="Snf2H"] <- "Smarca5"
  cl$Gene[cl$Model=="Gsk3(a)"]<- "Gsk3A"
  cl$Gene[cl$Model=="Gsk3(B)"]<- "Gsk3B"
  
  # Remove CNVs, chromosomal, and behavioural models
  valid_indices <- (! (cl$Gene %in% c("15q11-13", "16p11.2", "22q11.2", "XO", "Btbr", "Balbc", "MAR","15q25","TCDD","VPA","BtbrTT")))
  cl_filt <- cl[valid_indices, ]
  return(cl_filt)
}

# Import mouse clusters and filter for models to use for enrichment
cl_filt <- GetValidGeneClusterList(Cluster_Dir = cluster_dir,
                                   boot = "N", boot_pick = "100")

gene_score <- 950
total_clusters <- 10

all_df_list <- list()
gx_data_list <- list()
gscore <- gene_score

if (stringdb_version == "11.5") {
  stringdb_url <- "https://version-11-5.string-db.org/"
} else if (stringdb_version == "12.0") {
  stringdb_url <- "https://string-db.org/"
} else {
  stop()
}

# for (num_clusters in 2:total_clusters) {}
num_clusters <- 2

all_df <- cl_filt %>% 
  select(Model, Gene, paste0("group", num_clusters)) %>%
  rename(gene=Gene, cluster=paste0("group", num_clusters))
```

Start with 116 models total, from `cl_filt`

```{r}
all_df <- all_df[!duplicated(all_df %>% mutate(dup_select=paste(gene, cluster, sep = "-")) %>% .$dup_select),]
table(all_df$cluster)
```

Extract unique genes from models, resulting in 81 genes total.

```{r}
# Zero based index
all_df$queryIndex <- seq(from=0, to=(dim(all_df)[1]-1), by=1)

# Get STRINGids and merge to all_df
api_call <- paste(stringdb_url, "api/tsv/get_string_ids?identifiers=", paste(all_df$gene, collapse = "%0D"), "&species=10090&limit=1", sep="")
string_ids <- read_tsv(api_call) %>% select(queryIndex, stringId, preferredName)
all_df <- all_df %>% left_join(string_ids, by="queryIndex")

all_df
```
Get String IDs corresponding to each gene. 


```{r}
# Remove organism ID
all_df$fixed_id <- all_df$stringId %>% strsplit("\\.") %>% map_chr(`[`, 2)

all_df
```

Remove the organism ID from the String ID

```{r}
# Get interaction data
api_call <- paste(stringdb_url, "api/tsv/interaction_partners?identifiers=", paste(all_df$stringId, collapse = "%0D"), "&species=10090&required_score=",gscore, sep="")
gx_data <- read_tsv(api_call)

gx_data
```

Get the interaction partners for all the genes at the specified gene score (e.g. 950)

```{r}
gx_data <- gx_data %>% 
  left_join(all_df %>% dplyr::select(cluster, stringId), by=c("stringId_A"="stringId")) %>% 
  dplyr::rename(cluster_A=cluster)

# Write out gene neighbourhoods for each cluster
base_set <- unique(c(gx_data$preferredName_A, gx_data$preferredName_B))

length(base_set)
```
Generates the base set. What is this? The set of all model genes and their interacting partners at the given score. This is saved in "base_set_full_neighbourhood_950.txt". There are 502 genes total at a score of 950.

So the background set changing isn't happening here. 

What's next? 

```{r}
background_set <- "../../data/mouse/enrichment/sagittal_gene_table_normalized_filtered.csv"
Bader_List <- "../../data/mouse/enrichment/Human_Reactome_October_01_2023_symbol.gmt"
Neighbour_dir <- "../../data/mouse/enrichment/StringDB_12.0_Bader_2023/NeighbourhoodInfo/"

# Doing the same shit as above
all_df <- cl_filt %>% dplyr::select(Model, Gene, paste0("group", total_clusters)) %>% dplyr::rename(gene=Gene, cluster=paste0("group", total_clusters))
all_df <- all_df[!duplicated(all_df %>% mutate(dup_select=paste(gene, cluster, sep = "-")) %>% .$dup_select),]
all_df$queryIndex <- seq(from=0, to=(dim(all_df)[1]-1), by=1)
```

Get the full background set

```{r}
base_brain <- read.csv(background_set, header = T)$msg.genes.acronym %>% as.character
length(base_brain)
```
```{r}
GeneScore <- 950
base_models_neighbourhood <- read.csv(glue("{Neighbour_dir}/{GeneScore}/base_set_full_neighbourhood_{GeneScore}.txt"), header = F)$V1  %>% as.character
length(base_models_neighbourhood)
```

This is the thing we generated above. The full set of genes in the protein-protein interaction network. 

```{r}
base_models_only <- all_df$gene
```

Get the gene set without PPI

```{r}
base <- list(brain=base_brain, models_neighbourhood=base_models_neighbourhood, models_only=base_models_only)
```

Combine all the sets into a list.

```{r}
library(tmod)
gmt_file<-Bader_List
MappingsGMT <- tmodImportMSigDB(gmt_file, format = "gmt")
```

Import the Bader gene to pathway mappings


```{r}
# for (num_clusters in 2:total_clusters) {}
num_clusters <- 2

target <- list(models_neighbourhood=list(), models_only=list())
for (clust in 1:num_clusters) {
  
  if (file.size(glue("{Neighbour_dir}/{GeneScore}/target_set_cluster{num_clusters}_{clust}_{GeneScore}_neighbourhood.txt")) == 0) {
    next
  } else {
    target_set_cl <- read.csv(glue("{Neighbour_dir}/{GeneScore}/target_set_cluster{num_clusters}_{clust}_{GeneScore}_neighbourhood.txt"), header = F)$V1 %>% as.character
    target$models_neighbourhood[[clust]] <- target_set_cl
    
    target_set_cl <- read.csv(glue("{Neighbour_dir}/{GeneScore}/target_set_cluster{num_clusters}_{clust}_{GeneScore}_only_models.txt"), header = F)$V1 %>% as.character
    target$models_only[[clust]] <- target_set_cl
  }
}

length(target$models_neighbourhood)
```
```{r}
map(target$models_neighbourhood, length)
```

This gets the gene sets for each cluster in each cluster solution. 

```{r}
# for (clust in 1:num_clusters) {}
clust <- 1

base_set <- base$brain
target_set <- target$models_neighbourhood[[clust]]
```

Get the background set and gene set for the given cluster.

```{r}
enrichment_object <-  MappingsGMT


get_homologs <- function(genes, species, ordered=T) {
  if (!exists("hom", envir = globalenv())) {
    hom <<- read_tsv("http://www.informatics.jax.org/downloads/reports/HOM_MouseHumanSequence.rpt")
  }
  species <- switch (species,
                     mouse={"mouse, laboratory"},
                     human={"human"}
  )
  
  if (ordered) {
    genes_human <- genes_mouse <- c()
    prog <- txtProgressBar(max=length(genes), style = 3)
    for (i in 1:length(genes)) {
      g <- genes[i]
      homologene_ids <- hom$`DB Class Key`[which((hom$Symbol==g) & hom$`Common Organism Name`==species)]
      genes_mouse <- c(genes_mouse, hom$Symbol[which((hom$`DB Class Key` %in% homologene_ids) & (hom$`Common Organism Name`=="mouse, laboratory"))])
      genes_human <- c(genes_human, hom$Symbol[which((hom$`DB Class Key` %in% homologene_ids) & (hom$`Common Organism Name`=="human"))])
      setTxtProgressBar(prog, i)
    }  
    close(prog)
  } else {
    # Faster, but unordered
    homologene_ids <- hom$`DB Class Key`[which((hom$Symbol %in% genes) & hom$`Common Organism Name`==species)]
    genes_mouse <- hom$Symbol[which((hom$`DB Class Key` %in% homologene_ids) & (hom$`Common Organism Name`=="mouse, laboratory"))]
    genes_human <- hom$Symbol[which((hom$`DB Class Key` %in% homologene_ids) & (hom$`Common Organism Name`=="human"))]
  }
  
  return(list(input_genes=genes, mouse_genes=genes_mouse, human_genes=genes_human))  
}

fg <- get_homologs(as.character(target_set), "mouse", ordered = F)$human_genes
bg <- get_homologs(as.character(base_set), "mouse", ordered = F)$human_genes
```

```{r}
print(length(base_set))
print(length(bg))
```
```{r}
length(target_set)
length(fg)
```

Okay so this is where weird things are happening? Somehow the target set has increased in size? The background set has reduced, but that might be expected since not all genes have homologs. 

I think this is where the sets are changing size. 

```{r}
for (num_clusters in 2:total_clusters) {
  
  target <- list(models_neighbourhood=list(), models_only=list())
  for (clust in 1:num_clusters) {
    
    if (file.size(glue("{Neighbour_dir}/{GeneScore}/target_set_cluster{num_clusters}_{clust}_{GeneScore}_neighbourhood.txt")) == 0) {
      next
    } else {
      target_set_cl <- read.csv(glue("{Neighbour_dir}/{GeneScore}/target_set_cluster{num_clusters}_{clust}_{GeneScore}_neighbourhood.txt"), header = F)$V1 %>% as.character
      target$models_neighbourhood[[clust]] <- target_set_cl
      
      target_set_cl <- read.csv(glue("{Neighbour_dir}/{GeneScore}/target_set_cluster{num_clusters}_{clust}_{GeneScore}_only_models.txt"), header = F)$V1 %>% as.character
      target$models_only[[clust]] <- target_set_cl
    }
    
    base_set <- base$brain
    target_set <- target$models_neighbourhood[[clust]]
    
    fg <- get_homologs(as.character(target_set), "mouse", ordered = F)$human_genes
    bg <- get_homologs(as.character(base_set), "mouse", ordered = F)$human_genes
    
    print(length(bg))
    
  }
}
```

Okay so the background set still isn't changing here. The target sets change for the different clusters, which makes sense. 

But then the next step is just to run the HG test?

```{r}
tmodObj <- tmodHGtest(fg, bg, qval = 1.1, mset = enrichment_object, filter = F, order.by = "pval")
tmodObj <- tmodObj %>%  
  rowwise() %>% 
  mutate(P.Value = P.Value) %>% 
  ungroup() %>% 
  mutate(adj.P.Val=p.adjust(P.Value, method="fdr")) #tmod runs one-sided tests

tmodObj
```

```{r}
tmodObj %>% pull(N) %>% unique
```

The background set is the same for all tests, which makes sense. But it's now smaller than the set we started with. 

```{r}
for (num_clusters in 2:total_clusters) {
  
  target <- list(models_neighbourhood=list(), models_only=list())
  for (clust in 1:num_clusters) {
    
    if (file.size(glue("{Neighbour_dir}/{GeneScore}/target_set_cluster{num_clusters}_{clust}_{GeneScore}_neighbourhood.txt")) == 0) {
      next
    } else {
      target_set_cl <- read.csv(glue("{Neighbour_dir}/{GeneScore}/target_set_cluster{num_clusters}_{clust}_{GeneScore}_neighbourhood.txt"), header = F)$V1 %>% as.character
      target$models_neighbourhood[[clust]] <- target_set_cl
      
      target_set_cl <- read.csv(glue("{Neighbour_dir}/{GeneScore}/target_set_cluster{num_clusters}_{clust}_{GeneScore}_only_models.txt"), header = F)$V1 %>% as.character
      target$models_only[[clust]] <- target_set_cl
    }
    
    base_set <- base$brain
    target_set <- target$models_neighbourhood[[clust]]
    
    fg <- get_homologs(as.character(target_set), "mouse", ordered = F)$human_genes
    bg <- get_homologs(as.character(base_set), "mouse", ordered = F)$human_genes
    
    tmodObj <- tmodHGtest(fg, bg, qval = 1.1, mset = enrichment_object, filter = F, order.by = "pval")
    tmodObj <- tmodObj %>%  
      rowwise() %>% 
      mutate(P.Value = P.Value) %>% 
      ungroup() %>% 
      mutate(adj.P.Val=p.adjust(P.Value, method="fdr")) #tmod runs one-sided tests
    
    print(unique(tmodObj$N))
    
  }
}
```

So the background set is actually changing behind the scenes when running the HG test. 

```{r}
bg_len <- length(bg)
fg_len <- length(fg)

tmod_N <- unique(tmodObj$N)
```


So the background set doesn't change based on the test set, but it changes based on the target set. 

```{r}
tmodObj
```

Maybe this doesn't matter. I thought the difference arose at the level of pre-processing, but everything is consistent up until the actual test is run. 

```{r}
print(length(bg))
print(length(unique(bg)))
```

Looks like the background set is redundant. 

```{r}
length(unique(c(fg, bg)))
```

Ah there we go. The background set is the union of the input background set and the input target set. So genes in the different target sets aren't necessarily in the input background set. 

Okay. 


## Pathway significance

Well what to do with this anyway? 

```{r}
cluster_lvls <- df_pathways_all %>% 
  select(cluster_id, nk, k) %>% 
  distinct() %>% 
  arrange(nk, k) %>% 
  pull(cluster_id)

df_pathways_nsig <- df_pathways_all %>% 
  mutate(significant = adj.P.Val < 0.05) %>% 
  filter(significant) %>% 
  group_by(cluster_id, nk) %>%
  count() %>% 
  ungroup() %>% 
  mutate(cluster_id = factor(cluster_id, levels = cluster_lvls))

outfile <- "pathways_all_nsignificant.pdf"
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = 10,
    height = 5)
ggplot(df_pathways_nsig, aes(x = cluster_id, y = n)) + 
  geom_col(alpha = 0.5,
           fill = "grey50",
           col = "grey30") + 
  facet_wrap(~nk, scales = "free_x") +
  labs(x = "Cluster", 
       y = "Number of significant pathways") +
  theme_bw() +
  theme(axis.text = element_text(size = 8))
dev.off()
```

```{r}
df_pathways_all %>% 
  group_by(cluster_id) %>% 
  count() %>% 
  pull(n) %>% 
  unique()
```


```{r}
alpha <- c(0.05, 10^(-1*seq(2, 20)))
df_pathways_roc <- tibble()
for (q in alpha) {
  
  df_pathways_roc_i <- df_pathways_all %>% 
    mutate(significant = adj.P.Val < q) %>% 
    filter(significant) %>% 
    group_by(cluster_id, nk) %>%
    count() %>% 
    ungroup() %>% 
    mutate(alpha = q)
  
  df_pathways_roc <- bind_rows(df_pathways_roc, df_pathways_roc_i)
  
}

outfile <- "pathways_all_nsignificant_roc.pdf"
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = 8,
    height = 8)
ggplot(df_pathways_roc, 
       aes(x = -log10(alpha), y = n, group = cluster_id)) + 
  geom_line(alpha = 0.5) + 
  geom_point(size = 1, 
             col = "grey30") +
  geom_vline(xintercept = -log10(0.05),
             col = "red", linetype = "dashed",
             size = 0.3) + 
  facet_wrap(~nk, scales = "free_y") +
  coord_cartesian(xlim = c(0, 20),
                  ylim = c(0, 600)) + 
  scale_x_continuous(breaks = seq(0, 30, by = 5)) + 
  scale_y_continuous(breaks = seq(0, 1000, by = 100)) + 
  labs(x = "-log10(alpha)",
       y = "Number of significant pathways",
       col = "Cluster solution") + 
  theme_bw()
dev.off()
```

```{r}
df_pathways_nk2 <- df_pathways_all %>% 
  filter(nk == 2) %>%
  mutate(significant = adj.P.Val < 0.05,
         cluster_id = factor(cluster_id, levels = cluster_lvls)) 

outfile <- "pathways_all_nk2_test_set_size.pdf"
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = 8,
    height = 5)
ggplot(df_pathways_nk2, aes(x = B, y = E, col = significant)) + 
  geom_point(size = 0.5,
             alpha = 0.5) +
  facet_wrap(~cluster_id) +
  labs(x = "Number of genes in pathway",
       y = "Enrichment",
       col = "Significant") + 
  theme_bw()
dev.off()
```

```{r}
df_pathways_nk2 %>% 
  filter(k == 1,
         B > 400) %>% 
  arrange(desc(B))
```

```{r}
outfile <- "pathways_all_nk2_test_set_size_lt500.pdf"
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = 8,
    height = 5)
ggplot(filter(df_pathways_nk2, B < 500), aes(x = B, y = E, col = significant)) + 
  geom_point(size = 0.5,
             alpha = 0.5) +
  facet_wrap(~cluster_id) +
  labs(x = "Number of genes in pathway",
       y = "Enrichment",
       col = "Significant") + 
  theme_bw()
dev.off()
```

```{r}
df_pathways_nk2 %>% 
  filter(k == 1, B < 75, B != 0) %>% 
  ggplot(aes(x = B)) + 
  geom_histogram(binwidth = 2, fill = "grey70", col = "grey30")
```

```{r}
df_pathways_nk2 %>% 
  filter(k == 1, B != 0) %>% 
  arrange(B) %>% 
  select(pathway, B)
```

```{r}
df_pathways_nk2 %>% 
  filter(k == 1, B <= 10, B != 0) %>% 
  group_by(B) %>% 
  count() %>% 
  ungroup() %>% 
  ggplot(aes(x = B, y = n)) + 
  geom_col()
```

```{r}
npathways <- df_pathways_nk2 %>% 
  filter(k == 1, B != 0) %>% 
  nrow()

npathways_leq10 <- df_pathways_nk2 %>% 
  filter(k == 1, B != 0, B <= 10) %>% 
  nrow()

print(npathways_leq10)
print(npathways_leq10/npathways)
```

```{r}
B_max <- df_pathways_nk2 %>% 
  pull(B) %>% 
  max()

ecdf <- tibble(x = floor(seq(1, B_max, by = 1)),
               y = 0)
for (i in 1:nrow(ecdf)) {
  ni <- df_pathways_nk2 %>% 
    filter(k == 1, B != 0, 
           B < ecdf[[i, "x"]]) %>% 
    nrow()
  
  ecdf[[i, "y"]] <- ni/npathways
}

outfile <- "pathways_all_genes_ecdf.pdf"
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = 8,
    height = 5)
ggplot(ecdf, aes(x = x, y = y)) + 
  geom_line() + 
  geom_point(size = 0.5) +
  scale_x_continuous(breaks = seq(0, 3000, by = 200)) + 
  scale_y_continuous(breaks = seq(0, 1.0, by = 0.1)) + 
  labs(x = "Number of genes in pathway",
       y = "Proportion of pathways") +
  theme_bw()
dev.off()
```

```{r}
df_pathways_nk2 %>% 
  filter(k == 1,
         pathway %in% df_pathway_info[["pathway"]]) %>% 
  select(pathway, B) %>% 
  arrange(desc(B))
```

```{r}
pathways_threshold <- df_pathways_all %>% 
  select(pathway, B) %>% 
  group_by(pathway) %>% 
  filter(B == min(B)) %>%
  distinct() %>% 
  ungroup() %>% 
  filter(B >= 20, B < 400) %>% 
  pull(pathway)

df_pathways_all_threshold <- df_pathways_all %>%
  filter(pathway %in% pathways_threshold) %>% 
  group_by(cluster_id) %>% 
  mutate(adj.P.Val = p.adjust(P.Value, method = "fdr"),
         NLQ = -log10(adj.P.Val)) %>% 
  ungroup()

df_pathways_all_threshold
```

```{r}
alpha <- c(0.05, 10^(-1*seq(2, 20)))
df_pathways_roc <- tibble()
for (q in alpha) {
  
  df_pathways_roc_i <- df_pathways_all_threshold %>% 
    mutate(significant = adj.P.Val < q) %>% 
    filter(significant) %>% 
    group_by(cluster_id, nk) %>%
    count() %>% 
    ungroup() %>% 
    mutate(alpha = q)
  
  df_pathways_roc <- bind_rows(df_pathways_roc, df_pathways_roc_i)
  
}

outfile <- "pathways_all_B_geq20_lt400_nsignificant_roc.pdf"
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = 8,
    height = 8)
ggplot(df_pathways_roc, 
       aes(x = -log10(alpha), y = n, group = cluster_id)) + 
  geom_line(alpha = 0.5) + 
  geom_point(size = 1, 
             col = "grey30") +
  geom_vline(xintercept = -log10(0.05),
             col = "red", linetype = "dashed",
             size = 0.3) + 
  facet_wrap(~nk, scales = "free_y") +
  coord_cartesian(xlim = c(0, 20),
                  ylim = c(0, 600)) + 
  scale_x_continuous(breaks = seq(0, 30, by = 5)) + 
  scale_y_continuous(breaks = seq(0, 1000, by = 100)) + 
  labs(x = "-log10(alpha)",
       y = "Number of significant pathways",
       col = "Cluster solution") + 
  theme_bw()
dev.off()
```

```{r}
# Get enrichment for nk >= 4
df_pathways_all_nk_geq4 <- df_pathways_all_threshold %>% 
  filter(nk >= 4)

# Get cluster levels
cluster_lvls <- df_pathways_all_nk_geq4 %>% 
  select(nk, k, cluster_id) %>% 
  distinct() %>% 
  arrange(nk, k) %>% 
  pull(cluster_id)

# Number of most enriched pathways for each cluster
nhighest <- 10

# Filter for top pathways
list_pathways_all_topn <- vector(mode = "list", length = length(cluster_lvls))
for (i in 1:length(list_pathways_all_topn)) {
  list_pathways_all_topn[[i]] <-
    df_pathways_all_nk_geq4 %>% 
    filter(cluster_id == cluster_lvls[i]) %>% 
    arrange(rank) %>% 
    head(n = nhighest) %>% 
    pull(pathway)
}

# Get the full set of top pathways
pathways_topn <- reduce(.x = list_pathways_all_topn, .f = c)
pathways_topn <- unique(pathways_topn)

# Filter for top pathways and normalize enrichment 
df_pathways_topn <- df_pathways_all_nk_geq4 %>% 
  filter(pathway %in% pathways_topn) %>% 
  group_by(pathway) %>% 
  mutate(NLQ_norm = NLQ/max(NLQ)) %>% 
  ungroup() %>% 
  mutate(NLQ_norm = ifelse(is.nan(NLQ_norm), 0, NLQ_norm))

# Convert to matrix
mat_pathways_topn <- df_pathways_topn %>% 
  select(pathway, cluster_id, NLQ_norm) %>% 
  pivot_wider(id_cols = pathway, 
              names_from = cluster_id, 
              values_from = NLQ_norm) %>% 
  column_to_rownames("pathway") %>% 
  as.matrix()

# Pathway motif scree plot
pathway_scree_plot <- mat_pathways_topn %>% 
  t() %>% 
  hclust_wcss() %>% 
  as_tibble() %>% 
  mutate(nk = 1:nrow(.)) %>% 
  ggplot(df_pathway_hclust,
         mapping = aes(nk, y = value)) + 
  geom_line() + 
  geom_point() + 
  coord_cartesian(xlim = c(1, 70)) + 
  scale_x_continuous(breaks = seq(0, length(pathways_topn), by = 5)) +
  labs(x = "Number of clusters",
       y = "Within-cluster sum of squared distance") + 
  theme_bw() +
  theme(panel.grid.minor.x = element_blank())

outfile <- "pathways_all_B_geq20_lt400_cluster_NLQ_scree_plot.pdf"
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = unit(8, "in"),
    height = unit(4, "in"))
print(pathway_scree_plot)
dev.off()
```

```{r fig-supp-12-pathways-dendrogram}
# Dendrogram cut
hclust_kcut <- 20

# Hierarchical clustering of the pathways
pathways_topn_hc <- hclust(d = dist(mat_pathways_topn, 
                                    method = "euclidean"))

# Extract pathway order according to clustering
pathways_topn_lvls <- pathways_topn_hc[["labels"]]
pathways_topn_order <- pathways_topn_hc[["order"]]
pathways_topn_lvls_clustered <- pathways_topn_lvls[pathways_topn_order]

# Obtain pathway cluster order at selected solution
df_pathways_topn_hclust <- cutree(pathways_topn_hc, k = hclust_kcut) %>% 
  enframe(name = "pathway", value = "pathway_cluster") 

# Relevel pathways to follow dendrogram order
df_pathways_topn_cluster_lvls <- df_pathways_topn_hclust %>% 
  mutate(pathway = factor(pathway, levels = pathways_topn_lvls_clustered)) %>% 
  arrange(pathway) %>% 
  select(pathway_cluster) %>% 
  distinct() %>% 
  mutate(pathway_cluster_new = 1:nrow(.))

df_pathways_topn_hclust <- df_pathways_topn_hclust %>% 
  left_join(df_pathways_topn_cluster_lvls, by = "pathway_cluster") %>% 
  select(-pathway_cluster, pathway_cluster = pathway_cluster_new)

# Generate clustered heatmap
fig_supp_12_pheatmap <- pheatmap(mat = mat_pathways_topn,
                                 cluster_col = FALSE,
                                 cluster_rows = TRUE,
                                 clustering_distance_rows = "euclidean",
                                 cutree_rows = hclust_kcut,
                                 silent = TRUE)

# Extract dendrogram from pheatmap object
fig_supp_12_dendrogram_grob <- fig_supp_12_pheatmap[["gtable"]][["grobs"]][[1]]
fig_supp_12_dendrogram_grob[["gp"]] <- gpar(lwd = 0.75)


# Get pathway motifs
df_pathways_topn_heatmap <- df_pathways_topn %>% 
  left_join(df_pathways_topn_hclust, by = "pathway") %>% 
  mutate(pathway = factor(pathway, levels = pathways_topn_lvls_clustered))

# Create data frame for significant POND matches
df_sig_nk_POND <- list_significance[["375"]] %>% 
  rename(human_cluster_id = img1_cluster_id,
         human_nk = img1_nk,
         human_k = img1_k,
         mouse_cluster_id = img2_cluster_id,
         mouse_nk = img2_nk,
         mouse_k = img2_k) %>% 
  group_by(mouse_nk, mouse_k) %>% 
  summarise(p = min(pval),
            nsignificant = sum(significant),
            .groups = "drop") %>% 
  mutate(plab = case_when(p < 0.05 ~ "**",
                          p >= 0.05 & p < 0.1 ~ "*",
                          p >= 0.1 ~ ""),
         has_match = ifelse(nsignificant > 0, TRUE, FALSE),
         y = "y") %>% 
  select(nk = mouse_nk, k = mouse_k, p, plab, has_match, y) %>% 
  filter(nk >= 4) %>% 
  unite(col = "cluster_id", "nk", "k", 
        sep = "-", remove = FALSE) 

# Create data frame for significant HBN matches
df_sig_nk_HBN <- list_significance[["861"]] %>% 
  rename(human_cluster_id = img1_cluster_id,
         human_nk = img1_nk,
         human_k = img1_k,
         mouse_cluster_id = img2_cluster_id,
         mouse_nk = img2_nk,
         mouse_k = img2_k) %>%  
  group_by(mouse_nk, mouse_k) %>% 
  summarise(p = min(pval),
            nsignificant = sum(significant),
            .groups = "drop") %>% 
  mutate(plab = case_when(p < 0.05 ~ "**",
                          p >= 0.05 & p < 0.1 ~ "*",
                          p >= 0.1 ~ ""),
         has_match = ifelse(nsignificant > 0, TRUE, FALSE),
         y = "HBN") %>% 
  select(nk = mouse_nk, k = mouse_k, p, plab, has_match, y) %>% 
  filter(nk >= 4) %>% 
  unite(col = "cluster_id", "nk", "k", 
        sep = "-", remove = FALSE) 

# Combine POND and HBN data
df_sig_nk <- bind_rows(df_sig_nk_POND,
                       df_sig_nk_HBN)

# Clamped enrichment statistic
NLQ_threshold <- 30
df_pathways_topn_heatmap <- df_pathways_topn_heatmap %>% 
  mutate(intensity = ifelse(NLQ > NLQ_threshold, NLQ_threshold, NLQ))
heatmap_limits <- c(2, NLQ_threshold)
heatmap_fill_lab <- "Enrichment (-log10(q))"

# Pathways ####

# Heatmap palette
heatmap_palette_cols <- brewer.pal(n = 9, name = "OrRd")
heatmap_palette <- colorRampPalette(colors = heatmap_palette_cols)(255)

fig_supp_12_pathways_legend_width_pt <- 50

# Font family
font_family <- "Helvetica"

# Nature suggested font size: 5-7 pt
font_size <- 6

# Generate heatmap of enrichment significance
fig_supp_12_pathways <- ggplot(df_pathways_topn_heatmap, 
                               aes(x = factor(k), 
                                   y = fct_rev(pathway), 
                                   fill = intensity)) + 
  geom_tile(col = "grey60") +
  facet_grid(pathway_cluster~nk, scales = "free", space = "free") + 
  scale_x_discrete(expand = expansion()) + 
  scale_y_discrete(expand = expansion(), 
                   position = "right") + 
  scale_fill_gradientn(colors = heatmap_palette,
                       limits = heatmap_limits,
                       na.value = "grey85",
                       guide = guide_colourbar(title.position = "top",
                                               title.hjust = 0.5,
                                               barwidth = unit(fig_supp_12_pathways_legend_width_pt, "bigpts"),
                                               barheight = unit(10, "bigpts"))) +
  labs(x = "Mouse cluster",
       y = "Biological pathway module",
       fill = heatmap_fill_lab) +
  theme_bw() +
  theme(strip.background = element_blank(),
        strip.text = element_blank(),
        panel.spacing = unit(4, "bigpts"),
        axis.title.x = element_text(size = font_size, family = font_family),
        axis.text.x = element_text(size = font_size-2, family = font_family),
        axis.ticks.x = element_line(size = 0.25),
        axis.title.y = element_text(size = font_size, family = font_family),
        axis.text.y = element_text(size = font_size-2, family = font_family), 
        axis.ticks.y = element_line(size = 0.25),
        legend.position = "bottom",
        legend.title = element_text(size = font_size-1, family = font_family),
        legend.text = element_text(size = font_size-1, family = font_family),
        legend.margin = margin(),
        plot.margin = margin(l = 0))

# Extract legend grob
fig_supp_12_pathways_legend_grob <- fig_supp_12_pathways %>%
  ggplotGrob() %>%
  grid.force() %>%
  getGrob("guides.3-3-3-3")

# Remove legend from ggplot object
fig_supp_12_pathways <- fig_supp_12_pathways +
  theme(legend.position = "none")

# Generate heatmap of mouse clusters with human matches
fig_supp_12_match <- ggplot(df_sig_nk,
                            mapping = aes(x = factor(k), 
                                          y = y, 
                                          fill = p,
                                          label = plab)) + 
  geom_tile(col = "grey50") +
  geom_text(col = "white",
            angle = 90,
            vjust = "middle",
            nudge_x = 0.1,
            family = font_family,
            size = font_size*0.36) + 
  facet_grid(.~nk, scales = "free", space = "free") + 
  scale_x_discrete(expand = expansion()) +
  scale_y_discrete(expand = expansion()) +
  scale_fill_gradientn(colors = rev(brewer.pal(n = 9, name = "PuBu")[c(1:4, 8)]),
                       guide = guide_colourbar(title.position = "top", 
                                               barwidth = unit(80, "bigpts"))) +
  labs(x = "Mouse cluster",
       fill = "Human-mouse equivalence (p-value)") +
  theme_bw() +
  theme(panel.spacing = unit(4, "bigpts"),
        strip.background.x = element_rect(fill = "grey90"),
        strip.text.x = element_text(size = font_size-1, family = font_family,
                                    margin = margin(b = 1, t = 1)),
        strip.background.y = element_blank(),
        strip.text.y = element_blank(),
        axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        legend.direction = "horizontal",
        legend.position = "bottom",
        legend.key.size = unit(10, "bigpts"),
        legend.title = element_text(size = font_size-1,
                                    family = font_family,
                                    hjust = 0.5),
        legend.text = element_text(size = font_size-1,
                                   family = font_family),
        legend.margin = margin(),
        plot.margin = margin(l = 0))

# Extract heatmap legend
fig_supp_12_match_legend_grob <- fig_supp_12_match %>%
  ggplotGrob() %>%
  grid.force() %>%
  getGrob("guides.3-3-3-3")

# Remove legend from ggplot object
fig_supp_12_match <- fig_supp_12_match +
  theme(legend.position = "none")

# Patchwork #### 
fig_supp_12_patchwork <- (fig_supp_12_match / plot_spacer() / fig_supp_12_pathways) +
  plot_layout(heights = c(0.020, 0.005, 0.975)) &
  theme(plot.margin = margin(l = 0))
fig_supp_12_patchwork_grob <- patchworkGrob(fig_supp_12_patchwork)


# Grob ####

# Width of dendrogram panel in bigpts
fig_supp_12_dendrogram_width_pt <- 26

# Maximal figure dimensions in bigpts
fig_width_pt <- 510
fig_height_pt <- 500
pt_per_in <- 72

# Dimensions of heatmap patchwork in bigpts
fig_supp_12_patchwork_width_pt <- fig_width_pt - fig_supp_12_dendrogram_width_pt

# Heights of padding elements in bigpts
fig_supp_12_padding_height_1_pt <- 21
fig_supp_12_padding_height_2_pt <- 17

fig_supp_12_patchwork_height_pt <- fig_height_pt - fig_supp_12_padding_height_1_pt - fig_supp_12_padding_height_2_pt

# Dimensions of heatmap plot
fig_supp_12_widths <- c(fig_supp_12_dendrogram_width_pt, fig_supp_12_patchwork_width_pt)
fig_supp_12_heights <- c(fig_supp_12_padding_height_1_pt, 
                         fig_supp_12_patchwork_height_pt,
                         fig_supp_12_padding_height_2_pt)

# Layout of heatmap plot
fig_supp_12_layout <- rbind(c(01, 02),
                            c(03, 02),
                            c(04, 02))

# Grob grid for heatmap plot
fig_supp_12_grob <- arrangeGrob(zeroGrob(),
                                fig_supp_12_patchwork_grob,
                                fig_supp_12_dendrogram_grob,
                                zeroGrob(),
                                layout_matrix = fig_supp_12_layout,
                                widths = unit(fig_supp_12_widths, "bigpts"),
                                heights = unit(fig_supp_12_heights, "bigpts"))


fig_supp_12_width_pt <- fig_width_pt
fig_supp_12_height_pt <- fig_height_pt

# Viewport for pathways heatmap legend
fig_supp_12_pathways_legend_vp <- viewport(x = unit(fig_width_pt-12, "bigpts"),
                                           y = unit(35, "bigpts"),
                                           width = unit(fig_supp_12_pathways_legend_width_pt, "bigpts"),
                                           height = unit(22, "bigpts"),
                                           just = c("right", "bottom"))

# Viewport for human match heatmap legend
fig_supp_12_match_legend_vp_width <- 105
fig_supp_12_match_legend_vp_x <- fig_width_pt - fig_supp_12_match_legend_vp_width
fig_supp_12_match_legend_vp <- viewport(x = unit(fig_supp_12_match_legend_vp_x, "bigpts"),
                                        y = unit(fig_supp_12_height_pt-3, "bigpts"),
                                        width = unit(fig_supp_12_match_legend_vp_width, "bigpts"),
                                        height = unit(27, "bigpts"),
                                        just = c("left", "top"))

fig_supp_12_width_in <- fig_supp_12_width_pt/pt_per_in
fig_supp_12_height_in <- fig_supp_12_height_pt/pt_per_in

# Export
outfile <- "pathways_all_B_geq20_lt400_cluster_heatmap_NLQ_motifs_20.pdf"
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = unit(fig_supp_12_width_in, "in"),
    height = unit(fig_supp_12_height_in, "in"))
grid.draw(fig_supp_12_grob)
pushViewport(fig_supp_12_pathways_legend_vp)
grid.draw(fig_supp_12_pathways_legend_grob)
popViewport()
pushViewport(fig_supp_12_match_legend_vp)
grid.draw(fig_supp_12_match_legend_grob)
popViewport()
dev.off()
```

# Gene ontology pathway hierarchy

```{r}
library(tmod)
```

```{r}
# Background set of genes
background_set <- "/projects/jacob/ClusteringAutism_125Models_Mar2020/Data/Raw/sagittal_gene_table_normalized_filtered.csv"
background_set <- read_csv(background_set, show_col_types = FALSE) %>% 
  pull(msg.genes.acronym) %>% 
  as.character()

# Gene modules from Reactome database
tmod_modules <- "/projects/jacob/ClusteringAutism_125Models_Mar2020/Data/Raw/Human_Reactome_March_01_2020_symbol.gmt"
tmod_modules <- tmodImportMSigDB(tmod_modules, format = "gmt")
```

```{r}
df_pathway_similarity <- expand_grid(pathway_1 = pathway_ids,
                                     pathway_2 = pathway_ids,
                                     jaccard_index = 0,
                                     prop_1_in_2 = 0,
                                     prop_2_in_1 = 0,
                                     size_1 = 0,
                                     size_2 = 0)

for (i in 1:nrow(df_pathway_similarity)) {
  
  pathway_1 <- df_pathway_similarity[[i, "pathway_1"]]
  pathway_2 <- df_pathway_similarity[[i, "pathway_2"]]
  pathway_1_genes <- tmod_modules[["MODULES2GENES"]][[pathway_1]]
  pathway_2_genes <- tmod_modules[["MODULES2GENES"]][[pathway_2]]
  
  nintersect <- length(intersect(pathway_1_genes, pathway_2_genes))
  nunion <- length(union(pathway_1_genes, pathway_2_genes))
  df_pathway_similarity[[i, "jaccard_index"]] <- nintersect/nunion
  
  df_pathway_similarity[[i, "prop_1_in_2"]] <- sum(pathway_1_genes %in% pathway_2_genes)/length(pathway_1_genes)
  df_pathway_similarity[[i, "prop_2_in_1"]] <- sum(pathway_2_genes %in% pathway_1_genes)/length(pathway_2_genes)
  
  df_pathway_similarity[[i, "size_1"]] <- length(pathway_1_genes)
  df_pathway_similarity[[i, "size_2"]] <- length(pathway_2_genes)
  
}

df_pathway_similarity <- df_pathway_similarity %>% 
  rename(pathway_id_1 = pathway_1,
         pathway_id_2 = pathway_2) %>% 
  left_join(df_pathway_info, 
            by = c("pathway_id_1" = "ID")) %>% 
  rename(pathway_1 = pathway,
         acronym_1 = acronym) %>% 
  left_join(df_pathway_info, 
            by = c("pathway_id_2" = "ID")) %>% 
  rename(pathway_2 = pathway,
         acronym_2 = acronym) 
```

```{r}
df_pathway_sizes <- df_pathway_similarity %>% 
  select(pathway = pathway_1, size = size_1, acronym = acronym_1) %>% 
  distinct() %>% 
  mutate(pathway = factor(pathway, levels = pathway[order(size, decreasing = TRUE)]),
         acronym = factor(acronym, levels = acronym[order(size, decreasing = TRUE)]))

ggplot(df_pathway_sizes, 
       aes(x = size, y = pathway)) + 
  geom_col()
```

```{r}
pathway_hierarchy_heatmap <- df_pathway_similarity %>% 
  mutate(acronym_1 = factor(acronym_1, levels = levels(df_pathway_sizes[["acronym"]])),
         acronym_2 = factor(acronym_2, levels = levels(df_pathway_sizes[["acronym"]])),
         prop_1_in_2 = ifelse(pathway_1 == pathway_2, NA, prop_1_in_2),
         is_subset = ifelse(prop_1_in_2 == 1, "*", "")) %>% 
  ggplot(aes(x = acronym_2, y = fct_rev(acronym_1), fill = prop_1_in_2)) + 
  geom_tile(col = "grey60") +
  geom_text(mapping = aes(label = is_subset),
            col = "white",
            size = 8, nudge_y = -0.4) + 
  scale_fill_gradientn(colours = heatmap_palette, na.value = "grey80") + 
  scale_x_discrete(expand = expansion(), position = "top") + 
  scale_y_discrete(expand = expansion()) + 
  labs(x = "Pathway",
       y = "Pathway",
       fill = "Proportion of \nx in y") + 
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 0))

outfile <- "pathway_hierarchy_heatmap.pdf"
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = unit(8, "in"),
    height = unit(5, "in"))
print(pathway_hierarchy_heatmap)
dev.off()
```

I'm not sure if there's a cleaner way to get at this. The Jaccard index gives me the similarity between two sets, but it doesn't tell me anything about hierarchical relationships. The Jaccard index of a nested pair of sets could actually be quite small if one of the sets if much bigger than the other. What if I change the denominator though? Instead of the union I could use the size of one of the sets. The metric would stop being symmetric, but I think that's what I want in this case? Isn't that exactly what this proportion is that I'm computing? 

```{r}

```


```{r}
# Iterate over clusters
for (k in 1:nk) {
  
  # Target gene set for cluster k
  target_set <- unique(c(list_cluster_interactions[[k]][["preferredName_A"]],
                         list_cluster_interactions[[k]][["preferredName_B"]]))
  
  # Convert mouse gene names to human
  fg <- get_homologs(target_set, "mouse", ordered = F)[["human_genes"]]
  bg <- get_homologs(background_set, "mouse", ordered = F)[["human_genes"]]
  
  # Run hypergeometric test against pathway modules
  tmod_hgtest_out <- tmodHGtest(fg = fg, bg = bg, mset = tmod_modules, 
                                qval = 1.1, filter = FALSE, order.by = "pval")
  
  # Clean up output
  tmod_hgtest_out <- tmod_hgtest_out %>% 
    as_tibble() %>% 
    arrange(P.Value) %>% 
    mutate(rank = 1:nrow(.),
           NLQ = -log(adj.P.Val),
           k = k) %>% 
    dplyr::select(rank, Title, NLQ, P.Value, adj.P.Val, everything()) %>% 
    arrange(adj.P.Val)
  
  # Export the enrichment data to file
  outfile <- paste("human_cluster_pathway_enrichment", nk, k, gene_score, sep = "_")
  outfile <- paste0(outfile, ".csv")
  outfile <- file.path(output_dir, outfile)
  write_csv(x = tmod_hgtest_out, file = outfile)
  
}
```



# Pathways analysis (2025)

```{r}
suppressPackageStartupMessages(library(tidyverse))
```

```{r}
PROJECTPATH <- Sys.getenv("PROJECTPATH")
SRCPATH <- Sys.getenv("SRCPATH")
setwd(PROJECTPATH)
```


```{r}
source(file.path(SRCPATH, "enrichment.R"))
```


```{r}
bader_modules <- file.path(PROJECTPATH, "data/enrichment/", "Human_Reactome_June_01_2025_symbol.gmt")  

df_module_sizes <- get_module_sizes(modules = bader_modules)

# Pathway size threshold
B_threshold <- 10

# Pathways to keep
pathway_ids_keep <- df_module_sizes %>% 
  filter(B >= B_threshold) %>% 
  pull(ID)

length(pathway_ids_keep)
```

```{r}
df_module_sizes_keep <- df_module_sizes %>% filter(B >= B_threshold)

B_max <- max(df_module_sizes_keep$B)
B_min <- min(df_module_sizes_keep$B)
B_seq <- seq(B_min, B_max, by = 1)
B_ecdf <- numeric(length(B_seq))
for (i in 1:length(B_seq)) {
  B_ecdf[i] <- sum(df_module_sizes_keep$B <= B_seq[i])/nrow(df_module_sizes_keep)
}

tibble(x = B_seq, y = B_ecdf) %>% 
  ggplot(aes(x = x, y = y)) +
  geom_point() +
  geom_vline(xintercept = 33)
```

```{r}
quantile(x = df_module_sizes_keep$B)
```



```{r}
mouse_enrichment_dir <- file.path(PROJECTPATH,  "data/mouse/derivatives/v3/107/enrichment/StringDB_12.0_Bader_2025/950/NeighbourhoodEnrichment")

files <- list.files(mouse_enrichment_dir) %>% 
  str_subset(paste0("cluster_pathway_enrichment_", nk))

files <- file.path(mouse_enrichment_dir, files)

list_enrichment <- vector(mode = "list", length = nk)
for (i in 1:nk) {
  list_enrichment[[i]] <- read_csv(files[i]) %>% 
  filter(ID %in% pathway_ids_keep)
}

df_enrichment <- bind_rows(list_enrichment)
```

```{r}
df_module_sizes %>% 
  filter(str_detect(Title, "RNA Polymerase I Promoter"))
```


```{r}
df_enrichment %>% 
  select(k, n) %>% 
  distinct() %>% 
  arrange(k)
```

```{r}
df_enrichment %>% 
  filter(adj.P.Val < 0.05) %>% 
  group_by(k) %>% 
  count()
```

```{r}
pathways_enriched <- df_enrichment %>% 
  filter(adj.P.Val < 0.05) %>% 
  pull(ID) %>% 
  unique()

```

```{r}
tmp <- df_enrichment %>% 
  filter(ID %in% pathways_enriched) 

ggplot(tmp, aes(x = Title, y = factor(k), fill = -log10(adj.P.Val))) + 
  geom_tile()
```


```{r}
modules <- importMsigDBGMT(bader_modules)

# modules_keep <- names(modules$MODULES2GENES) %in% pathway_ids_keep
modules_enriched <- names(modules$MODULES2GENES) %in% pathways_enriched
modules$MODULES2GENES <- modules$MODULES2GENES[modules_enriched]

# modules$MODULES <- modules$MODULES %>% filter(ID %in% pathway_ids_keep)
modules$MODULES <- modules$MODULES %>% filter(ID %in% pathways_enriched)

genes_all <- modules$MODULES2GENES %>% reduce(c) %>% unique() %>% sort()

nmodules <- length(modules$MODULES2GENES)
ngenes <- length(genes_all)

membership <- matrix(data = FALSE, nrow = ngenes, ncol = nmodules)

for (i in 1:nmodules) {
  pathway_genes <- modules[["MODULES2GENES"]][[i]]
  idx <- which(genes_all %in% pathway_genes)
  membership[idx,i] <- TRUE
}

overlap_coef <- function(x, y) {
  intersect <- sum(x & y)
  min_size <- min(sum(x), sum(y))
  if (min_size == 0) return(NA)
  intersect / min_size
}

jaccard <- function(x, y) {
  intersect <- sum(x & y)
  union <- sum(x | y)
  if (union == 0) return(NA)  # handle edge case
  intersect / union
}

jac_mat <- matrix(0, nrow = nmodules, ncol = nmodules)
for (i in 1:nrow(jac_mat)) {
  if (i %% 10 == 0) {print(i)}
  for (j in i:ncol(jac_mat)) {
    jac_mat[i, j] <- jaccard(membership[,i], membership[,j])
  }
}

jac_mat <- 1 - jac_mat

jac_mat[lower.tri(jac_mat)] <- t(jac_mat)[lower.tri(jac_mat)]
```
```{r}
jaccard_dist <- dist(x = t(membership), method = "binary")
motifs <- cluster::pam(x = jaccard_dist, diss = TRUE, k = 20)
motifs$medoids
```

```{r}
df_pathways <- modules[["MODULES"]] %>% 
  mutate(cluster = motifs$clustering) %>% 
  left_join(df_module_sizes, by = c("ID", "Title"))

ggplot(df_pathways, aes(x = cluster, y = B)) + 
  geom_point()
```

```{r}
df_pathways %>% filter(cluster == 8) %>% 
  arrange(desc(B))
```



```{r}
length(modules$MODULES2GENES$`DEVELOPMENTAL BIOLOGY%REACTOME DATABASE ID RELEASE 92%1266738`)
length(modules$MODULES2GENES$`GENE EXPRESSION (TRANSCRIPTION)%REACTOME DATABASE ID RELEASE 92%74160`)
```


```{r}
medoid_IDs <- modules$MODULES[motifs$medoids,]$ID
```

```{r}
table(motifs$clustering)
```

```{r}
df_module_sizes %>% 
  filter(ID %in% medoid_IDs)
```

