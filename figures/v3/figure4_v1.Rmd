---
title: "Figure 4"
subtitle: "Clustering Autism"
author: "Antoine Beauchamp"
date: "2024-07-22"
output: html_document
---

# Initialization

```{r fig4-knitr-setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r fig4-packages}
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(RMINC))
suppressPackageStartupMessages(library(MRIcrotome))
suppressPackageStartupMessages(library(grid))
suppressPackageStartupMessages(library(gridExtra))
suppressPackageStartupMessages(library(patchwork))
suppressPackageStartupMessages(library(viridis))
suppressPackageStartupMessages(library(viridisLite))
# suppressPackageStartupMessages(library(RColorBrewer))
# suppressPackageStartupMessages(library(rcartocolor))
# suppressPackageStartupMessages(library(pROC))
```

```{r fig4-environment}
SRCPATH <- Sys.getenv("SRCPATH")
PROJECTPATH <- Sys.getenv("PROJECTPATH")
```

```{r fig4-functions}
source(file.path(SRCPATH, "utils.R"))
source(file.path(SRCPATH, "processing.R"))
source(file.path(SRCPATH, "analysis.R"))
```

```{r fig4-pipeline-params}
# Output directory
output_dir <- "figure4/"
if (!dir.exists(output_dir)) {
  dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)
}

# Plot file prefix
output_plot_prefix <- "figure4"

# Similarity pipeline
version <- "v3"
pipeline_dir <- file.path(PROJECTPATH, "data/cross_species")
pipeline_dir <- file.path(pipeline_dir, version)

# Human parameters
human_dataset <- "POND-SickKids"
human_resolution <- 0.8
human_es_method <- "normative-growth"
human_es_df <- 3
human_centroid_method <- "mean"

# Mouse parameters
mouse_resolution <- 0.2

# Similarity parameters
metric <- "correlation"

# Fetch parameter set
metadata <- file.path(pipeline_dir, "metadata.csv")
params <- fetch_params_metadata(metadata = metadata,
                                input_1_species = "human",
                                input_1_id = "700",
                                input_2_species = "mouse",
                                input_2_id = "107",
                                n_latent_spaces = 50,
                                metric = metric)
params
```

```{r fig4-graphical-params}
# # Number of bigpts in an inch
# pt_per_in <- 72
# 
# # Font family
# font_family <- "Helvetica"
# 
# # Nature suggested font size: 5-7 pt
# font_size <- 6
# 
# # Empty rectangle grob
# empty_rect_grob <- rectGrob(gp = gpar(fill = NA))
# 
# # Black rectangle grob
black_rect_grob <- rectGrob(gp = gpar(fill = "black"))
# 
# # Rectangle with number in it
# rect_w_num <- function(n) {
#   out <- gTree(children = gList(empty_rect_grob,
#                                 textGrob(label = n)))
#   return(out)
# }
# 
# # Maximal figure dimensions in bigpts
# fig4_width_pt <- 510
# fig4_height_pt <- 481
```

```{r}
# Max and min similarity values
similarity_max <- 1.00
similarity_min <- 0.10
# similarity_max <- max(df_similarity_nk[["similarity"]])
# similarity_min <- min(df_similarity_nk[["similarity"]])

# Length of the heatmap palette
heatmap_palette_length <- 255

# Numerical values for the heatmap scale
heatmap_scale_values <- seq(similarity_min, similarity_max, length.out = heatmap_palette_length)
heatmap_scale_values <- (heatmap_scale_values - similarity_min)/(similarity_max - similarity_min)

# Colours for the heatmap palette 
heatmap_scale_colours <- magma(n = heatmap_palette_length, begin = 0.3)

# Heatmap palette vector
heatmap_scale_palette <- colorRampPalette(heatmap_scale_colours)(heatmap_palette_length)
```

# Heatmaps

## PONDSK-MICe

```{r fig4-PONDSK-MICe-heatmap}
pipeline_dir <- file.path(PROJECTPATH, "data/cross_species/v3/375/")

# Cluster solutions to visualize
nk_1 <- 2
nk_2 <- 4


# Import similarity ----------------------------------------------------------

# Path to mouse-human similarity directory
similarity_dir <- file.path(pipeline_dir, "similarity")
similarity_file <- file.path(similarity_dir, "similarity.csv")

# Import the similarity data and extract cluster information
similarity <- read_csv(similarity_file, show_col_types = FALSE) %>% 
  mutate(img1_nk = img1 %>% 
           basename() %>% 
           str_extract("_nk_[0-9]+") %>% 
           str_extract("[0-9]+") %>% 
           as.numeric(),
         img1_k = img1 %>% 
           basename() %>% 
           str_extract("_k_[0-9]+") %>% 
           str_extract("[0-9]+") %>% 
           as.numeric(),
         img1_jacobians = img1 %>% 
           str_extract("absolute|relative"),
         img2_nk = img2 %>% 
           basename() %>% 
           str_extract("_nk_[0-9]+") %>% 
           str_extract("[0-9]+") %>% 
           as.numeric(),
         img2_k = img2 %>% 
           basename() %>% 
           str_extract("_k_[0-9]+") %>% 
           str_extract("[0-9]+") %>% 
           as.numeric(),
         img2_jacobians = img2 %>% 
           str_extract("absolute|relative"),) %>% 
  unite(col = "img1_cluster_id", img1_nk, img1_k, 
        sep = "-", remove = FALSE) %>% 
  unite(col = "img2_cluster_id", img2_nk, img2_k, 
        sep = "-", remove = FALSE)

# Filter similarity data for desired cluster numbers
# and combine Jacobians
df_similarity_nk <- similarity %>% 
  filter(img1_nk == nk_1,
         img2_nk == nk_2) %>% 
  group_by(img1_cluster_id, img2_cluster_id) %>% 
  summarise(similarity = mean(similarity),
            .groups = "drop")


# Import permutations --------------------------------------------------------

# Path to permutations directory
permutation_dir <- file.path(pipeline_dir, "permutations", "similarity")

# Permutation file names
permutation_files <- list.files(permutation_dir)

# Number of permutations
np <- length(permutation_files)
list_permutations <- vector(mode = "list", length = np)  
for (p in 1:np) {
  
  # Permutation data to import
  permutation_file <- permutation_files %>% 
    str_subset(str_c("similarity_permutation_", p, ".csv"))
  permutation_file <- file.path(permutation_dir, permutation_file)
  
  # Import permutation data
  list_permutations[[p]] <- read_csv(permutation_file, 
                                     show_col_types = FALSE) %>% 
    mutate(img1_nk = img1 %>% 
             basename() %>% 
             str_extract("_nk_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric(),
           img1_k = img1 %>% 
             basename() %>% 
             str_extract("_k_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric(),
           img2_nk = img2 %>% 
             basename() %>% 
             str_extract("_nk_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric(),
           img2_k = img2 %>% 
             basename() %>% 
             str_extract("_k_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric()) %>% 
    unite(col = "img1_cluster_id", img1_nk, img1_k, 
          sep = "-", remove = FALSE) %>% 
    unite(col = "img2_cluster_id", img2_nk, img2_k, 
          sep = "-", remove = FALSE) %>% 
    mutate(permutation = p)
  
}

# Filter permutations data for desired cluster numbers
# and combine Jacobians
df_permutations_nk <- list_permutations %>% 
  bind_rows() %>% 
  filter(img1_nk == nk_1,
         img2_nk == nk_2) %>% 
  group_by(permutation, img1_nk, img2_nk, img1_cluster_id, img2_cluster_id) %>% 
  summarise(similarity = mean(similarity), .groups = "drop")


# Compute p-values -----------------------------------------------------------

# Compute p-values for cluster correlations
df_similarity_nk[["pval"]] <- 0
for (i in 1:nrow(df_similarity_nk)) {
  df_similarity_nk[[i, "pval"]] <- sum(df_permutations_nk[["similarity"]] >= df_similarity_nk[[i, "similarity"]])/nrow(df_permutations_nk)
}

# Compute q-values and -log10 transforms
df_similarity_nk <- df_similarity_nk %>% 
  mutate(qval = p.adjust(pval, method = "fdr"),
         pval_log = -log10(pval),
         qval_log = -log10(qval),
         significant = ifelse(pval <= 0.10, TRUE, FALSE),
         pval_lab = case_when(pval > 0.10 ~ "",
                              pval >= 0.001 & pval <= 0.10 ~ paste0("p = ", as.character(round(pval, 3))),
                              pval < 0.001 ~ "p < 0.001"))


# Generate heatmap -----------------------------------------------------------

# # Max and min similarity values
# similarity_max <- 1.00
# similarity_min <- 0.10
# # similarity_max <- max(df_similarity_nk[["similarity"]])
# # similarity_min <- min(df_similarity_nk[["similarity"]])
# 
# # Length of the heatmap palette
# heatmap_palette_length <- 255
# 
# # Numerical values for the heatmap scale
# heatmap_scale_values <- seq(similarity_min, similarity_max, length.out = heatmap_palette_length)
# heatmap_scale_values <- (heatmap_scale_values - similarity_min)/(similarity_max - similarity_min)
# 
# # Colours for the heatmap palette 
# heatmap_scale_colours <- magma(n = heatmap_palette_length, begin = 0.3)
# 
# # Heatmap palette vector
# heatmap_scale_palette <- colorRampPalette(heatmap_scale_colours)(heatmap_palette_length)

# Clamp log p-values when infinite
df_similarity_nk <- df_similarity_nk %>% 
  mutate(pval_log = ifelse(is.infinite(pval_log), 3, pval_log))

# Numerical values for the heatmap scale
heatmap_scale_values <- seq(similarity_min, similarity_max, length.out = heatmap_palette_length)
heatmap_scale_values <- (heatmap_scale_values - similarity_min)/(similarity_max - similarity_min)

# Colours for the heatmap palette 
heatmap_scale_colours <- magma(n = heatmap_palette_length, begin = 0.3)

# Heatmap palette vector
heatmap_scale_palette <- colorRampPalette(heatmap_scale_colours)(heatmap_palette_length)

# Heatmap plot
fig4_heatmap_PONDSK_MICe <- ggplot(df_similarity_nk, 
                                   aes(x = img2_cluster_id, 
                                       y = fct_rev(img1_cluster_id), 
                                       fill = similarity)) + 
  geom_tile(col = "grey50") + 
  geom_text(mapping = aes(label = pval_lab),
            size = 1.6, 
            hjust = "center", 
            vjust = "center") + 
  labs(x = "Mouse clusters",
       y = "POND-SickKids clusters",
       fill = "Correlation") + 
  scale_fill_gradientn(colors = heatmap_scale_palette,
                       values = heatmap_scale_values,
                       limits = c(0.1, 1.0),
                       breaks = seq(0, 1, by = 0.2),
                       guide = guide_colourbar(title.position = "top",
                                               title.hjust = 0.5)) + 
  scale_x_discrete(expand = expansion(mult = 0), position = "top") + 
  scale_y_discrete(expand = expansion(mult = 0)) + 
  theme_bw() +
  theme(legend.position = "bottom",
        legend.direction = "horizontal")

# Export
outfile <- paste0("figure4_PONDSK_MICe_heatmap_with_legend.pdf")
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = unit(500/72, "in"),
    height = unit(500/72, "in"))
print(fig4_heatmap_PONDSK_MICe)
dev.off()


fig4_heatmap_PONDSK_MICe <- fig4_heatmap_PONDSK_MICe +
    theme(legend.position = "none")

# Export
outfile <- paste0("figure4_PONDSK_MICe_heatmap.pdf")
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = unit(500/72, "in"),
    height = unit(500/72, "in"))
print(fig4_heatmap_PONDSK_MICe)
dev.off()
```

```{r}
df_similarity_nk %>% 
  select(img1_cluster_id, img2_cluster_id, similarity, pval)
```

```{r}
df_matches_PONDSK_MICe <- df_similarity_nk %>% 
  filter(significant) %>% 
  select(img1_cluster_id, img2_cluster_id)
```


```{r fig4-PONDSK-MICe-nk6-heatmap}
pipeline_dir <- file.path(PROJECTPATH, "data/cross_species/v3/375/")

# Cluster solutions to visualize
nk_1 <- 6
nk_2 <- 6


# Import similarity ----------------------------------------------------------

# Path to mouse-human similarity directory
similarity_dir <- file.path(pipeline_dir, "similarity")
similarity_file <- file.path(similarity_dir, "similarity.csv")

# Import the similarity data and extract cluster information
similarity <- read_csv(similarity_file, show_col_types = FALSE) %>% 
  mutate(img1_nk = img1 %>% 
           basename() %>% 
           str_extract("_nk_[0-9]+") %>% 
           str_extract("[0-9]+") %>% 
           as.numeric(),
         img1_k = img1 %>% 
           basename() %>% 
           str_extract("_k_[0-9]+") %>% 
           str_extract("[0-9]+") %>% 
           as.numeric(),
         img1_jacobians = img1 %>% 
           str_extract("absolute|relative"),
         img2_nk = img2 %>% 
           basename() %>% 
           str_extract("_nk_[0-9]+") %>% 
           str_extract("[0-9]+") %>% 
           as.numeric(),
         img2_k = img2 %>% 
           basename() %>% 
           str_extract("_k_[0-9]+") %>% 
           str_extract("[0-9]+") %>% 
           as.numeric(),
         img2_jacobians = img2 %>% 
           str_extract("absolute|relative"),) %>% 
  unite(col = "img1_cluster_id", img1_nk, img1_k, 
        sep = "-", remove = FALSE) %>% 
  unite(col = "img2_cluster_id", img2_nk, img2_k, 
        sep = "-", remove = FALSE)

# Filter similarity data for desired cluster numbers
# and combine Jacobians
df_similarity_nk <- similarity %>% 
  filter(img1_nk == nk_1,
         img2_nk == nk_2) %>% 
  group_by(img1_cluster_id, img2_cluster_id) %>% 
  summarise(similarity = mean(similarity),
            .groups = "drop")


# Import permutations --------------------------------------------------------

# Path to permutations directory
permutation_dir <- file.path(pipeline_dir, "permutations", "similarity")

# Permutation file names
permutation_files <- list.files(permutation_dir)

# Number of permutations
np <- length(permutation_files)
list_permutations <- vector(mode = "list", length = np)  
for (p in 1:np) {
  
  # Permutation data to import
  permutation_file <- permutation_files %>% 
    str_subset(str_c("similarity_permutation_", p, ".csv"))
  permutation_file <- file.path(permutation_dir, permutation_file)
  
  # Import permutation data
  list_permutations[[p]] <- read_csv(permutation_file, 
                                     show_col_types = FALSE) %>% 
    mutate(img1_nk = img1 %>% 
             basename() %>% 
             str_extract("_nk_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric(),
           img1_k = img1 %>% 
             basename() %>% 
             str_extract("_k_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric(),
           img2_nk = img2 %>% 
             basename() %>% 
             str_extract("_nk_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric(),
           img2_k = img2 %>% 
             basename() %>% 
             str_extract("_k_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric()) %>% 
    unite(col = "img1_cluster_id", img1_nk, img1_k, 
          sep = "-", remove = FALSE) %>% 
    unite(col = "img2_cluster_id", img2_nk, img2_k, 
          sep = "-", remove = FALSE) %>% 
    mutate(permutation = p)
  
}

# Filter permutations data for desired cluster numbers
# and combine Jacobians
df_permutations_nk <- list_permutations %>% 
  bind_rows() %>% 
  filter(img1_nk == nk_1,
         img2_nk == nk_2) %>% 
  group_by(permutation, img1_nk, img2_nk, img1_cluster_id, img2_cluster_id) %>% 
  summarise(similarity = mean(similarity), .groups = "drop")


# Compute p-values -----------------------------------------------------------

# Compute p-values for cluster correlations
df_similarity_nk[["pval"]] <- 0
for (i in 1:nrow(df_similarity_nk)) {
  df_similarity_nk[[i, "pval"]] <- sum(df_permutations_nk[["similarity"]] >= df_similarity_nk[[i, "similarity"]])/nrow(df_permutations_nk)
}

# Compute q-values and -log10 transforms
df_similarity_nk <- df_similarity_nk %>% 
  mutate(qval = p.adjust(pval, method = "fdr"),
         pval_log = -log10(pval),
         qval_log = -log10(qval),
         significant = ifelse(pval <= 0.10, TRUE, FALSE),
         pval_lab = case_when(pval > 0.10 ~ "",
                              pval >= 0.001 & pval <= 0.10 ~ paste0("p = ", as.character(round(pval, 3))),
                              pval < 0.001 ~ "p < 0.001"))

# Generate heatmap -----------------------------------------------------------

# Clamp log p-values when infinite
df_similarity_nk <- df_similarity_nk %>% 
  mutate(pval_log = ifelse(is.infinite(pval_log), 3, pval_log))

# Heatmap plot
fig4_heatmap_PONDSK_MICe_nk6 <- ggplot(df_similarity_nk, 
                                       aes(x = img2_cluster_id, 
                                           y = fct_rev(img1_cluster_id), 
                                           fill = similarity)) + 
  geom_tile(col = "grey50") + 
  geom_text(mapping = aes(label = pval_lab),
            size = 1.4, 
            hjust = "center", 
            vjust = "center") + 
  labs(x = "Mouse clusters",
       y = "POND-SickKids clusters",
       fill = "Correlation") + 
  scale_fill_gradientn(colors = heatmap_scale_palette,
                       values = heatmap_scale_values,
                       limits = c(0.1, 1.0),
                       breaks = seq(0, 1, by = 0.2)) + 
  scale_x_discrete(expand = expansion(mult = 0), position = "top") + 
  scale_y_discrete(expand = expansion(mult = 0)) + 
  theme_bw() +
  theme(legend.position = "none")

# Export
outfile <- paste0("figure4_PONDSK_MICe_heatmap_nk6.pdf")
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = unit(500/72, "in"),
    height = unit(500/72, "in"))
print(fig4_heatmap_PONDSK_MICe_nk6)
dev.off()
```

```{r}
df_matches_PONDSK_MICe <- bind_rows(df_matches_PONDSK_MICe,
                                    df_similarity_nk %>% 
                                      filter(significant) %>% 
                                      select(img1_cluster_id, img2_cluster_id))
```



## HBN-MICe


```{r fig4-HBN-MICe-heatmap}
pipeline_dir <- file.path(PROJECTPATH, "data/cross_species/v3/861/")

# Cluster solutions to visualize
nk_1 <- 3
nk_2 <- 4


# Import similarity ----------------------------------------------------------

# Path to mouse-human similarity directory
similarity_dir <- file.path(pipeline_dir, "similarity")
similarity_file <- file.path(similarity_dir, "similarity.csv")

# Import the similarity data and extract cluster information
similarity <- read_csv(similarity_file, show_col_types = FALSE) %>% 
  mutate(img1_nk = img1 %>% 
           basename() %>% 
           str_extract("_nk_[0-9]+") %>% 
           str_extract("[0-9]+") %>% 
           as.numeric(),
         img1_k = img1 %>% 
           basename() %>% 
           str_extract("_k_[0-9]+") %>% 
           str_extract("[0-9]+") %>% 
           as.numeric(),
         img1_jacobians = img1 %>% 
           str_extract("absolute|relative"),
         img2_nk = img2 %>% 
           basename() %>% 
           str_extract("_nk_[0-9]+") %>% 
           str_extract("[0-9]+") %>% 
           as.numeric(),
         img2_k = img2 %>% 
           basename() %>% 
           str_extract("_k_[0-9]+") %>% 
           str_extract("[0-9]+") %>% 
           as.numeric(),
         img2_jacobians = img2 %>% 
           str_extract("absolute|relative"),) %>% 
  unite(col = "img1_cluster_id", img1_nk, img1_k, 
        sep = "-", remove = FALSE) %>% 
  unite(col = "img2_cluster_id", img2_nk, img2_k, 
        sep = "-", remove = FALSE)

# Filter similarity data for desired cluster numbers
# and combine Jacobians
df_similarity_nk <- similarity %>% 
  filter(img1_nk == nk_1,
         img2_nk == nk_2) %>% 
  group_by(img1_cluster_id, img2_cluster_id) %>% 
  summarise(similarity = mean(similarity),
            .groups = "drop")


# Import permutations --------------------------------------------------------

# Path to permutations directory
permutation_dir <- file.path(pipeline_dir, "permutations", "similarity")

# Permutation file names
permutation_files <- list.files(permutation_dir)

# Number of permutations
np <- length(permutation_files)
list_permutations <- vector(mode = "list", length = np)  
for (p in 1:np) {
  
  # Permutation data to import
  permutation_file <- permutation_files %>% 
    str_subset(str_c("similarity_permutation_", p, ".csv"))
  permutation_file <- file.path(permutation_dir, permutation_file)
  
  # Import permutation data
  list_permutations[[p]] <- read_csv(permutation_file, 
                                     show_col_types = FALSE) %>% 
    mutate(img1_nk = img1 %>% 
             basename() %>% 
             str_extract("_nk_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric(),
           img1_k = img1 %>% 
             basename() %>% 
             str_extract("_k_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric(),
           img2_nk = img2 %>% 
             basename() %>% 
             str_extract("_nk_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric(),
           img2_k = img2 %>% 
             basename() %>% 
             str_extract("_k_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric()) %>% 
    unite(col = "img1_cluster_id", img1_nk, img1_k, 
          sep = "-", remove = FALSE) %>% 
    unite(col = "img2_cluster_id", img2_nk, img2_k, 
          sep = "-", remove = FALSE) %>% 
    mutate(permutation = p)
  
}

# Filter permutations data for desired cluster numbers
# and combine Jacobians
df_permutations_nk <- list_permutations %>% 
  bind_rows() %>% 
  filter(img1_nk == nk_1,
         img2_nk == nk_2) %>% 
  group_by(permutation, img1_nk, img2_nk, img1_cluster_id, img2_cluster_id) %>% 
  summarise(similarity = mean(similarity), .groups = "drop")


# Compute p-values -----------------------------------------------------------

# Compute p-values for cluster correlations
df_similarity_nk[["pval"]] <- 0
for (i in 1:nrow(df_similarity_nk)) {
  df_similarity_nk[[i, "pval"]] <- sum(df_permutations_nk[["similarity"]] >= df_similarity_nk[[i, "similarity"]])/nrow(df_permutations_nk)
}

# Compute q-values and -log10 transforms
df_similarity_nk <- df_similarity_nk %>% 
  mutate(qval = p.adjust(pval, method = "fdr"),
         pval_log = -log10(pval),
         qval_log = -log10(qval),
         significant = ifelse(pval <= 0.10, TRUE, FALSE),
         pval_lab = case_when(pval > 0.10 ~ "",
                              pval >= 0.001 & pval <= 0.10 ~ paste0("p = ", as.character(round(pval, 3))),
                              pval < 0.001 ~ "p < 0.001"))


# Generate heatmap -----------------------------------------------------------

# Clamp log p-values when infinite
df_similarity_nk <- df_similarity_nk %>% 
  mutate(pval_log = ifelse(is.infinite(pval_log), 3, pval_log))

# Heatmap plot
fig4_heatmap_HBN_MICe <- ggplot(df_similarity_nk, 
                                aes(x = img2_cluster_id, 
                                    y = fct_rev(img1_cluster_id), 
                                    fill = similarity)) + 
  geom_tile(col = "grey50") + 
  geom_text(mapping = aes(label = pval_lab),
            size = 1.6, 
            hjust = "center", 
            vjust = "center") + 
  labs(x = "Mouse clusters",
       y = "HBN clusters",
       fill = "Correlation") + 
  scale_fill_gradientn(colors = heatmap_scale_palette,
                       values = heatmap_scale_values,
                       limits = c(0.1, 1.0),
                       breaks = seq(0, 1, by = 0.2)) + 
  scale_x_discrete(expand = expansion(mult = 0), position = "top") + 
  scale_y_discrete(expand = expansion(mult = 0)) + 
  theme_bw() +
  theme(legend.position = "none")

# Export
outfile <- paste0("figure4_HBN_MICe_heatmap.pdf")
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = unit(500/72, "in"),
    height = unit(500/72, "in"))
print(fig4_heatmap_HBN_MICe)
dev.off()
```


```{r}
df_similarity_nk %>% 
  select(img1_cluster_id, img2_cluster_id, similarity, pval)
```

```{r}
df_matches_HBN_MICe <- tibble()
df_matches_HBN_MICe <- bind_rows(df_matches_HBN_MICe,
                                 df_similarity_nk %>% 
                                   filter(significant) %>% 
                                   select(img1_cluster_id, img2_cluster_id))
```


```{r fig4-HBN-MICe-nk6-heatmap}
pipeline_dir <- file.path(PROJECTPATH, "data/cross_species/v3/861/")

# Cluster solutions to visualize
nk_1 <- 6
nk_2 <- 6


# Import similarity ----------------------------------------------------------

# Path to mouse-human similarity directory
similarity_dir <- file.path(pipeline_dir, "similarity")
similarity_file <- file.path(similarity_dir, "similarity.csv")

# Import the similarity data and extract cluster information
similarity <- read_csv(similarity_file, show_col_types = FALSE) %>% 
  mutate(img1_nk = img1 %>% 
           basename() %>% 
           str_extract("_nk_[0-9]+") %>% 
           str_extract("[0-9]+") %>% 
           as.numeric(),
         img1_k = img1 %>% 
           basename() %>% 
           str_extract("_k_[0-9]+") %>% 
           str_extract("[0-9]+") %>% 
           as.numeric(),
         img1_jacobians = img1 %>% 
           str_extract("absolute|relative"),
         img2_nk = img2 %>% 
           basename() %>% 
           str_extract("_nk_[0-9]+") %>% 
           str_extract("[0-9]+") %>% 
           as.numeric(),
         img2_k = img2 %>% 
           basename() %>% 
           str_extract("_k_[0-9]+") %>% 
           str_extract("[0-9]+") %>% 
           as.numeric(),
         img2_jacobians = img2 %>% 
           str_extract("absolute|relative"),) %>% 
  unite(col = "img1_cluster_id", img1_nk, img1_k, 
        sep = "-", remove = FALSE) %>% 
  unite(col = "img2_cluster_id", img2_nk, img2_k, 
        sep = "-", remove = FALSE)

# Filter similarity data for desired cluster numbers
# and combine Jacobians
df_similarity_nk <- similarity %>% 
  filter(img1_nk == nk_1,
         img2_nk == nk_2) %>% 
  group_by(img1_cluster_id, img2_cluster_id) %>% 
  summarise(similarity = mean(similarity),
            .groups = "drop")


# Import permutations --------------------------------------------------------

# Path to permutations directory
permutation_dir <- file.path(pipeline_dir, "permutations", "similarity")

# Permutation file names
permutation_files <- list.files(permutation_dir)

# Number of permutations
np <- length(permutation_files)
list_permutations <- vector(mode = "list", length = np)  
for (p in 1:np) {
  
  # Permutation data to import
  permutation_file <- permutation_files %>% 
    str_subset(str_c("similarity_permutation_", p, ".csv"))
  permutation_file <- file.path(permutation_dir, permutation_file)
  
  # Import permutation data
  list_permutations[[p]] <- read_csv(permutation_file, 
                                     show_col_types = FALSE) %>% 
    mutate(img1_nk = img1 %>% 
             basename() %>% 
             str_extract("_nk_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric(),
           img1_k = img1 %>% 
             basename() %>% 
             str_extract("_k_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric(),
           img2_nk = img2 %>% 
             basename() %>% 
             str_extract("_nk_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric(),
           img2_k = img2 %>% 
             basename() %>% 
             str_extract("_k_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric()) %>% 
    unite(col = "img1_cluster_id", img1_nk, img1_k, 
          sep = "-", remove = FALSE) %>% 
    unite(col = "img2_cluster_id", img2_nk, img2_k, 
          sep = "-", remove = FALSE) %>% 
    mutate(permutation = p)
  
}

# Filter permutations data for desired cluster numbers
# and combine Jacobians
df_permutations_nk <- list_permutations %>% 
  bind_rows() %>% 
  filter(img1_nk == nk_1,
         img2_nk == nk_2) %>% 
  group_by(permutation, img1_nk, img2_nk, img1_cluster_id, img2_cluster_id) %>% 
  summarise(similarity = mean(similarity), .groups = "drop")


# Compute p-values -----------------------------------------------------------

# Compute p-values for cluster correlations
df_similarity_nk[["pval"]] <- 0
for (i in 1:nrow(df_similarity_nk)) {
  df_similarity_nk[[i, "pval"]] <- sum(df_permutations_nk[["similarity"]] >= df_similarity_nk[[i, "similarity"]])/nrow(df_permutations_nk)
}

# Compute q-values and -log10 transforms
df_similarity_nk <- df_similarity_nk %>% 
  mutate(qval = p.adjust(pval, method = "fdr"),
         pval_log = -log10(pval),
         qval_log = -log10(qval),
         significant = ifelse(pval <= 0.10, TRUE, FALSE),
         pval_lab = case_when(pval > 0.10 ~ "",
                              pval >= 0.001 & pval <= 0.10 ~ paste0("p = ", as.character(round(pval, 3))),
                              pval < 0.001 ~ "p < 0.001"))


# Generate heatmap -----------------------------------------------------------

# Clamp log p-values when infinite
df_similarity_nk <- df_similarity_nk %>% 
  mutate(pval_log = ifelse(is.infinite(pval_log), 3, pval_log))

# Heatmap plot
fig4_heatmap_HBN_MICe_nk6 <- ggplot(df_similarity_nk, 
                                    aes(x = img2_cluster_id, 
                                        y = fct_rev(img1_cluster_id), 
                                        fill = similarity)) + 
  geom_tile(col = "grey50") + 
  geom_text(mapping = aes(label = pval_lab),
            size = 1.4, 
            hjust = "center", 
            vjust = "center") + 
  labs(x = "Mouse clusters",
       y = "HBN clusters",
       fill = "Correlation") + 
  scale_fill_gradientn(colors = heatmap_scale_palette,
                       values = heatmap_scale_values,
                       limits = c(0.1, 1.0),
                       breaks = seq(0, 1, by = 0.2)) + 
  scale_x_discrete(expand = expansion(mult = 0), position = "top") + 
  scale_y_discrete(expand = expansion(mult = 0)) + 
  theme_bw() +
  theme(legend.position = "none")

# Export
outfile <- paste0("figure4_HBN_MICe_heatmap_nk6.pdf")
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = unit(500/72, "in"),
    height = unit(500/72, "in"))
print(fig4_heatmap_HBN_MICe_nk6)
dev.off()
```


```{r}
df_matches_HBN_MICe <- bind_rows(df_matches_HBN_MICe,
                                 df_similarity_nk %>% 
                                   filter(significant) %>% 
                                   select(img1_cluster_id, img2_cluster_id))
```



## PONDSK-HBN

```{r fig4-PONDSK-HBN-heatmap}
pipeline_dir <- file.path(PROJECTPATH, "data/cross_species/v3/779/")

# Cluster solutions to visualize
nk_1 <- 2
nk_2 <- 3


# Import similarity ----------------------------------------------------------

# Path to mouse-human similarity directory
similarity_dir <- file.path(pipeline_dir, "similarity")
similarity_file <- file.path(similarity_dir, "similarity.csv")

# Import the similarity data and extract cluster information
similarity <- read_csv(similarity_file, show_col_types = FALSE) %>% 
  mutate(img1_nk = img1 %>% 
           basename() %>% 
           str_extract("_nk_[0-9]+") %>% 
           str_extract("[0-9]+") %>% 
           as.numeric(),
         img1_k = img1 %>% 
           basename() %>% 
           str_extract("_k_[0-9]+") %>% 
           str_extract("[0-9]+") %>% 
           as.numeric(),
         img1_jacobians = img1 %>% 
           str_extract("absolute|relative"),
         img2_nk = img2 %>% 
           basename() %>% 
           str_extract("_nk_[0-9]+") %>% 
           str_extract("[0-9]+") %>% 
           as.numeric(),
         img2_k = img2 %>% 
           basename() %>% 
           str_extract("_k_[0-9]+") %>% 
           str_extract("[0-9]+") %>% 
           as.numeric(),
         img2_jacobians = img2 %>% 
           str_extract("absolute|relative"),) %>% 
  unite(col = "img1_cluster_id", img1_nk, img1_k, 
        sep = "-", remove = FALSE) %>% 
  unite(col = "img2_cluster_id", img2_nk, img2_k, 
        sep = "-", remove = FALSE)

# Filter similarity data for desired cluster numbers
# and combine Jacobians
df_similarity_nk <- similarity %>% 
  filter(img1_nk == nk_1,
         img2_nk == nk_2) %>% 
  group_by(img1_cluster_id, img2_cluster_id) %>% 
  summarise(similarity = mean(similarity),
            .groups = "drop")


# Import permutations --------------------------------------------------------

# Path to permutations directory
permutation_dir <- file.path(pipeline_dir, "permutations", "similarity")

# Permutation file names
permutation_files <- list.files(permutation_dir)

# Number of permutations
np <- length(permutation_files)
list_permutations <- vector(mode = "list", length = np)  
for (p in 1:np) {
  
  # Permutation data to import
  permutation_file <- permutation_files %>% 
    str_subset(str_c("similarity_permutation_", p, ".csv"))
  permutation_file <- file.path(permutation_dir, permutation_file)
  
  # Import permutation data
  list_permutations[[p]] <- read_csv(permutation_file, 
                                     show_col_types = FALSE) %>% 
    mutate(img1_nk = img1 %>% 
             basename() %>% 
             str_extract("_nk_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric(),
           img1_k = img1 %>% 
             basename() %>% 
             str_extract("_k_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric(),
           img2_nk = img2 %>% 
             basename() %>% 
             str_extract("_nk_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric(),
           img2_k = img2 %>% 
             basename() %>% 
             str_extract("_k_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric()) %>% 
    unite(col = "img1_cluster_id", img1_nk, img1_k, 
          sep = "-", remove = FALSE) %>% 
    unite(col = "img2_cluster_id", img2_nk, img2_k, 
          sep = "-", remove = FALSE) %>% 
    mutate(permutation = p)
  
}

# Filter permutations data for desired cluster numbers
# and combine Jacobians
df_permutations_nk <- list_permutations %>% 
  bind_rows() %>% 
  filter(img1_nk == nk_1,
         img2_nk == nk_2) %>% 
  group_by(permutation, img1_nk, img2_nk, img1_cluster_id, img2_cluster_id) %>% 
  summarise(similarity = mean(similarity), .groups = "drop")


# Compute p-values -----------------------------------------------------------

# Compute p-values for cluster correlations
df_similarity_nk[["pval"]] <- 0
for (i in 1:nrow(df_similarity_nk)) {
  df_similarity_nk[[i, "pval"]] <- sum(df_permutations_nk[["similarity"]] >= df_similarity_nk[[i, "similarity"]])/nrow(df_permutations_nk)
}

# Compute q-values and -log10 transforms
df_similarity_nk <- df_similarity_nk %>% 
  mutate(qval = p.adjust(pval, method = "fdr"),
         pval_log = -log10(pval),
         qval_log = -log10(qval),
         significant = ifelse(pval <= 0.10, TRUE, FALSE),
         pval_lab = case_when(pval > 0.10 ~ "",
                              pval >= 0.001 & pval <= 0.10 ~ paste0("p = ", as.character(round(pval, 3))),
                              pval < 0.001 ~ "p < 0.001"))


# Generate heatmap -----------------------------------------------------------

# Clamp log p-values when infinite
df_similarity_nk <- df_similarity_nk %>% 
  mutate(pval_log = ifelse(is.infinite(pval_log), 3, pval_log))

# Heatmap plot
fig4_heatmap_PONDSK_HBN <- ggplot(df_similarity_nk, 
                                  aes(x = img2_cluster_id, 
                                      y = fct_rev(img1_cluster_id), 
                                      fill = similarity)) + 
  geom_tile(col = "grey50") + 
  geom_text(mapping = aes(label = pval_lab),
            size = 1.6, 
            hjust = "center", 
            vjust = "center") + 
  labs(x = "HBN clusters",
       y = "POND-SickKids clusters",
       fill = "Correlation") + 
  scale_fill_gradientn(colors = heatmap_scale_palette,
                       values = heatmap_scale_values,
                       limits = c(0.1, 1.0),
                       breaks = seq(0, 1, by = 0.2)) + 
  scale_x_discrete(expand = expansion(mult = 0), position = "top") + 
  scale_y_discrete(expand = expansion(mult = 0)) + 
  theme_bw() +
  theme(legend.position = "none")

# Export
outfile <- paste0("figure4_PONDSK_HBN_heatmap.pdf")
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = unit(500/72, "in"),
    height = unit(500/72, "in"))
print(fig4_heatmap_PONDSK_HBN)
dev.off()
```


```{r}
df_similarity_nk %>% 
  select(img1_cluster_id, img2_cluster_id, similarity, pval)
```

```{r}
df_matches_PONDSK_HBN <- tibble()
df_matches_PONDSK_HBN <- bind_rows(df_matches_PONDSK_HBN,
                                   df_similarity_nk %>% 
                                     filter(significant) %>% 
                                     select(img1_cluster_id, img2_cluster_id))
```


```{r fig4-PONDSK-HBN-nk6-heatmap}
pipeline_dir <- file.path(PROJECTPATH, "data/cross_species/v3/779/")

# Cluster solutions to visualize
nk_1 <- 6
nk_2 <- 6


# Import similarity ----------------------------------------------------------

# Path to mouse-human similarity directory
similarity_dir <- file.path(pipeline_dir, "similarity")
similarity_file <- file.path(similarity_dir, "similarity.csv")

# Import the similarity data and extract cluster information
similarity <- read_csv(similarity_file, show_col_types = FALSE) %>% 
  mutate(img1_nk = img1 %>% 
           basename() %>% 
           str_extract("_nk_[0-9]+") %>% 
           str_extract("[0-9]+") %>% 
           as.numeric(),
         img1_k = img1 %>% 
           basename() %>% 
           str_extract("_k_[0-9]+") %>% 
           str_extract("[0-9]+") %>% 
           as.numeric(),
         img1_jacobians = img1 %>% 
           str_extract("absolute|relative"),
         img2_nk = img2 %>% 
           basename() %>% 
           str_extract("_nk_[0-9]+") %>% 
           str_extract("[0-9]+") %>% 
           as.numeric(),
         img2_k = img2 %>% 
           basename() %>% 
           str_extract("_k_[0-9]+") %>% 
           str_extract("[0-9]+") %>% 
           as.numeric(),
         img2_jacobians = img2 %>% 
           str_extract("absolute|relative"),) %>% 
  unite(col = "img1_cluster_id", img1_nk, img1_k, 
        sep = "-", remove = FALSE) %>% 
  unite(col = "img2_cluster_id", img2_nk, img2_k, 
        sep = "-", remove = FALSE)

# Filter similarity data for desired cluster numbers
# and combine Jacobians
df_similarity_nk <- similarity %>% 
  filter(img1_nk == nk_1,
         img2_nk == nk_2) %>% 
  group_by(img1_cluster_id, img2_cluster_id) %>% 
  summarise(similarity = mean(similarity),
            .groups = "drop")


# Import permutations --------------------------------------------------------

# Path to permutations directory
permutation_dir <- file.path(pipeline_dir, "permutations", "similarity")

# Permutation file names
permutation_files <- list.files(permutation_dir)

# Number of permutations
np <- length(permutation_files)
list_permutations <- vector(mode = "list", length = np)  
for (p in 1:np) {
  
  # Permutation data to import
  permutation_file <- permutation_files %>% 
    str_subset(str_c("similarity_permutation_", p, ".csv"))
  permutation_file <- file.path(permutation_dir, permutation_file)
  
  # Import permutation data
  list_permutations[[p]] <- read_csv(permutation_file, 
                                     show_col_types = FALSE) %>% 
    mutate(img1_nk = img1 %>% 
             basename() %>% 
             str_extract("_nk_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric(),
           img1_k = img1 %>% 
             basename() %>% 
             str_extract("_k_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric(),
           img2_nk = img2 %>% 
             basename() %>% 
             str_extract("_nk_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric(),
           img2_k = img2 %>% 
             basename() %>% 
             str_extract("_k_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric()) %>% 
    unite(col = "img1_cluster_id", img1_nk, img1_k, 
          sep = "-", remove = FALSE) %>% 
    unite(col = "img2_cluster_id", img2_nk, img2_k, 
          sep = "-", remove = FALSE) %>% 
    mutate(permutation = p)
  
}

# Filter permutations data for desired cluster numbers
# and combine Jacobians
df_permutations_nk <- list_permutations %>% 
  bind_rows() %>% 
  filter(img1_nk == nk_1,
         img2_nk == nk_2) %>% 
  group_by(permutation, img1_nk, img2_nk, img1_cluster_id, img2_cluster_id) %>% 
  summarise(similarity = mean(similarity), .groups = "drop")


# Compute p-values -----------------------------------------------------------

# Compute p-values for cluster correlations
df_similarity_nk[["pval"]] <- 0
for (i in 1:nrow(df_similarity_nk)) {
  df_similarity_nk[[i, "pval"]] <- sum(df_permutations_nk[["similarity"]] >= df_similarity_nk[[i, "similarity"]])/nrow(df_permutations_nk)
}

# Compute q-values and -log10 transforms
df_similarity_nk <- df_similarity_nk %>% 
  mutate(qval = p.adjust(pval, method = "fdr"),
         pval_log = -log10(pval),
         qval_log = -log10(qval),
         significant = ifelse(pval <= 0.10, TRUE, FALSE),
         pval_lab = case_when(pval > 0.10 ~ "",
                              pval >= 0.001 & pval <= 0.10 ~ paste0("p = ", as.character(round(pval, 3))),
                              pval < 0.001 ~ "p < 0.001"))


# Generate heatmap -----------------------------------------------------------

# Clamp log p-values when infinite
df_similarity_nk <- df_similarity_nk %>% 
  mutate(pval_log = ifelse(is.infinite(pval_log), 3, pval_log))

# Heatmap plot
fig4_heatmap_PONDSK_HBN_nk6 <- ggplot(df_similarity_nk, 
                                      aes(x = img2_cluster_id, 
                                          y = fct_rev(img1_cluster_id), 
                                          fill = similarity)) + 
  geom_tile(col = "grey50") + 
  geom_text(mapping = aes(label = pval_lab),
            size = 1.4, 
            hjust = "center", 
            vjust = "center") + 
  labs(x = "HBN clusters",
       y = "POND-SickKids clusters",
       fill = "Correlation") + 
  scale_fill_gradientn(colors = heatmap_scale_palette,
                       values = heatmap_scale_values,
                       limits = c(0.1, 1.0),
                       breaks = seq(0, 1, by = 0.2)) + 
  scale_x_discrete(expand = expansion(mult = 0), position = "top") + 
  scale_y_discrete(expand = expansion(mult = 0)) + 
  theme_bw() +
  theme(legend.position = "none")

# Export
outfile <- paste0("figure4_PONDSK_HBN_heatmap_nk6.pdf")
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = unit(500/72, "in"),
    height = unit(500/72, "in"))
print(fig4_heatmap_PONDSK_HBN_nk6)
dev.off()
```


```{r}
df_matches_PONDSK_HBN <- bind_rows(df_matches_PONDSK_HBN,
                                   df_similarity_nk %>% 
                                     filter(significant) %>% 
                                     select(img1_cluster_id, img2_cluster_id))
```


```{r}
# Font family
font_family <- "Helvetica"

# Nature suggested font size: 5-7 pt
font_size <- 6

fig4_heatmap <- (fig4_heatmap_PONDSK_MICe | fig4_heatmap_HBN_MICe | fig4_heatmap_PONDSK_HBN) /
  (fig4_heatmap_PONDSK_MICe_nk6 | fig4_heatmap_HBN_MICe_nk6 | fig4_heatmap_PONDSK_HBN_nk6) +
  plot_layout(heights = c(1, 2)) &
  theme(axis.text = element_text(size = font_size-1, family = font_family),
        axis.title = element_text(size = font_size, family = font_family),
        plot.margin = margin(t = 3, r = 3, b = 3, l = 3))

outfile <- paste0("figure4_heatmap.pdf")
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = unit(510/72, "in"),
    height = unit(254/72, "in"))
print(fig4_heatmap)
dev.off()
```



# Brain slices


```{r fig3-ss-mouse-paths}
# Mouse anatomy
mouse_anat_file <- file.path(PROJECTPATH, "data/mouse/atlas/DSURQE_CCFv3_average_50um.mnc")
mouse_anat <- mincGetVolume(mouse_anat_file)
mouse_anat_vol <- mincArray(mouse_anat)

# Mouse mask
mouse_mask_file <- file.path(PROJECTPATH, "data/mouse/atlas/coronal_50um_coverage_bin0.8.mnc")
mouse_mask <- mincGetVolume(mouse_mask_file)
```

```{r fig3-ss-human-paths}
# Human mask
human_mask_file <- file.path(PROJECTPATH, "data/human/registration/v3/reference_files/mask_0.8mm.mnc")
human_mask <- mincGetVolume(human_mask_file)

# Human anatomy
human_anat_file <- file.path(PROJECTPATH, "data/human/registration/v3/reference_files/model_0.8mm.mnc")
human_anat <- mincGetVolume(human_anat_file)
human_anat[human_mask != 1] <- 0
human_anat_vol <- mincArray(human_anat)

# Cropped human human images
slices_dim_1 <- 27:220
slices_dim_2 <- 10:280
slices_dim_3 <- 10:220
human_anat_vol_cropped <- human_anat_vol[slices_dim_1, slices_dim_2, slices_dim_3]
```


## PONDSK-MICe

```{r}
# Fetch parameter set for PONDSK-MICe pipeline
params_id <- 375
metadata <- file.path(PROJECTPATH, "data/cross_species/v3/metadata.csv")
params <- fetch_params_metadata(metadata = metadata,
                                id = params_id)
```

```{r fig3-ss-mouse-paths}
# Jacobians to display
jacobians <- "relative"

# Threshold method
threshold <- params %>% 
  filter(id == params_id) %>% 
  pull(threshold)

# Threshold value
threshold_value <- params %>% 
  filter(id == params_id) %>% 
  pull(threshold_value)

# Threshold symmetric option
threshold_symmetric <- params %>% 
  filter(id == params_id) %>% 
  pull(threshold_symmetric)

# Mouse parameter set ID
mouse_params_id <- params %>% 
  filter(id == params_id) %>% 
  pull(input_2_id)

# Mouse pipeline directory
mouse_pipeline_dir <- file.path(PROJECTPATH, "data/mouse/derivatives/")
mouse_pipeline_dir <- file.path(mouse_pipeline_dir, version)
mouse_pipeline_dir <- file.path(mouse_pipeline_dir, mouse_params_id)

# Mouse centroid map directory
mouse_centroid_dir <- file.path(mouse_pipeline_dir, "centroids")
mouse_centroid_dir <- file.path(mouse_centroid_dir, "resolution_0.05")
mouse_centroid_dir <- file.path(mouse_centroid_dir, jacobians)

# Human parameter set ID
human_params_id <- params %>% 
  filter(id == params_id) %>% 
  pull(input_1_id)

# Human image resolution
human_resolution <- params %>% 
  filter(id == params_id) %>% 
  pull(input_1_resolution)
human_resolution <- sprintf("%.1f", human_resolution)

# Human pipeline directory
human_pipeline_dir <- file.path(PROJECTPATH, "data/human/derivatives/")
human_pipeline_dir <- file.path(human_pipeline_dir, version)
human_pipeline_dir <- file.path(human_pipeline_dir, human_params_id)

# Human centroid map directory
human_centroid_dir <- file.path(human_pipeline_dir, "centroids")
human_centroid_dir <- file.path(human_centroid_dir, paste("resolution", human_resolution, sep = "_"))
human_centroid_dir <- file.path(human_centroid_dir, jacobians)
```

```{r}
df_matches_PONDSK_MICe
```

```{r fig3-ss-human-import}
# Anatomical plane to display
# Sagittal: 1
# Coronal: 2 
# Transverse: 3
human_slc_dim <- 1

# Human brain slice to display
human_slc <- 82

# Iterate over mouse slices
list_human_slices <- vector(mode = "list", length = nrow(df_matches_PONDSK_MICe))
names(list_human_slices) <- df_matches_PONDSK_MICe$img1_cluster_id
for(i in 1:nrow(df_matches_PONDSK_MICe)) {
  
  cluster_id <- df_matches_PONDSK_MICe[[i, "img1_cluster_id"]]
  
  nk <- str_split(cluster_id, pattern = "-", simplify = TRUE)[1]
  k <- str_split(cluster_id, pattern = "-", simplify = TRUE)[2]
  
  print(paste(nk, k, sep = "-"))
  
  # Import centroid image and threshold
  img <- import_cluster_map(imgdir = human_centroid_dir,
                            mask = human_mask_file,
                            nk = nk, k = k,
                            threshold = threshold,
                            threshold_value = threshold_value,
                            threshold_symmetric = threshold_symmetric)
  
  # Compute overlay thresholds
  overlay_threshold <- numeric(2)
  overlay_threshold[1] <- min(abs(img[img != 0]))
  overlay_threshold[2] <- 0.8*max(abs(img[img != 0]))
  overlay_threshold <- round(overlay_threshold, 2)
  
  # Convert mincSingleDim to mincArray and crop
  img <- mincArray(img)
  img <- img[slices_dim_1, slices_dim_2, slices_dim_3]
  
  # Generate slice series
  list_human_slices[[i]] <- sliceSeries(nrow = 1, ncol = 1, 
                                        dimension = human_slc_dim, 
                                        slices = human_slc) %>% 
    anatomy(human_anat_vol_cropped, low = 40, high = 110) %>% 
    overlay(img, 
            low = overlay_threshold[1], 
            high = overlay_threshold[2], 
            symmetric = TRUE) %>% 
    grobify()
  
}
```

```{r fig3-ss-mouse-import}
# Anatomical plane to display
# Sagittal: 1
# Coronal: 2 
# Transverse: 3
mouse_slc_dim <- 1

# Mouse brain slice to display
mouse_slc <- 92

# Iterate over nk subset
list_mouse_slices <- vector(mode = "list", length = nrow(df_matches_PONDSK_MICe))
names(list_mouse_slices) <- df_matches_PONDSK_MICe$img2_cluster_id
for(i in 1:nrow(df_matches_PONDSK_MICe)) {
  
  cluster_id <- df_matches_PONDSK_MICe[[i, "img2_cluster_id"]]
  
  nk <- str_split(cluster_id, pattern = "-", simplify = TRUE)[1]
  k <- str_split(cluster_id, pattern = "-", simplify = TRUE)[2]
  
  print(paste(nk, k, sep = "-"))
  
  # Import centroid image and threshold
  img <- import_cluster_map(imgdir = mouse_centroid_dir,
                            mask = mouse_mask_file,
                            nk = nk, k = k,
                            threshold = threshold,
                            threshold_value = threshold_value,
                            threshold_symmetric = threshold_symmetric)
  
  # Compute overlay thresholds
  overlay_threshold <- numeric(2)
  overlay_threshold[1] <- min(abs(img[img != 0]))
  overlay_threshold[2] <- 0.8*max(abs(img[img != 0]))
  overlay_threshold <- round(overlay_threshold, 2)
  
  # Convert mincSingleDim to mincArray
  img <- mincArray(img)
  
  # Generate slice series
  list_mouse_slices[[i]] <- sliceSeries(nrow = 1, ncol = 1, 
                                        dimension = mouse_slc_dim, 
                                        slices = mouse_slc) %>% 
    anatomy(mouse_anat_vol, low = 700, high = 1400) %>% 
    overlay(img, 
            low = overlay_threshold[1], high = overlay_threshold[2], 
            symmetric = TRUE) %>% 
    grobify()
  
}
```

```{r}
# Mouse slice dimensions in pixels
mouse_width_px <- dim(mouse_anat_vol)[2]
mouse_height_px <- dim(mouse_anat_vol)[3]

# Human slice dimensions in pixels
human_width_px <- dim(human_anat_vol_cropped)[2]
human_height_px <- dim(human_anat_vol_cropped)[3]

fig3_mouse_ss_width_pt <- 38.83
fig3_mouse_ss_height_pt <- fig3_mouse_ss_width_pt*(mouse_height_px/mouse_width_px)

fig3_human_ss_width_pt <- fig3_mouse_ss_width_pt
fig3_human_ss_height_pt <- fig3_human_ss_width_pt*(human_height_px/human_width_px)

fig3_neuro_ss_padding_pt <- 3.0

# Dimensions of slice series grid
fig3_neuro_ss_widths <- fig3_mouse_ss_width_pt
fig3_neuro_ss_heights <- c(fig3_human_ss_height_pt, fig3_neuro_ss_padding_pt, fig3_mouse_ss_height_pt)

for (i in 1:length(list_human_slices)) {
  
  # Generate slice series for cluster solution    
  ss <- arrangeGrob(list_human_slices[[i]],
                    black_rect_grob,
                    list_mouse_slices[[i]],
                    layout_matrix = cbind(1:3),
                    widths = unit(fig3_neuro_ss_widths, "bigpts"),
                    heights = unit(fig3_neuro_ss_heights, "bigpts"))
  
  # Coloured border for slice series
  # ss_border <- rectGrob(gp = gpar(fill = NA, 
  #                                 col = neuro_palette_nk[j], 
  #                                 lwd = 2.5))
  
  # Export slice series
  
  outfile <- paste(output_plot_prefix, "neuro_ss", "PONDSK_MICe", names(list_human_slices)[[i]], names(list_mouse_slices)[[i]], sep = "_")
  outfile <- paste0(outfile, ".pdf")
  outfile <- file.path(output_dir, outfile)
  export_pdf(x = ss,
             file = outfile,
             width = sum(fig3_neuro_ss_widths),
             height = sum(fig3_neuro_ss_heights),
             units = "bigpts")
  
}
```


## HBN-MICe


```{r}
# Fetch parameter set for HBN-MICe pipeline
params_id <- 861
metadata <- file.path(PROJECTPATH, "data/cross_species/v3/metadata.csv")
params <- fetch_params_metadata(metadata = metadata,
                                id = params_id)

# Jacobians to display
jacobians <- "relative"

# Threshold method
threshold <- params %>% 
  filter(id == params_id) %>% 
  pull(threshold)

# Threshold value
threshold_value <- params %>% 
  filter(id == params_id) %>% 
  pull(threshold_value)

# Threshold symmetric option
threshold_symmetric <- params %>% 
  filter(id == params_id) %>% 
  pull(threshold_symmetric)

# Mouse parameter set ID
mouse_params_id <- params %>% 
  filter(id == params_id) %>% 
  pull(input_2_id)

# Mouse pipeline directory
mouse_pipeline_dir <- file.path(PROJECTPATH, "data/mouse/derivatives/")
mouse_pipeline_dir <- file.path(mouse_pipeline_dir, version)
mouse_pipeline_dir <- file.path(mouse_pipeline_dir, mouse_params_id)

# Mouse centroid map directory
mouse_centroid_dir <- file.path(mouse_pipeline_dir, "centroids")
mouse_centroid_dir <- file.path(mouse_centroid_dir, "resolution_0.05")
mouse_centroid_dir <- file.path(mouse_centroid_dir, jacobians)

# Human parameter set ID
human_params_id <- params %>% 
  filter(id == params_id) %>% 
  pull(input_1_id)

# Human image resolution
human_resolution <- params %>% 
  filter(id == params_id) %>% 
  pull(input_1_resolution)
human_resolution <- sprintf("%.1f", human_resolution)

# Human pipeline directory
human_pipeline_dir <- file.path(PROJECTPATH, "data/human/derivatives/")
human_pipeline_dir <- file.path(human_pipeline_dir, version)
human_pipeline_dir <- file.path(human_pipeline_dir, human_params_id)

# Human centroid map directory
human_centroid_dir <- file.path(human_pipeline_dir, "centroids")
human_centroid_dir <- file.path(human_centroid_dir, paste("resolution", human_resolution, sep = "_"))
human_centroid_dir <- file.path(human_centroid_dir, jacobians)
```


```{r}
df_matches_HBN_MICe
```

```{r fig3-ss-human-import}
# Anatomical plane to display
# Sagittal: 1
# Coronal: 2 
# Transverse: 3
human_slc_dim <- 1

# Human brain slice to display
human_slc <- 82

# Iterate over mouse slices
list_human_slices <- vector(mode = "list", length = nrow(df_matches_HBN_MICe))
names(list_human_slices) <- df_matches_HBN_MICe$img1_cluster_id
for(i in 1:nrow(df_matches_HBN_MICe)) {
  
  
  cluster_id <- df_matches_HBN_MICe[[i, "img1_cluster_id"]]
  
  nk <- str_split(cluster_id, pattern = "-", simplify = TRUE)[1]
  k <- str_split(cluster_id, pattern = "-", simplify = TRUE)[2]
  
  print(paste(nk, k, sep = "-"))
  
  # Import centroid image and threshold
  img <- import_cluster_map(imgdir = human_centroid_dir,
                            mask = human_mask_file,
                            nk = nk, k = k,
                            threshold = threshold,
                            threshold_value = threshold_value,
                            threshold_symmetric = threshold_symmetric)
  
  # Compute overlay thresholds
  overlay_threshold <- numeric(2)
  overlay_threshold[1] <- min(abs(img[img != 0]))
  overlay_threshold[2] <- 0.8*max(abs(img[img != 0]))
  overlay_threshold <- round(overlay_threshold, 2)
  
  # Convert mincSingleDim to mincArray and crop
  img <- mincArray(img)
  img <- img[slices_dim_1, slices_dim_2, slices_dim_3]
  
  # Generate slice series
  list_human_slices[[i]] <- sliceSeries(nrow = 1, ncol = 1, 
                                        dimension = human_slc_dim, 
                                        slices = human_slc) %>% 
    anatomy(human_anat_vol_cropped, low = 40, high = 110) %>% 
    overlay(img, 
            low = overlay_threshold[1], 
            high = overlay_threshold[2], 
            symmetric = TRUE) %>% 
    grobify()
  
}
```

```{r fig3-ss-mouse-import}
# Anatomical plane to display
# Sagittal: 1
# Coronal: 2 
# Transverse: 3
mouse_slc_dim <- 1

# Mouse brain slice to display
mouse_slc <- 92

# Iterate over nk subset
list_mouse_slices <- vector(mode = "list", length = nrow(df_matches_HBN_MICe))
names(list_mouse_slices) <- df_matches_HBN_MICe$img2_cluster_id
for(i in 1:nrow(df_matches_HBN_MICe)) {
  
  cluster_id <- df_matches_HBN_MICe[[i, "img2_cluster_id"]]
  
  nk <- str_split(cluster_id, pattern = "-", simplify = TRUE)[1]
  k <- str_split(cluster_id, pattern = "-", simplify = TRUE)[2]
  
  print(paste(nk, k, sep = "-"))
  
  # Import centroid image and threshold
  img <- import_cluster_map(imgdir = mouse_centroid_dir,
                            mask = mouse_mask_file,
                            nk = nk, k = k,
                            threshold = threshold,
                            threshold_value = threshold_value,
                            threshold_symmetric = threshold_symmetric)
  
  # Compute overlay thresholds
  overlay_threshold <- numeric(2)
  overlay_threshold[1] <- min(abs(img[img != 0]))
  overlay_threshold[2] <- 0.8*max(abs(img[img != 0]))
  overlay_threshold <- round(overlay_threshold, 2)
  
  # Convert mincSingleDim to mincArray
  img <- mincArray(img)
  
  # Generate slice series
  list_mouse_slices[[i]] <- sliceSeries(nrow = 1, ncol = 1, 
                                        dimension = mouse_slc_dim, 
                                        slices = mouse_slc) %>% 
    anatomy(mouse_anat_vol, low = 700, high = 1400) %>% 
    overlay(img, 
            low = overlay_threshold[1], high = overlay_threshold[2], 
            symmetric = TRUE) %>% 
    grobify()
  
}
```

```{r}

# Mouse slice dimensions in pixels
mouse_width_px <- dim(mouse_anat_vol)[2]
mouse_height_px <- dim(mouse_anat_vol)[3]

# Human slice dimensions in pixels
human_width_px <- dim(human_anat_vol_cropped)[2]
human_height_px <- dim(human_anat_vol_cropped)[3]


fig3_mouse_ss_width_pt <- 38.83
fig3_mouse_ss_height_pt <- fig3_mouse_ss_width_pt*(mouse_height_px/mouse_width_px)

fig3_human_ss_width_pt <- fig3_mouse_ss_width_pt
fig3_human_ss_height_pt <- fig3_human_ss_width_pt*(human_height_px/human_width_px)

fig3_neuro_ss_padding_pt <- 3.0

# Dimensions of slice series grid
fig3_neuro_ss_widths <- fig3_mouse_ss_width_pt
fig3_neuro_ss_heights <- c(fig3_human_ss_height_pt, fig3_neuro_ss_padding_pt, fig3_mouse_ss_height_pt)

for (i in 1:length(list_human_slices)) {
  
  # Generate slice series for cluster solution    
  ss <- arrangeGrob(list_human_slices[[i]],
                    black_rect_grob,
                    list_mouse_slices[[i]],
                    layout_matrix = cbind(1:3),
                    widths = unit(fig3_neuro_ss_widths, "bigpts"),
                    heights = unit(fig3_neuro_ss_heights, "bigpts"))
  
  # Coloured border for slice series
  # ss_border <- rectGrob(gp = gpar(fill = NA, 
  #                                 col = neuro_palette_nk[j], 
  #                                 lwd = 2.5))
  
  # Export slice series
  
  outfile <- paste(output_plot_prefix, "neuro_ss", "HBN_MICe", names(list_human_slices)[[i]], names(list_mouse_slices)[[i]], sep = "_")
  outfile <- paste0(outfile, ".pdf")
  outfile <- file.path(output_dir, outfile)
  export_pdf(x = ss,
             file = outfile,
             width = sum(fig3_neuro_ss_widths),
             height = sum(fig3_neuro_ss_heights),
             units = "bigpts")
  
}
```


## PONDSK-HBN


```{r}
# Fetch parameter set
params_id <- 779
metadata <- file.path(PROJECTPATH, "data/cross_species/v3/metadata.csv")
params <- fetch_params_metadata(metadata = metadata,
                                id = params_id)

# Jacobians to display
jacobians <- "relative"

# Threshold method
threshold <- params %>% 
  filter(id == params_id) %>% 
  pull(threshold)

# Threshold value
threshold_value <- params %>% 
  filter(id == params_id) %>% 
  pull(threshold_value)

# Threshold symmetric option
threshold_symmetric <- params %>% 
  filter(id == params_id) %>% 
  pull(threshold_symmetric)

# PONDSK parameter set ID
PONDSK_params_id <- params %>% 
  filter(id == params_id) %>% 
  pull(input_1_id)

# PONDSK image resolution
PONDSK_resolution <- params %>% 
  filter(id == params_id) %>% 
  pull(input_1_resolution)
PONDSK_resolution <- sprintf("%.1f", PONDSK_resolution)

# PONDSK pipeline directory
PONDSK_pipeline_dir <- file.path(PROJECTPATH, "data/human/derivatives/")
PONDSK_pipeline_dir <- file.path(PONDSK_pipeline_dir, version)
PONDSK_pipeline_dir <- file.path(PONDSK_pipeline_dir, PONDSK_params_id)

# PONDSK centroid map directory
PONDSK_centroid_dir <- file.path(PONDSK_pipeline_dir, "centroids")
PONDSK_centroid_dir <- file.path(PONDSK_centroid_dir, paste("resolution", PONDSK_resolution, sep = "_"))
PONDSK_centroid_dir <- file.path(PONDSK_centroid_dir, jacobians)

# HBN parameter set ID
HBN_params_id <- params %>% 
  filter(id == params_id) %>% 
  pull(input_2_id)

# HBN image resolution
HBN_resolution <- params %>% 
  filter(id == params_id) %>% 
  pull(input_2_resolution)
HBN_resolution <- sprintf("%.1f", HBN_resolution)

# HBN pipeline directory
HBN_pipeline_dir <- file.path(PROJECTPATH, "data/human/derivatives/")
HBN_pipeline_dir <- file.path(HBN_pipeline_dir, version)
HBN_pipeline_dir <- file.path(HBN_pipeline_dir, HBN_params_id)

# HBN centroid map directory
HBN_centroid_dir <- file.path(HBN_pipeline_dir, "centroids")
HBN_centroid_dir <- file.path(HBN_centroid_dir, paste("resolution", HBN_resolution, sep = "_"))
HBN_centroid_dir <- file.path(HBN_centroid_dir, jacobians)
```


```{r}
df_matches_PONDSK_HBN
```

```{r fig3-ss-human-import}
# Anatomical plane to display
# Sagittal: 1
# Coronal: 2 
# Transverse: 3
human_slc_dim <- 1

# Human brain slice to display
human_slc <- 82

# Iterate over mouse slices
list_PONDSK_slices <- vector(mode = "list", length = nrow(df_matches_PONDSK_HBN))
names(list_PONDSK_slices) <- df_matches_PONDSK_HBN$img1_cluster_id
for(i in 1:nrow(df_matches_PONDSK_HBN)) {
  
  
  cluster_id <- df_matches_PONDSK_HBN[[i, "img1_cluster_id"]]
  
  nk <- str_split(cluster_id, pattern = "-", simplify = TRUE)[1]
  k <- str_split(cluster_id, pattern = "-", simplify = TRUE)[2]
  
  print(paste(nk, k, sep = "-"))
  
  # Import centroid image and threshold
  img <- import_cluster_map(imgdir = PONDSK_centroid_dir,
                            mask = human_mask_file,
                            nk = nk, k = k,
                            threshold = threshold,
                            threshold_value = threshold_value,
                            threshold_symmetric = threshold_symmetric)
  
  # Compute overlay thresholds
  overlay_threshold <- numeric(2)
  overlay_threshold[1] <- min(abs(img[img != 0]))
  overlay_threshold[2] <- 0.8*max(abs(img[img != 0]))
  overlay_threshold <- round(overlay_threshold, 2)
  
  # Convert mincSingleDim to mincArray and crop
  img <- mincArray(img)
  img <- img[slices_dim_1, slices_dim_2, slices_dim_3]
  
  # Generate slice series
  list_PONDSK_slices[[i]] <- sliceSeries(nrow = 1, ncol = 1, 
                                         dimension = human_slc_dim, 
                                         slices = human_slc) %>% 
    anatomy(human_anat_vol_cropped, low = 40, high = 110) %>% 
    overlay(img, 
            low = overlay_threshold[1], 
            high = overlay_threshold[2], 
            symmetric = TRUE) %>% 
    grobify()
  
}
```

```{r fig3-ss-human-import}
# Anatomical plane to display
# Sagittal: 1
# Coronal: 2 
# Transverse: 3
human_slc_dim <- 1

# Human brain slice to display
human_slc <- 82

# Iterate over mouse slices
list_HBN_slices <- vector(mode = "list", length = nrow(df_matches_PONDSK_HBN))
names(list_HBN_slices) <- df_matches_PONDSK_HBN$img2_cluster_id
for(i in 1:nrow(df_matches_PONDSK_HBN)) {
  
  
  cluster_id <- df_matches_PONDSK_HBN[[i, "img2_cluster_id"]]
  
  nk <- str_split(cluster_id, pattern = "-", simplify = TRUE)[1]
  k <- str_split(cluster_id, pattern = "-", simplify = TRUE)[2]
  
  print(paste(nk, k, sep = "-"))
  
  # Import centroid image and threshold
  img <- import_cluster_map(imgdir = HBN_centroid_dir,
                            mask = human_mask_file,
                            nk = nk, k = k,
                            threshold = threshold,
                            threshold_value = threshold_value,
                            threshold_symmetric = threshold_symmetric)
  
  # Compute overlay thresholds
  overlay_threshold <- numeric(2)
  overlay_threshold[1] <- min(abs(img[img != 0]))
  overlay_threshold[2] <- 0.8*max(abs(img[img != 0]))
  overlay_threshold <- round(overlay_threshold, 2)
  
  # Convert mincSingleDim to mincArray and crop
  img <- mincArray(img)
  img <- img[slices_dim_1, slices_dim_2, slices_dim_3]
  
  # Generate slice series
  list_HBN_slices[[i]] <- sliceSeries(nrow = 1, ncol = 1, 
                                      dimension = human_slc_dim, 
                                      slices = human_slc) %>% 
    anatomy(human_anat_vol_cropped, low = 40, high = 110) %>% 
    overlay(img, 
            low = overlay_threshold[1], 
            high = overlay_threshold[2], 
            symmetric = TRUE) %>% 
    grobify()
  
}
```


```{r}
# Human slice dimensions in pixels
human_width_px <- dim(human_anat_vol_cropped)[2]
human_height_px <- dim(human_anat_vol_cropped)[3]

fig3_human_ss_width_pt <- 38.83
fig3_human_ss_height_pt <- fig3_human_ss_width_pt*(human_height_px/human_width_px)

fig3_neuro_ss_padding_pt <- 3.0

# Dimensions of slice series grid
fig3_neuro_ss_widths <- fig3_human_ss_width_pt
fig3_neuro_ss_heights <- c(fig3_human_ss_height_pt, fig3_neuro_ss_padding_pt, fig3_human_ss_height_pt)

for (i in 1:length(list_PONDSK_slices)) {
  
  # Generate slice series for cluster solution    
  ss <- arrangeGrob(list_PONDSK_slices[[i]],
                    black_rect_grob,
                    list_HBN_slices[[i]],
                    layout_matrix = cbind(1:3),
                    widths = unit(fig3_neuro_ss_widths, "bigpts"),
                    heights = unit(fig3_neuro_ss_heights, "bigpts"))
  
  # Coloured border for slice series
  # ss_border <- rectGrob(gp = gpar(fill = NA, 
  #                                 col = neuro_palette_nk[j], 
  #                                 lwd = 2.5))
  
  # Export slice series
  
  outfile <- paste(output_plot_prefix, "neuro_ss", "PONDSK_HBN", names(list_PONDSK_slices)[[i]], names(list_HBN_slices)[[i]], sep = "_")
  outfile <- paste0(outfile, ".pdf")
  outfile <- file.path(output_dir, outfile)
  export_pdf(x = ss,
             file = outfile,
             width = sum(fig3_neuro_ss_widths),
             height = sum(fig3_neuro_ss_heights),
             units = "bigpts")
  
}
```


