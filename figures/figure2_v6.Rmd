---
title: "Figure 2"
subtitle: "Clustering Autism"
author: "Antoine Beauchamp"
date: "2023-11-27"
output: html_document
---

# Initialization

```{r fig2-knitr-setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r fig2-packages}
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(RMINC))
suppressPackageStartupMessages(library(MRIcrotome))
suppressPackageStartupMessages(library(grid))
suppressPackageStartupMessages(library(gridExtra))
suppressPackageStartupMessages(library(patchwork))
suppressPackageStartupMessages(library(viridis))
suppressPackageStartupMessages(library(viridisLite))
suppressPackageStartupMessages(library(RColorBrewer))
suppressPackageStartupMessages(library(rcartocolor))
suppressPackageStartupMessages(library(pROC))
```

```{r fig2-functions}
source("../src/utils.R")
source("../src/processing.R")
source("../src/analysis.R")
```

```{r fig2-pipeline-params}
# Output directory
output_dir <- "figure2/"
if (!dir.exists(output_dir)) {
  dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)
}

# Plot file prefix
output_plot_prefix <- "figure2"

# Similarity pipeline
version <- "v2"
pipeline_dir <- "../data/cross_species/"
pipeline_dir <- file.path(pipeline_dir, version)

# Human parameters
human_resolution <- 0.8
human_es_method <- "normative-growth"
human_es_df <- 3
human_cluster_map_method <- "mean"

# Mouse parameters
mouse_resolution <- 0.2
mouse_cluster_map_method <- human_cluster_map_method

# Similarity parameters
metric <- "correlation"

# Fetch parameter set
metadata <- file.path(pipeline_dir, "metadata.csv")
params <- fetch_params_metadata(metadata = metadata,
                                human_resolution = human_resolution,
                                human_es_method = human_es_method,
                                human_es_df = human_es_df,
                                human_cluster_map_method = human_cluster_map_method,
                                metric = metric)
params
```

```{r fig2-paths}
# Parameter set ID
params_id <- 405

# Update pipeline directory with parameter set ID
pipeline_dir <- file.path(pipeline_dir, params_id)

# Jacobians
jacobians <- c("absolute", "relative")

# Human parameter set ID
human_params_id <- params %>% 
  filter(id == params_id) %>% 
  pull(human_id)

# Mouse parameter set ID
mouse_params_id <- params %>% 
  filter(id == params_id) %>% 
  pull(mouse_id)

# Max number of clusters
nk_max <- params %>% 
  filter(id == params_id) %>% 
  pull(human_cluster_nk_max)

# Human pipeline directory
human_pipeline_dir <- "../data/human/derivatives/"
human_pipeline_dir <- file.path(human_pipeline_dir, version, human_params_id)

# Human cluster map directories
human_cluster_map_dirs <- file.path(human_pipeline_dir, "cluster_maps")
human_cluster_map_dirs <- file.path(human_cluster_map_dirs, str_c("resolution_", human_resolution))
human_cluster_map_dirs <- file.path(human_cluster_map_dirs, jacobians)
names(human_cluster_map_dirs) <- jacobians

# Mouse pipeline directory
mouse_pipeline_dir <- "../data/mouse/derivatives/"
mouse_pipeline_dir <- file.path(mouse_pipeline_dir, "v2", mouse_params_id)

# Mouse cluster map directories
mouse_cluster_map_dirs <- file.path(mouse_pipeline_dir, "cluster_maps")
mouse_cluster_map_dirs <- file.path(mouse_cluster_map_dirs, str_c("resolution_", mouse_resolution))
mouse_cluster_map_dirs <- file.path(mouse_cluster_map_dirs, jacobians)
names(mouse_cluster_map_dirs) <- jacobians

# Mouse cluster map directories at 50um
mouse_cluster_map_dirs_50um <- file.path(mouse_pipeline_dir, "cluster_maps")
mouse_cluster_map_dirs_50um <- file.path(mouse_cluster_map_dirs_50um, "resolution_0.05")
mouse_cluster_map_dirs_50um <- file.path(mouse_cluster_map_dirs_50um, jacobians)
names(mouse_cluster_map_dirs_50um) <- jacobians
```

```{r fig2-graphical-params}
# Number of bigpts in an inch
pt_per_in <- 72

# Font family
font_family <- "Helvetica"

# Nature suggested font size: 5-7 pt
font_size <- 6

# Empty rectangle grob
empty_rect_grob <- rectGrob(gp = gpar(fill = NA))

# Black rectangle grob
black_rect_grob <- rectGrob(gp = gpar(fill = "black"))

# Rectangle with number in it
rect_w_num <- function(n) {
  out <- gTree(children = gList(empty_rect_grob,
                                textGrob(label = n)))
  return(out)
}

# Maximal figure dimensions in bigpts
fig2_width_pt <- 510
fig2_height_pt <- 481
```


# Panel: Neuroanatomy slice series

```{r fig2-ss-files}
# Mouse anatomy
mouse_anat_file <- "../data/mouse/atlas/DSURQE_CCFv3_average_50um.mnc"
mouse_anat <- mincGetVolume(mouse_anat_file)
mouse_anat_vol <- mincArray(mouse_anat)

# Human anatomy
human_anat_file <- "../data/human/registration/v2/reference_files/model_0.8mm.mnc"
human_anat <- mincGetVolume(human_anat_file)
human_anat_vol <- mincArray(human_anat)

# Cropped human images along sagittal and transverse planes
human_slices_dim_1 <- 25:200
human_slices_dim_3 <- 25:220
human_anat_vol_cropped <- human_anat_vol[human_slices_dim_1,,human_slices_dim_3]

# Human mask
human_mask_file <- "../data/human/registration/v2/reference_files/mask_0.8mm.mnc"
human_mask <- mincGetVolume(human_mask_file)

# Mouse mask
mouse_mask_file <- "../data/mouse/atlas/coronal_50um_coverage_bin0.8.mnc"
mouse_mask <- mincGetVolume(mouse_mask_file)

# Image threshold method
threshold <- params %>% 
  filter(id == params_id) %>% 
  pull(threshold)

# Image threshold value
threshold_value <- params %>% 
  filter(id == params_id) %>% 
  pull(threshold_value)

# Image threshold symmetric option
threshold_symmetric <- params %>% 
  filter(id == params_id) %>% 
  pull(threshold_symmetric)

# Cluster solutions to visualize
nk_mouse <- 4
nk_human <- 2
```

```{r fig2-ss-mouse-resample}
# Mouse images need to be resampled to 50um
run <- FALSE
if (run) {
  for (j in jacobians) {
    
    indir <- mouse_cluster_map_dirs[[j]]
    outdir <- mouse_cluster_map_dirs_50um[[j]]
    
    for (k in 1:nk_mouse) {
      
      infile <- paste0("cluster_map_nk_", nk_mouse, "_k_", k, ".mnc")
      outfile <- infile
      
      infile <- file.path(indir, infile)
      outfile <- file.path(outdir, outfile)
      
      cmd_mincresample <- paste("mincresample", "-clobber",
                                "-like", mouse_anat_file,
                                infile, outfile)
      system(command = cmd_mincresample)
      
    }
  }
}
```

```{r fig2-ss-mouse-import}
# Iterate over jacobians  
list_mouse_centroids <- vector(mode = "list", length = length(jacobians))
names(list_mouse_centroids) <- jacobians
for (j in jacobians) {
  
  # Iterate over clusters in nk solution
  list_mouse_centroids[[j]] <- vector(mode = "list", length = nk_mouse)
  names(list_mouse_centroids[[j]]) <- paste(nk_mouse, 1:nk_mouse, sep = "-")
  for (k in 1:nk_mouse) {
    
    # Import centroid image for specific cluster using threshold
    img_mouse <- import_cluster_map(imgdir = mouse_cluster_map_dirs_50um[[j]],
                                    mask = mouse_mask_file,
                                    nk = nk_mouse, k = k,
                                    threshold = threshold,
                                    threshold_value = threshold_value,
                                    threshold_symmetric = threshold_symmetric)
    
    list_mouse_centroids[[j]][[k]] <- mincArray(img_mouse)
    
  }
}
```

```{r fig2-ss-human-import}
# Iterate over jacobians  
list_human_centroids <- vector(mode = "list", length = length(jacobians))
names(list_human_centroids) <- jacobians
for (j in jacobians) {
  
  # Iterate over clusters in nk solution
  list_human_centroids[[j]] <- vector(mode = "list", length = nk_human)
  names(list_human_centroids[[j]]) <- paste(nk_human, 1:nk_human, sep = "-")
  for (k in 1:nk_human) {
    
    # Import centroid image for specific cluster using threshold
    img_human <- import_cluster_map(imgdir = human_cluster_map_dirs[[j]],
                                    mask = human_mask_file,
                                    nk = nk_human, k = k,
                                    threshold = threshold,
                                    threshold_value = threshold_value,
                                    threshold_symmetric = threshold_symmetric)
    
    # Crop image to remove black space
    img_human <- mincArray(img_human)
    img_human <- img_human[human_slices_dim_1,,human_slices_dim_3]
    list_human_centroids[[j]][[k]] <- img_human
    
  }
}
```

```{r fig2-ss-mouse-thresholds}
# Data frame to store mouse image thresholds
df_mouse_thresholds <- tibble(nk = rep(nk_mouse, nk_mouse),
                              k = 1:nk_mouse) %>% 
  unite(col = "cluster_id", nk, k, sep = "-", remove = FALSE) %>% 
  mutate(threshold_min = 0, 
         threshold_max = 0)

# Get min/max thresholds for each mouse image
for (i in 1:nrow(df_mouse_thresholds)) {
  mouse_img_abs <- abs(list_mouse_centroids[["relative"]][[i]])
  mouse_img_abs <- mouse_img_abs[mouse_img_abs > 0]
  df_mouse_thresholds[[i, "threshold_max"]] <- max(mouse_img_abs)
  df_mouse_thresholds[[i, "threshold_min"]] <- min(mouse_img_abs)
}
```

```{r fig2-ss-human-thresholds}
# Data frame to store human image thresholds
df_human_thresholds <- tibble(nk = rep(nk_human, nk_human),
                              k = 1:nk_human) %>% 
  unite(col = "cluster_id", nk, k, sep = "-", remove = FALSE) %>% 
  mutate(threshold_min = 0, 
         threshold_max = 0)

# Get min/max thresholds for each human image
for (i in 1:nrow(df_human_thresholds)) {
  human_img_abs <- abs(list_human_centroids[["relative"]][[i]])
  human_img_abs <- human_img_abs[human_img_abs > 0]
  df_human_thresholds[[i, "threshold_max"]] <- max(human_img_abs)
  df_human_thresholds[[i, "threshold_min"]] <- min(human_img_abs)
}
```

```{r fig2-ss-thresholds}
# Compute global min/max mouse thresholds
mouse_min <- min(df_mouse_thresholds$threshold_min)
mouse_max <- max(df_mouse_thresholds$threshold_max)

# Compute global min/max human thresholds
human_min <- min(df_human_thresholds$threshold_min)
human_max <- max(df_human_thresholds$threshold_max)

# Compute global thresholds
global_min <- min(c(mouse_min, human_min))
global_max <- max(c(mouse_max, human_max))

# Print thresholds
print(c(global_min, global_max))
```

```{r fig2-ss-params}
# Number of slices per ss
ss_nslices <- 5

# Human slices
# human_slices <- c(61, 105, 127, 152, 214)
human_slices <- floor(seq(60, 220, length.out = ss_nslices))

# Mouse slices
# mouse_slices <- c(18, 41, 85, 174, 196)
mouse_slices <- floor(seq(20, 200, length.out = ss_nslices))

# Human anatomy thresholds
human_anat_low <- 3
human_anat_high <- 10

# Mouse anatomy thresholds
mouse_anat_low <- 800
mouse_anat_high <- 2000

# Overlay thresholds from previous code chunk
overlay_low <- 0.19
overlay_high <- 1.0
```

```{r fig2-ss-human-grob}
# For each human cluster, create a set of coronal slices
fig2_ss_human_slice_grobs <- vector(mode = "list", length = nk_human)
names(fig2_ss_human_slice_grobs) <- names(list_human_centroids[["relative"]])
for (k in 1:nk_human) {
  fig2_ss_human_slice_grobs[[k]] <- vector(mode = "list", length = length(human_slices))
  for (s in 1:length(human_slices)) {
    fig2_ss_human_slice_grobs[[k]][[s]] <- sliceSeries(nrow = 1, ncol = 1, slice = human_slices[s]) %>% 
      anatomy(human_anat_vol_cropped, low = human_anat_low, high = human_anat_high) %>% 
      overlay(list_human_centroids[["relative"]][[k]],
              low = overlay_low, high = overlay_high,
              symmetric = TRUE) %>% 
      grobify()
  }
}

# Number of rows and columns in slice series
ss_nrow <- ss_nslices
ss_ncol <- nk_human

# Collapse human slices grobs into one list
fig2_ss_human_grobs_list <- reduce(.x = fig2_ss_human_slice_grobs, .f = c)

# Human ss layout
fig2_ss_human_layout <- matrix(1:length(fig2_ss_human_grobs_list),
                               nrow = ss_nrow, ncol = ss_ncol,
                               byrow = FALSE)

# Human ss dimensions
fig2_ss_human_widths <- unit(rep(1, ss_ncol)/ss_ncol, "npc")
fig2_ss_human_heights <- unit(rep(1, ss_nrow)/ss_nrow, "npc")

# Human ss grob
fig2_ss_human_grob <- arrangeGrob(grobs = fig2_ss_human_grobs_list,
                                  layout_matrix = fig2_ss_human_layout,
                                  widths = fig2_ss_human_widths,
                                  heights = fig2_ss_human_heights)

# Human ss dimensions in bigpts
fig2_ss_human_height_pt <- 195
fig2_ss_human_width_pt <- fig2_ss_human_height_pt*(nk_human/ss_nslices)

# Export human ss plot
outfile <- "figure2_ss_human.pdf"
outfile <- file.path(output_dir, outfile)
export_pdf(x = fig2_ss_human_grob,
           width = fig2_ss_human_width_pt,
           height = fig2_ss_human_height_pt,
           units = "bigpts",
           file = outfile)
```

```{r fig2-ss-mouse-grob}
# For each mouse cluster, create a set of coronal slices
fig2_ss_mouse_slice_grobs <- vector(mode = "list", length = nk_mouse)
names(fig2_ss_mouse_slice_grobs) <- names(list_mouse_centroids[["relative"]])
for (k in 1:nk_mouse) {
  fig2_ss_mouse_slice_grobs[[k]] <- vector(mode = "list", length = length(mouse_slices))
  for (s in 1:length(mouse_slices)) {
    fig2_ss_mouse_slice_grobs[[k]][[s]] <- sliceSeries(nrow = 1, ncol = 1, slice = mouse_slices[s]) %>% 
      anatomy(mouse_anat_vol, low = mouse_anat_low, high = mouse_anat_high) %>% 
      overlay(list_mouse_centroids[["relative"]][[k]],
              low = overlay_low, high = overlay_high,
              symmetric = TRUE) %>% 
      grobify()
  }
}

# Number of rows and columns in slice series
ss_nrow <- ss_nslices
ss_ncol <- nk_mouse

# Collapse mouse slices grobs into one list
fig2_ss_mouse_grobs_list <- reduce(.x = fig2_ss_mouse_slice_grobs, .f = c)

# Mouse ss layout
fig2_ss_mouse_layout <- matrix(1:length(fig2_ss_mouse_grobs_list),
                               nrow = ss_nrow, ncol = ss_ncol,
                               byrow = FALSE)

# Mouse ss dimensions
fig2_ss_mouse_widths <- unit(rep(1, ss_ncol)/ss_ncol, "npc")
fig2_ss_mouse_heights <- unit(rep(1, ss_nrow)/ss_nrow, "npc")

# Mouse ss grob
fig2_ss_mouse_grob <- arrangeGrob(grobs = fig2_ss_mouse_grobs_list,
                                  layout_matrix = fig2_ss_mouse_layout,
                                  widths = fig2_ss_mouse_widths,
                                  heights = fig2_ss_mouse_heights)

# Mouse ss dimensions in bigpts
fig2_ss_mouse_height_pt <- fig2_ss_human_height_pt
fig2_ss_mouse_width_pt <- fig2_ss_mouse_height_pt*(nk_mouse/ss_nslices)

# Export mouse ss plot
outfile <- "figure2_ss_mouse.pdf"
outfile <- file.path(output_dir, outfile)
export_pdf(x = fig2_ss_mouse_grob,
           width = fig2_ss_mouse_width_pt,
           height = fig2_ss_mouse_height_pt,
           units = "bigpts",
           file = outfile)
```

```{r fig2-ss-legend-grob}
# Global properties for legend
fig2_ss_legend_scale_y <- 0.5
fig2_ss_legend_scale_height <- 0.9
fig2_ss_legend_labels_y <- fig2_ss_legend_scale_y + 0.5*fig2_ss_legend_scale_height*c(-1, 1)
fig2_ss_legend_labels_fontsize <- font_size
fig2_ss_legend_labels_colour <- "white"

# Positive scale raster grob
fig2_ss_legend_pos_scale_palette <- rev(MRIcrotome:::defaultCol())
fig2_ss_legend_pos_scale_raster_grob <- rasterGrob(image = cbind(fig2_ss_legend_pos_scale_palette),
                                                   y = fig2_ss_legend_scale_y,
                                                   width = 1, height = fig2_ss_legend_scale_height)
fig2_ss_legend_pos_scale_raster_grob <- gTree(children = gList(black_rect_grob, 
                                                               fig2_ss_legend_pos_scale_raster_grob))

# Positive scale labels
fig2_ss_legend_pos_labels <- c(overlay_low, overlay_high)
fig2_ss_legend_pos_labels <- sprintf("%.2f", fig2_ss_legend_pos_labels)
fig2_ss_legend_pos_labels <- paste0("  ", fig2_ss_legend_pos_labels)
fig2_ss_legend_pos_labels_grob <- textGrob(label = fig2_ss_legend_pos_labels,
                                           y = fig2_ss_legend_labels_y,
                                           x = 0.1,
                                           just = c("left", "center"),
                                           gp = gpar(fontsize = fig2_ss_legend_labels_fontsize,
                                                     fontfamily = font_family,
                                                     col = fig2_ss_legend_labels_colour))
fig2_ss_legend_pos_labels_grob <- gTree(children = gList(black_rect_grob, 
                                                         fig2_ss_legend_pos_labels_grob))

# Negative scale raster grob
fig2_ss_legend_neg_scale_palette <- MRIcrotome:::defaultRCol()
fig2_ss_legend_neg_scale_raster_grob <- rasterGrob(image = cbind(fig2_ss_legend_neg_scale_palette),
                                                   y = fig2_ss_legend_scale_y,
                                                   width = 1, height = fig2_ss_legend_scale_height)
fig2_ss_legend_neg_scale_raster_grob <- gTree(children = gList(black_rect_grob, 
                                                               fig2_ss_legend_neg_scale_raster_grob))

# Negative scale labels
fig2_ss_legend_neg_labels <- -1*rev(c(overlay_low, overlay_high))
fig2_ss_legend_neg_labels <- sprintf("%.2f", fig2_ss_legend_neg_labels)
fig2_ss_legend_neg_labels_grob <- textGrob(label = fig2_ss_legend_neg_labels,
                                           y = fig2_ss_legend_labels_y,
                                           x = 0.1,
                                           just = c("left", "center"),
                                           gp = gpar(fontsize = fig2_ss_legend_labels_fontsize,
                                                     fontfamily = font_family,
                                                     col = fig2_ss_legend_labels_colour))
fig2_ss_legend_neg_labels_grob <- gTree(children = gList(black_rect_grob, 
                                                         fig2_ss_legend_neg_labels_grob))

# Legend title
fig2_ss_legend_title_grob <- textGrob(label = "Effect size", rot = 90,
                                      x = 0.2, y = 0.5,
                                      just = c("center", "top"),
                                      gp = gpar(fontsize = fig2_ss_legend_labels_fontsize,
                                                fontfamily = font_family,
                                                col = fig2_ss_legend_labels_colour))
fig2_ss_legend_title_grob <- gTree(children = gList(black_rect_grob,
                                                    fig2_ss_legend_title_grob))

# Legend grob
fig2_ss_legend_grob <- arrangeGrob(fig2_ss_legend_pos_scale_raster_grob,
                                   fig2_ss_legend_pos_labels_grob,
                                   fig2_ss_legend_title_grob,
                                   black_rect_grob,
                                   fig2_ss_legend_neg_scale_raster_grob,
                                   fig2_ss_legend_neg_labels_grob,
                                   layout_matrix = rbind(c(01, 02, 03),
                                                         c(04, 04, 03),
                                                         c(05, 06, 03)),
                                   widths = unit(c(0.35, 0.35, 0.3), "npc"),
                                   heights = unit(c(0.49, 0.02, 0.49), "npc"))

# Legend dimensions in bigpts
fig2_ss_legend_height_pt <- fig2_ss_mouse_height_pt
fig2_ss_legend_width_pt <- 50

# Export slice series legend
outfile <- "figure2_ss_legend.pdf"
outfile <- file.path(output_dir, outfile)
export_pdf(x = fig2_ss_legend_grob,
           width = fig2_ss_legend_width_pt,
           height = fig2_ss_legend_height_pt,
           units = "bigpts",
           file = outfile)
```

```{r fig2-ss-grob}
# Layout for figure 2 slice series
fig2_ss_layout <- rbind(c(01, 01, 01, 01, 01, 01),
                        c(02, 03, 04, 05, 06, 07),
                        c(08, 08, 08, 08, 08, 08))

# Dimensions for figure 2 slice series
fig2_ss_widths <- c(7, fig2_ss_human_width_pt, 19, fig2_ss_mouse_width_pt, 12, fig2_ss_legend_width_pt)
fig2_ss_heights <- c(22, fig2_ss_human_height_pt, 23)

# Figure 2 slice series grob
fig2_ss_grob <- arrangeGrob(black_rect_grob,
                            black_rect_grob,
                            fig2_ss_human_grob,
                            black_rect_grob,
                            fig2_ss_mouse_grob,
                            black_rect_grob,
                            fig2_ss_legend_grob,
                            black_rect_grob,
                            layout_matrix = fig2_ss_layout,
                            widths = unit(fig2_ss_widths, "bigpts"),
                            heights = unit(fig2_ss_heights, "bigpts"))

# Figure 2 slice series dimensions
fig2_ss_width_pt <- sum(fig2_ss_widths)
fig2_ss_height_pt <- sum(fig2_ss_heights)

# Export plot
outfile <- paste(output_plot_prefix, "ss", sep = "_")
outfile <- paste0(outfile, ".pdf")
outfile <- file.path(output_dir, outfile)
export_pdf(x = fig2_ss_grob,
           width = fig2_ss_width_pt,
           height = fig2_ss_height_pt,
           units = "bigpts",
           file = outfile)
```


# Panel: Mouse-human cluster similarity heatmap

```{r fig2-sim-import}
# Path to mouse-human similarity directory
similarity_dir <- file.path(pipeline_dir, "similarity")

# Iterate over jacobians
list_similarity <- vector(mode = "list", length = length(jacobians))
names(list_similarity) <- jacobians
for (j in jacobians) {
  
  # Build the path to the similarity file
  similarity_file <- paste0("similarity_", j, ".csv")
  similarity_file <- file.path(similarity_dir, similarity_file)
  
  # Import the similarity data and extract cluster information
  list_similarity[[j]] <- read_csv(similarity_file, show_col_types = FALSE) %>% 
    mutate(human_nk = human_img %>% 
             basename() %>% 
             str_extract("_nk_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric(),
           human_k = human_img %>% 
             basename() %>% 
             str_extract("_k_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric(),
           mouse_nk = mouse_img %>% 
             basename() %>% 
             str_extract("_nk_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric(),
           mouse_k = mouse_img %>% 
             basename() %>% 
             str_extract("_k_[0-9]+") %>% 
             str_extract("[0-9]+") %>% 
             as.numeric()) %>% 
    unite(col = "human_cluster_id", human_nk, human_k, 
          sep = "-", remove = FALSE) %>% 
    unite(col = "mouse_cluster_id", mouse_nk, mouse_k, 
          sep = "-", remove = FALSE)
  
}

# Filter similarity data for desired cluster numbers
list_similarity_nk <- vector(mode = "list", length = length(jacobians))
names(list_similarity_nk) <- jacobians
for (j in jacobians) {
  list_similarity_nk[[j]] <- list_similarity[[j]] %>% 
    filter(human_nk == nk_human,
           mouse_nk == nk_mouse) %>% 
    mutate(jacobians = j)
}

# Combine absolute and relative jacobian similarities
df_similarity_nk <- list_similarity_nk %>% 
  reduce(.f = bind_rows) %>% 
  group_by(human_cluster_id, mouse_cluster_id) %>% 
  summarise(similarity = mean(similarity),
            .groups = "drop")
```

```{r fig2-sim-perm-import}
# Path to permutations directory
# permutation_dir <- file.path(pipeline_dir, "permutations", "similarity")
permutation_dir <- file.path(pipeline_dir, "permutations", "similarity_H2M4")

# Permutation file names
permutation_files <- list.files(permutation_dir)

# Number of permutations
np <- 99

# Iterate over jacobians
list_permutations <- vector(mode = "list", length = length(jacobians))
names(list_permutations) <- jacobians
for (j in jacobians) {
  
  # For each jacobian type, iterate over permutations
  list_permutations[[j]] <- vector(mode = "list", length = np)
  for (p in 1:np) {
    
    # Permutation data to import
    permutation_file <- permutation_files %>% 
      str_subset(j) %>% 
      str_subset(str_c("_", p, "_"))
    permutation_file <- file.path(permutation_dir, permutation_file)
    
    # Import permutation data
    list_permutations[[j]][[p]] <- read_csv(permutation_file, 
                                            show_col_types = FALSE) %>% 
      mutate(human_nk = human_img %>% 
               basename() %>% 
               str_extract("_nk_[0-9]+") %>% 
               str_extract("[0-9]+") %>% 
               as.numeric(),
             human_k = human_img %>% 
               basename() %>% 
               str_extract("_k_[0-9]+") %>% 
               str_extract("[0-9]+") %>% 
               as.numeric(),
             mouse_nk = mouse_img %>% 
               basename() %>% 
               str_extract("_nk_[0-9]+") %>% 
               str_extract("[0-9]+") %>% 
               as.numeric(),
             mouse_k = mouse_img %>% 
               basename() %>% 
               str_extract("_k_[0-9]+") %>% 
               str_extract("[0-9]+") %>% 
               as.numeric()) %>% 
      unite(col = "human_cluster_id", human_nk, human_k, 
            sep = "-", remove = FALSE) %>% 
      unite(col = "mouse_cluster_id", mouse_nk, mouse_k, 
            sep = "-", remove = FALSE) %>% 
      mutate(jacobians = j,
             permutation = p)
    
  }
  
  # Combine permutations into one data frame
  list_permutations[[j]] <- reduce(.x = list_permutations[[j]],
                                   .f = bind_rows)
  
}

# Filter permutations data for desired cluster numbers
list_permutations_nk <- vector(mode = "list", length = length(list_permutations))
names(list_permutations_nk) <- names(list_permutations)
for (j in jacobians) {
  list_permutations_nk[[j]] <- list_permutations[[j]] %>% 
    filter(human_nk %in% nk_human,
           mouse_nk %in% nk_mouse) 
}

# Combine absolute and relative jacobian similarity into one
df_permutations_nk <- list_permutations_nk %>% 
  reduce(.f = bind_rows) %>% 
  group_by(permutation, human_nk, mouse_nk, human_cluster_id, mouse_cluster_id) %>% 
  summarise(similarity = mean(similarity), .groups = "drop")
```

```{r fig2-sim-pvals}
# Compute p-values for cluster correlations
df_similarity_nk[["pval"]] <- 0
for (i in 1:nrow(df_similarity_nk)) {
  df_similarity_nk[[i, "pval"]] <- sum(df_permutations_nk[["similarity"]] >= df_similarity_nk[[i, "similarity"]])/nrow(df_permutations_nk)
}

# Compute q-values and -log10 transforms
df_similarity_nk <- df_similarity_nk %>% 
  mutate(qval = p.adjust(pval, method = "fdr"),
         pval_log = -log10(pval),
         qval_log = -log10(qval),
         significant = ifelse(pval < 0.05, TRUE, FALSE),
         pval_lab = ifelse(significant, "*", ""))
```

```{r fig2-sim-heatmap-plot}
# Max and min similarity values
similarity_max <- max(df_similarity_nk[["similarity"]])
similarity_min <- min(df_similarity_nk[["similarity"]])

# Length of the heatmap palette
heatmap_palette_length <- 255

# Numerical values for the heatmap scale
heatmap_scale_values <- seq(similarity_min, similarity_max, length.out = heatmap_palette_length)
heatmap_scale_values <- (heatmap_scale_values - similarity_min)/(similarity_max - similarity_min)

# Colours for the heatmap palette 
heatmap_scale_colours <- magma(n = heatmap_palette_length, begin = 0.3)

# Heatmap palette vector
heatmap_scale_palette <- colorRampPalette(heatmap_scale_colours)(heatmap_palette_length)

# Clamp log p-values when infinite
df_similarity_nk <- df_similarity_nk %>% 
  mutate(pval_log = ifelse(is.infinite(pval_log), 3, pval_log))

# Heatmap plot
fig2_sim_heatmap <- ggplot(df_similarity_nk, 
                           aes(x = mouse_cluster_id, 
                               y = fct_rev(human_cluster_id), 
                               fill = similarity)) + 
  geom_tile(col = "grey50") + 
  geom_text(mapping = aes(label = pval_lab),
            size = 6, 
            hjust = "center", 
            vjust = "center",
            nudge_y = -0.12) + 
  labs(x = "Mouse clusters",
       y = "Human clusters",
       fill = "Correlation") + 
  scale_fill_gradientn(colors = heatmap_scale_palette,
                       values = heatmap_scale_values,
                       breaks = seq(0, 1, by = 0.1),
                       guide = guide_colourbar(title.position = "top",
                                               barheight = unit(60, "bigpts"),
                                               barwidth = unit(15, "bigpts"))) +
  scale_x_discrete(expand = expansion(mult = 0), position = "top") + 
  scale_y_discrete(expand = expansion(mult = 0)) + 
  theme_bw() +
  theme(plot.margin = margin(t = 0, b = 0, l = 5, unit = "bigpts"),
        legend.position = c(1, 0),
        legend.justification = c("left", "bottom"),)
```


# Panel: Human cluster demographics

```{r fig2-dx-import}
# Human registration directory
human_registration_dir <- "../data/human/registration/"
human_registration_dir <- file.path(human_registration_dir, version)

# Import human demographics data
demographics <- file.path(human_registration_dir, "subject_info", "demographics.csv")
demographics <- read_csv(demographics, show_col_types = FALSE)

# Filter for participants 
demographics <- demographics %>%
  filter(!is.na(DX),
         !is.na(Age),
         !is.na(Sex),
         !is.na(Site),
         !is.na(Scanner))

# Resolution used for clustering
human_cluster_resolution <- params %>% 
  filter(id == params_id) %>% 
  pull(human_cluster_resolution)
human_cluster_resolution <- sprintf("%.1f", human_cluster_resolution)

# Human clustering directory
human_cluster_dir <- file.path(human_pipeline_dir, "clusters")
human_cluster_dir <- file.path(human_cluster_dir, paste("resolution", human_cluster_resolution, sep = "_"))

# Import human clusters
human_clusters <- file.path(human_cluster_dir, "clusters.csv")
human_clusters <- read_csv(human_clusters, show_col_types = FALSE)

# Join demographics to clusters
human_cluster_demo <- human_clusters %>% 
  left_join(demographics, by = c("ID" = "file"))

# Redefine diagnostic categories
df_diagnoses <- tibble(DX = c("ASD", "OCD", "ADHD", "Sub-threshold OCD",
                              "Anxiety", "Sub-threshold ADHD",
                              "Intellectual Disability only", 
                              "Tourette Syndrome", "Other", "Fragile X"),
                       DX_new = c("ASD", "OCD", "ADHD", "OCD", "Other", 
                                  "ADHD", "Other", "Other", "Other", "Other"))

# Join new diagnostic categories
human_cluster_demo <- human_cluster_demo %>% 
  left_join(df_diagnoses, by = "DX")
```

```{r fig2-dx-freq}
# Diagnostic category levels
dx_lvls <- c("ASD", "ADHD", "OCD", "Other")

# Full grid of cluster and DX
dx_grid <- expand_grid(DX_new = df_diagnoses$DX_new,
                       k = 1:nk_human)

# Select diagnoses for desired cluster
df_dx_nk <- human_cluster_demo %>% 
  select(k = contains(paste0("nk", nk_human)),
         DX_new)

# Compute diagnostic proportions per cluster
df_dx_nk_freq <- df_dx_nk %>% 
  group_by(k) %>% 
  mutate(n_per_k = n()) %>% 
  group_by(k, DX_new) %>% 
  mutate(n_per_k_per_dx = n(),
         prop_per_k_per_dx = n_per_k_per_dx/n_per_k) %>% 
  ungroup() %>% 
  distinct() %>% 
  right_join(dx_grid, by = c("k", "DX_new")) %>% 
  mutate(prop_per_k_per_dx = ifelse(is.na(prop_per_k_per_dx), 0, prop_per_k_per_dx),
         k = factor(k),
         DX_new = factor(DX_new, levels = dx_lvls),
         cluster_id = paste(nk_human, k, sep = "-"),
         cluster_id = factor(cluster_id))
```

```{r fig2-dx-plot}
# Diagnostic plot palette
dx_palette <- brewer.pal(n = length(dx_lvls), name = "Dark2")

# Generate plot
fig2_dx <- ggplot(df_dx_nk_freq,
                  aes(x = cluster_id, y = prop_per_k_per_dx,
                      fill = DX_new, col = DX_new, alpha = DX_new)) + 
  geom_col(position = "dodge", alpha = 0.6) +
  scale_y_continuous(breaks = seq(0, 1, by = 0.1)) + 
  scale_colour_manual(values = dx_palette,
                      guide = guide_legend(title.position = "top",
                                           hjust = 0)) +
  scale_fill_manual(values = dx_palette,
                    guide = guide_legend(title.position = "top",
                                         hjust = 0)) +
  labs(x = "Human clusters",
       y = "Proportion per cluster",
       fill = "Diagnosis",
       col = "Diagnosis") + 
  theme_bw() +
  theme(legend.key.size = unit(15, "bigpts"),
        legend.position = c(1, 0.5),
        legend.justification = c("left", "center"), 
        plot.margin = margin(t = 10, l = 5, r = 40, unit = "bigpts"))
```


# Panel: Mouse molecular pathways polar plot

```{r fig2-pathways-mouse-import}
# Enrichment database versions
# stringdb_version <- "11.5"
stringdb_version <- "12.0"
# bader_version <- "2020"
bader_version <- "2023"
stringdb_score <- 950

# Base directory for pathway data files
mouse_pathways_dir <- "../data/mouse/enrichment/"
mouse_pathways_dir <- file.path(mouse_pathways_dir, 
                                paste("StringDB", stringdb_version, 
                                      "Bader", bader_version, 
                                      sep = "_"))
mouse_pathways_dir <- file.path(mouse_pathways_dir, "NeighbourhoodEnrichment")
mouse_pathways_dir <- file.path(mouse_pathways_dir, stringdb_score)

if (length(list.files(mouse_pathways_dir)) == 0) {
  stop("No files in specified directory")
}

# Prefix for pathway data files
mouse_pathways_file_prefix <- "NewBader_enrichment_clusterneighbourhood_vs_brain_all"

# Pathway IDs for a prior pathway set
if (bader_version == "2020") {
  pathway_ids <- c("ADHERENS JUNCTIONS INTERACTIONS%REACTOME%R-HSA-418990.2",
                   "AXON GUIDANCE%REACTOME DATABASE ID RELEASE 71%422475",
                   "CA2+ PATHWAY%REACTOME DATABASE ID RELEASE 71%4086398",
                   "CHROMATIN ORGANIZATION%REACTOME DATABASE ID RELEASE 71%4839726",
                   "GAP JUNCTION TRAFFICKING AND REGULATION%REACTOME%R-HSA-157858.1",
                   "GENE EXPRESSION (TRANSCRIPTION)%REACTOME DATABASE ID RELEASE 71%74160",
                   "GENERIC TRANSCRIPTION PATHWAY%REACTOME%R-HSA-212436.9",
                   "LONG-TERM POTENTIATION%REACTOME DATABASE ID RELEASE 71%9620244",
                   "MAPK FAMILY SIGNALING CASCADES%REACTOME DATABASE ID RELEASE 71%5683057",
                   "MTOR SIGNALLING%REACTOME%R-HSA-165159.5",
                   "PROTEIN-PROTEIN INTERACTIONS AT SYNAPSES%REACTOME DATABASE ID RELEASE 71%6794362",
                   "SIGNALING BY ERBB2%REACTOME DATABASE ID RELEASE 71%1227986",
                   "SIGNALING BY ERBB4%REACTOME DATABASE ID RELEASE 71%1236394",
                   "SIGNALING BY HEDGEHOG%REACTOME DATABASE ID RELEASE 71%5358351",
                   "SIGNALING BY GPCR%REACTOME%R-HSA-372790.4",
                   "SIGNALING BY NOTCH%REACTOME DATABASE ID RELEASE 71%157118",
                   "SIGNALING BY VEGF%REACTOME DATABASE ID RELEASE 71%194138",
                   "SIGNALING BY WNT%REACTOME%R-HSA-195721.5",
                   "TIGHT JUNCTION INTERACTIONS%REACTOME DATABASE ID RELEASE 71%420029",
                   "TRANSMISSION ACROSS CHEMICAL SYNAPSES%REACTOME%R-HSA-112315.5")
} else if (bader_version == "2023") {
  pathway_ids <- c("ADHERENS JUNCTIONS INTERACTIONS%REACTOME DATABASE ID RELEASE 38%418990",
                   "AXON GUIDANCE%REACTOME%R-HSA-422475.7",
                   "CA2+ PATHWAY%REACTOME%R-HSA-4086398.4",
                   "CHROMATIN ORGANIZATION%REACTOME DATABASE ID RELEASE 38%4839726",
                   "GAP JUNCTION TRAFFICKING AND REGULATION%REACTOME%R-HSA-157858.2",
                   "GENE EXPRESSION (TRANSCRIPTION)%REACTOME%R-HSA-74160.8",
                   "GENERIC TRANSCRIPTION PATHWAY%REACTOME%R-HSA-212436.12",
                   "LONG-TERM POTENTIATION%REACTOME DATABASE ID RELEASE 38%9620244",
                   "MAPK FAMILY SIGNALING CASCADES%REACTOME%R-HSA-5683057.4",
                   "MTOR SIGNALLING%REACTOME%R-HSA-165159.7",
                   "PROTEIN-PROTEIN INTERACTIONS AT SYNAPSES%REACTOME DATABASE ID RELEASE 38%6794362",
                   "SIGNALING BY ERBB2%REACTOME DATABASE ID RELEASE 38%1227986",
                   "SIGNALING BY ERBB4%REACTOME DATABASE ID RELEASE 38%1236394",
                   "SIGNALING BY GPCR%REACTOME DATABASE ID RELEASE 38%372790",
                   "SIGNALING BY HEDGEHOG%REACTOME DATABASE ID RELEASE 38%5358351",
                   "SIGNALING BY NOTCH%REACTOME%R-HSA-157118.6",
                   "SIGNALING BY VEGF%REACTOME%R-HSA-194138.3",
                   "SIGNALING BY WNT%REACTOME DATABASE ID RELEASE 38%195721",
                   "TIGHT JUNCTION INTERACTIONS%REACTOME DATABASE ID RELEASE 38%420029",
                   "TRANSMISSION ACROSS CHEMICAL SYNAPSES%REACTOME%R-HSA-112315.7")
} else {
  stop()
}

# Iterate over cluster solutions and import mouse pathway enrichment files
list_mouse_pathways <- vector(mode = "list", length = nk_max-1)
names(list_mouse_pathways) <- 2:nk_max
for (nk in 2:nk_max) {
  
  # Iterate over cluster number
  list_mouse_pathways[[as.character(nk)]] <- vector(mode = "list", length = nk)
  for (k in 1:nk) {
    pathways_file <- paste(mouse_pathways_file_prefix, nk, k, stringdb_score, sep = "_")
    pathways_file <- paste0(pathways_file, ".csv")
    pathways_file <- file.path(mouse_pathways_dir, pathways_file)
    list_mouse_pathways[[as.character(nk)]][[k]] <- read_csv(pathways_file, show_col_types = FALSE)  
    
    # Fix mouse enrichment p-values and q-values
    list_mouse_pathways[[as.character(nk)]][[k]] <- list_mouse_pathways[[as.character(nk)]][[k]] %>%
      mutate(NLQ = -log10(adj.P.Val))
  }
  
  # Combine clusters per solution
  list_mouse_pathways[[as.character(nk)]] <- list_mouse_pathways[[as.character(nk)]] %>% 
    reduce(.f = bind_rows) %>% 
    rename(pathway = Title,
           k = cluster) %>% 
    filter(ID %in% pathway_ids) %>% 
    mutate(nk = nk) %>% 
    unite(col = "cluster_id", nk, k, 
          sep = "-", remove = FALSE)
  
}

# Reduce list of pathways to a data frame
df_mouse_pathways_all <- list_mouse_pathways %>% 
  bind_rows() %>% 
  filter(ID %in% pathway_ids)

# Filter pathways for nk = 4
df_mouse_pathways <- df_mouse_pathways_all %>% 
  filter(nk == nk_mouse)
```

```{r fig2-pathways-info}
# Extract pathway ID and name
df_pathway_info <- df_mouse_pathways %>% 
  select(ID, pathway) %>% 
  distinct() %>% 
  arrange(pathway)

# # Create pathway acronyms
# df_pathway_info[["acronym"]] <- c(
#   "Adherens junction", "Axon guid.",
#   "Ca2+", "Chromatin",
#   "Gap junction", "Gene expr.",
#   "Transcription", "LTP",
#   "Mapk", "Mtor",
#   "Prot-prot int.", "erbb2",
#   "erbb4", "gpcr",
#   "hedgehog", "notch",
#   "vegf", "wnt", 
#   "Tight junction", "Trans. synapses"
# )

# Create pathway acronyms
df_pathway_info[["acronym"]] <- c(
  "AJI", "AG", "Ca2+", "CO",
  "GJTR", "GE", "GTP", "LTP",
  "MAPK", "MTOR", "PPIS", "ERBB2",
  "ERBB4", "GPCR", "HEDGEHOG", "NOTCH",
  "VEGF", "WNT", "TJI", "TACS"
)
```

```{r fig2-pathways-mouse-clust}
# Filter for cluster solutions with nk >= 4
df_pathways_nk_gt4 <- df_mouse_pathways_all %>% 
  filter(nk >= 4)

# Filter for desired pathways
# Compute normalized enrichment and NLQ per pathway
df_pathways_nk_gt4_subset <- df_pathways_nk_gt4 %>% 
  filter(pathway %in% df_pathway_info[["pathway"]]) %>% 
  group_by(pathway) %>% 
  mutate(NLQ_norm = NLQ/max(NLQ)) %>% 
  ungroup() %>% 
  mutate(NLQ_norm = ifelse(is.nan(NLQ_norm), 0, NLQ_norm))

# Convert pathway data frame into matrix 
mat_pathways_nk_gt4_subset <- df_pathways_nk_gt4_subset %>% 
  select(pathway, cluster_id, NLQ_norm) %>% 
  pivot_wider(id_cols = pathway, 
              names_from = cluster_id, 
              values_from = NLQ_norm) %>% 
  column_to_rownames("pathway") %>% 
  as.matrix()

# Hierarchical clustering of the pathways
pathway_hc <- hclust(d = dist(mat_pathways_nk_gt4_subset, 
                              method = "euclidean"))

# Extract pathway order according to clustering
pathway_lvls <- pathway_hc[["labels"]]
pathway_order <- pathway_hc[["order"]]
pathway_lvls_clustered <- pathway_lvls[pathway_order]

# Order pathway acronyms according to clustering
pathway_label_lvls_clustered <- df_pathway_info %>%
  mutate(pathway = factor(pathway, levels = pathway_lvls_clustered)) %>%
  arrange(pathway) %>%
  pull(acronym)
```

```{r fig2-pathways-mouse-clust}
# Obtain pathway cluster order at selected solution
hclust_kcut <- 5
cutree(pathway_hc, k = hclust_kcut) %>% 
  enframe(name = "pathway", value = "pathway_cluster") %>% 
  mutate(pathway = factor(pathway, levels = pathway_lvls_clustered)) %>% 
  arrange(pathway)
```

```{r fig2-pathways-mouse-plot}
# An additional empty level must be added to close the polar plot
polar_plot_lvls <- c(" ", pathway_lvls_clustered)

# Create a temp df for the additional empty factor level
df_polar_plot_tmp <- df_mouse_pathways %>% 
  mutate(pathway = as.character(pathway)) %>% 
  filter(pathway == polar_plot_lvls[length(polar_plot_lvls)]) %>% 
  mutate(pathway = " ")

# Join the empty factor level to the true factors
df_polar_plot <- df_mouse_pathways %>% 
  bind_rows(df_polar_plot_tmp) %>% 
  mutate(pathway = factor(pathway, levels = polar_plot_lvls))

# Clamp q-values to threshold
NLQ_threshold <- 8
df_polar_plot <- df_polar_plot %>% 
  mutate(NLQ = ifelse(NLQ > NLQ_threshold, NLQ_threshold, NLQ))

# Polar plot parameters
nspokes <- length(polar_plot_lvls) - 1
theta_start <- -(2*pi)/nspokes
breaks_start <- 0
breaks_end <- NLQ_threshold
breaks_step <- 2
polar_breaks <- seq(breaks_start, breaks_end, by = breaks_step)
polar_labels <- tibble(pathway = polar_plot_lvls[2],
                       breaks = polar_breaks)

# Palette for mouse pathway plot
# pathways_mouse_palette <- c(carto_pal(12, "Prism")[2],
#                             carto_pal(12, "Vivid")[1],
#                             carto_pal(12, "Safe")[4],
#                             carto_pal(12, "Prism")[8])
pathways_mouse_palette <- c("#008CFF",
                            carto_pal(12, "Vivid")[1],
                            "green3",
                            "#E63716")

# Transparency for mouse pathway plot
pathways_mouse_alpha <- c(0.4, 0.3, 0.6, 0.4)

# Theme for polar plots
theme_pathways <- theme(axis.ticks.x = element_blank(),
                        axis.line.x = element_blank(),
                        axis.text.x = element_text(size = font_size-1,
                                                   family = font_family),
                        axis.text.y = element_blank(),
                        axis.ticks.y = element_blank(),
                        axis.title.y = element_blank(),
                        panel.border = element_blank(),
                        legend.position = "bottom",
                        legend.key.size = unit(12, "bigpts"),
                        legend.title = element_text(size = font_size,
                                                    family = font_family,
                                                    hjust = 0.5),
                        legend.text = element_text(size = font_size,
                                                   family = font_family),
                        legend.margin = margin(b = 5)
)

# Generate polar plot
fig2_pathways_mouse <- ggplot(df_polar_plot, 
                              aes(x = pathway, 
                                  ymin = 0, ymax = NLQ, 
                                  group = cluster_id, 
                                  fill = cluster_id, 
                                  col = cluster_id)) + 
  geom_ribbon(mapping = aes(alpha = cluster_id,
                            size = cluster_id)) + 
  geom_text(data = polar_labels,
            inherit.aes = FALSE,
            mapping = aes(x = pathway,
                          y = breaks,
                          label = breaks),
            family = font_family,
            size = font_size*0.36) +
  coord_radar(start = theta_start, clip = "off") + 
  scale_x_discrete(expand = expansion()) + 
  scale_y_continuous(breaks = polar_breaks) +
  scale_colour_manual(values = pathways_mouse_palette,
                      guide = guide_legend(title.position = "bottom",
                                           hjust = 0)) + 
  scale_fill_manual(values = pathways_mouse_palette,
                    guide = guide_legend(title.position = "bottom",
                                         hjust = 0)) +
  scale_size_manual(values = c(0.6, 0.4, 0.4, 0.6)) + 
  scale_alpha_manual(values = pathways_mouse_alpha) +
  labs(x = NULL,
       fill = "Mouse cluster",
       col = "Mouse cluster") + 
  theme_bw() + 
  theme_pathways

# Extract legend grob
fig2_pathways_mouse_legend_grob <- fig2_pathways_mouse %>% 
  ggplotGrob() %>% 
  grid.force() %>% 
  getGrob("guides.3-3-3-3")

# Remove legend
fig2_pathways_mouse <- fig2_pathways_mouse +
  theme(legend.position = "none")

# Plot grob
fig2_pathways_mouse_grob <- grid.force(ggplotGrob(fig2_pathways_mouse))

# Fix polar axis labels
fig2_pathways_mouse_grob[["children"]][["panel.7-5-7-5"]][["children"]][[6]][["children"]][[1]][["children"]][[1]][["label"]] <- pathway_label_lvls_clustered

# Get initial label positions
fig2_pathways_mouse_labels_x <- fig2_pathways_mouse_grob[["children"]][["panel.7-5-7-5"]][["children"]][[6]][["children"]][[1]][["children"]][[1]][["x"]]
fig2_pathways_mouse_labels_y <- fig2_pathways_mouse_grob[["children"]][["panel.7-5-7-5"]][["children"]][[6]][["children"]][[1]][["children"]][[1]][["y"]]

# Nudge label positions
fig2_pathways_mouse_labels_x_nudge <- c(0.00, 0.00, 0.00, 0.00, 0.00, 
                                        0.00, 0.00, 0.00, 0.00, 0.00, 
                                        0.00, 0.00, 0.00, 0.00, 0.00, 
                                        0.00, 0.00, 0.00, 0.00, 0.00)

fig2_pathways_mouse_labels_y_nudge <- c(0.00, 0.00, 0.00, 0.00, 0.00, 
                                        0.00, 0.00, 0.00, 0.00, 0.00, 
                                        0.00, 0.00, 0.00, 0.00, 0.00, 
                                        0.00, 0.00, 0.00, 0.00, 0.00)

# Add units to nudge values
fig2_pathways_mouse_labels_x_nudge <- unit(fig2_pathways_mouse_labels_x_nudge, "native")
fig2_pathways_mouse_labels_y_nudge <- unit(fig2_pathways_mouse_labels_y_nudge, "native")

# Update label positions
fig2_pathways_mouse_labels_x <- fig2_pathways_mouse_labels_x + fig2_pathways_mouse_labels_x_nudge
fig2_pathways_mouse_labels_y <- fig2_pathways_mouse_labels_y + fig2_pathways_mouse_labels_y_nudge

# Set new label positions
fig2_pathways_mouse_grob[["children"]][["panel.7-5-7-5"]][["children"]][[6]][["children"]][[1]][["children"]][[1]][["x"]] <- fig2_pathways_mouse_labels_x
fig2_pathways_mouse_grob[["children"]][["panel.7-5-7-5"]][["children"]][[6]][["children"]][[1]][["children"]][[1]][["y"]] <- fig2_pathways_mouse_labels_y
```


# Panel: Human molecular pathways polar plot

```{r fig2-pathways-human-import}
# Base directory for human pathway data files
human_pathways_dir <- file.path(human_pipeline_dir, "enrichment")
human_pathways_dir <- file.path(human_pathways_dir, 
                                paste("StringDB", stringdb_version, 
                                      "Bader", bader_version, 
                                      sep = "_"))
human_pathways_dir <- file.path(human_pathways_dir, stringdb_score)

# Prefix for pathway data files
human_pathways_file_prefix <- "cluster_pathway_enrichment"

# Import human pathway enrichment files
list_human_pathways <- vector(mode = "list", length = nk_human)
names(list_human_pathways) <- paste(nk_human, 1:nk_human, sep = "-")
for (k in 1:nk_human) {
  pathways_file <- paste(human_pathways_file_prefix, nk_human, k, stringdb_score, sep = "_")
  pathways_file <- paste0(pathways_file, ".csv")
  pathways_file <- file.path(human_pathways_dir, pathways_file)
  list_human_pathways[[k]] <- read_csv(pathways_file, show_col_types = FALSE) %>% 
    rename(pathway = Title) %>% 
    mutate(nk = nk_human,
           NLQ = -log10(adj.P.Val)) %>% 
    unite(col = "cluster_id", nk, k,
          sep = "-", remove = FALSE)
}

# Reduce list of pathways to a data frame
df_human_pathways <- list_human_pathways %>% 
  bind_rows() %>% 
  filter(ID %in% pathway_ids)
```

```{r fig2-pathways-human-plot}
# An additional empty level must be added to close the polar plot
# polar_plot_lvls <- c(" ", df_pathway_info[["pathway"]])
polar_plot_lvls <- c(" ", pathway_lvls_clustered)

# Create a temp df for the additional empty factor level
df_polar_plot_tmp <- df_human_pathways %>% 
  mutate(pathway = as.character(pathway)) %>% 
  filter(pathway == polar_plot_lvls[length(polar_plot_lvls)]) %>% 
  mutate(pathway = " ")

# Join the empty factor level to the true factors
df_polar_plot <- df_human_pathways %>% 
  bind_rows(df_polar_plot_tmp) %>% 
  mutate(pathway = factor(pathway, levels = polar_plot_lvls))

# Clamp q-values to threshold
df_polar_plot <- df_polar_plot %>% 
  mutate(NLQ = ifelse(NLQ > NLQ_threshold, NLQ_threshold, NLQ))

# Palette for human pathway plot
pathways_human_palette <- pathways_mouse_palette[c(4, 1)]

# Transparency for human pathway plot
pathway_human_alpha <- pathways_mouse_alpha[c(4, 1)]

# Generate polar plot
fig2_pathways_human <- ggplot(df_polar_plot, 
                              aes(x = pathway, 
                                  ymin = 0, ymax = NLQ, 
                                  group = cluster_id, 
                                  fill = cluster_id, 
                                  col = cluster_id)) + 
  geom_ribbon(mapping = aes(alpha = cluster_id)) + 
  geom_text(data = polar_labels,
            inherit.aes = FALSE,
            mapping = aes(x = pathway,
                          y = breaks,
                          label = breaks),
            family = font_family,
            size = font_size*0.36) +
  coord_radar(start = theta_start, clip = "off") + 
  scale_x_discrete(expand = expansion()) + 
  scale_y_continuous(breaks = polar_breaks) +
  scale_colour_manual(values = pathways_human_palette,
                      guide = guide_legend(title.position = "bottom",
                                           hjust = 0)) + 
  scale_fill_manual(values = pathways_human_palette,
                    guide = guide_legend(title.position = "bottom",
                                         hjust = 0)) +
  scale_alpha_manual(values = pathway_human_alpha) + 
  labs(x = NULL,
       fill = "Human cluster",
       col = "Human cluster") + 
  theme_bw() + 
  theme_pathways

# Extract legend grob
fig2_pathways_human_legend_grob <- fig2_pathways_human %>% 
  ggplotGrob() %>% 
  grid.force() %>% 
  getGrob("guides.3-3-3-3")

# Remove legend
fig2_pathways_human <- fig2_pathways_human +
  theme(legend.position = "none")

# Plot grob
fig2_pathways_human_grob <- grid.force(ggplotGrob(fig2_pathways_human))

# Fix polar axis labels
fig2_pathways_human_grob[["children"]][["panel.7-5-7-5"]][["children"]][[6]][["children"]][[1]][["children"]][[1]][["label"]] <- pathway_label_lvls_clustered

# Get initial label positions
fig2_pathways_human_labels_x <- fig2_pathways_human_grob[["children"]][["panel.7-5-7-5"]][["children"]][[6]][["children"]][[1]][["children"]][[1]][["x"]]
fig2_pathways_human_labels_y <- fig2_pathways_human_grob[["children"]][["panel.7-5-7-5"]][["children"]][[6]][["children"]][[1]][["children"]][[1]][["y"]]

# Nudge label positions
fig2_pathways_human_labels_x_nudge <- c(0.00, 0.00, 0.00, 0.00, 0.00, 
                                        0.00, 0.00, 0.00, 0.00, 0.00, 
                                        0.00, 0.00, 0.00, 0.00, 0.00, 
                                        0.00, 0.00, 0.00, 0.00, 0.00)

fig2_pathways_human_labels_y_nudge <- c(0.00, 0.00, 0.00, 0.00, 0.00, 
                                        0.00, 0.00, 0.00, 0.00, 0.00, 
                                        0.00, 0.00, 0.00, 0.00, 0.00, 
                                        0.00, 0.00, 0.00, 0.00, 0.00)

# Add units to nudge values
fig2_pathways_human_labels_x_nudge <- unit(fig2_pathways_human_labels_x_nudge, "native")
fig2_pathways_human_labels_y_nudge <- unit(fig2_pathways_human_labels_y_nudge, "native")

# Update label positions
fig2_pathways_human_labels_x <- fig2_pathways_human_labels_x + fig2_pathways_human_labels_x_nudge
fig2_pathways_human_labels_y <- fig2_pathways_human_labels_y + fig2_pathways_human_labels_y_nudge

# Set new label positions
fig2_pathways_human_grob[["children"]][["panel.7-5-7-5"]][["children"]][[6]][["children"]][[1]][["children"]][[1]][["x"]] <- fig2_pathways_human_labels_x
fig2_pathways_human_grob[["children"]][["panel.7-5-7-5"]][["children"]][[6]][["children"]][[1]][["children"]][[1]][["y"]] <- fig2_pathways_human_labels_y
```


# Panel: Mouse-human pathway correspondence

```{r fig2-pathways-match}
# Get mouse and human pathway enrichment for matching clusters
list_human_pathways_match <- vector(mode = "list", length = length(list_human_pathways))
names(list_human_pathways_match) <- names(list_human_pathways)
for (k in 1:nk_human) {
  
  # ID for matching mouse cluster
  mouse_match_id <- df_similarity_nk %>% 
    filter(human_cluster_id == paste(nk_human, k, sep = "-"),
           significant) %>% 
    pull(mouse_cluster_id)
  
  # Combine human and mouse pathway enrichment
  list_human_pathways_match[[k]] <- list_human_pathways[[k]] %>% 
    mutate(cluster_id = paste0("H", cluster_id)) %>% 
    bind_rows(df_mouse_pathways %>% 
                filter(cluster_id == mouse_match_id) %>% 
                mutate(cluster_id = paste0("M", cluster_id))) %>% 
    filter(ID %in% pathway_ids)
  
}
```

```{r fig2-pathways-roc}
# Generate sequence of alpha values for ROC analysis
nalpha <- 1000
human_NLQ_start <- -10
human_NLQ_end <- 0
human_NLQ_seq <- seq(human_NLQ_start, human_NLQ_end, length.out = nalpha)
human_alpha_seq <- 10^human_NLQ_seq
human_alpha_seq <- c(0, human_alpha_seq)

# Iterate over mouse alpha values used to establish ground truth
mouse_alpha_seq <- c(5e-2, 1e-4, 1e-6, 1e-8)
list_pathways_roc <- vector(mode = "list", length = length(mouse_alpha_seq))
for (l in 1:length(list_pathways_roc)) {
  
  # Iterate over human clusters and generate ROC curve
  list_pathways_roc[[l]] <- vector(mode = "list", length = length(list_human_pathways_match))
  names(list_pathways_roc[[l]]) <- names(list_human_pathways_match)
  for (k in 1:length(list_pathways_roc[[l]])) {
    
    # Mouse ground truth for human cluster k
    mouse_pass <- list_human_pathways_match[[k]] %>% 
      filter(str_detect(cluster_id, "M")) %>% 
      mutate(pass = adj.P.Val < mouse_alpha_seq[l]) %>% 
      arrange(pathway) %>% 
      pull(pass)
    
    # Generate ROC curve data
    df_roc <- tibble(alpha = human_alpha_seq,
                     fpr = 0,
                     tpr = 0)
    for (i in 1:nrow(df_roc)) {
      
      # Human pathway predictions at alpha threshold
      human_pass <- list_human_pathways_match[[k]] %>% 
        filter(str_detect(cluster_id, "H")) %>% 
        mutate(pass = adj.P.Val <= df_roc[[i, "alpha"]]) %>% 
        arrange(pathway) %>% 
        pull(pass)
      
      # Compute TPR and FPR
      df_roc[[i, "tpr"]] <- sum(human_pass & mouse_pass)/sum(mouse_pass)
      df_roc[[i, "fpr"]] <- sum(human_pass & !mouse_pass)/sum(!mouse_pass)
      
    }
    
    list_pathways_roc[[l]][[k]] <- df_roc
    
  }
  
  # Bind ROC data for multiple clusters
  list_pathways_roc[[l]] <- list_pathways_roc[[l]] %>% 
    bind_rows(.id = "cluster_id") %>% 
    mutate(alpha_mouse = mouse_alpha_seq[l])
}

# Bind ROC data for multiple mouse alpha
df_pathways_roc <- list_pathways_roc %>% 
  bind_rows() %>% 
  mutate(NLQ_mouse = -log10(alpha_mouse),
         NLQ_mouse = round(NLQ_mouse, 2),
         NLQ_mouse_lab = sprintf("%.1f", NLQ_mouse),
         NLQ_mouse_lab = str_c("-log10(q) = ", NLQ_mouse_lab),
         NLQ_mouse_lab = factor(NLQ_mouse_lab))
```

```{r fig2-pathways-roc-plot}
# Plot ROC curves
fig2_pathways_roc <- ggplot(df_pathways_roc,
                            aes(x = fpr, y = tpr, col = cluster_id)) + 
  annotate(geom = "segment",
           x = 0, xend = 1,
           y = 0, yend = 1,
           size = 0.3,
           linetype = "dashed",
           col = "black") +
  geom_line(size = 0.35) +
  facet_wrap(~NLQ_mouse_lab, nrow = 2, ncol = 2) + 
  scale_x_continuous(limits = c(0, 1)) + 
  scale_y_continuous(limits = c(0, 1), 
                     expand = expansion(add = 0.1)) + 
  scale_color_manual(values = pathways_human_palette) + 
  labs(x = "False positive rate",
       y = "True positive rate") +
  theme_bw() +
  theme(legend.position = "none",
        strip.text.x = element_text(size = font_size-1, 
                                    family = font_family,
                                    margin = margin(b = 2, t = 2)),
        panel.spacing.x = unit(6, "bigpts"),
        panel.spacing.y = unit(2, "bigpts"),
        plot.margin = margin())
```

```{r fig2-pathways-roc-auc}
# Generate sequence of mouse alpha values for AUC analysis
mouse_alpha_seq_auc <- 2:10
mouse_alpha_seq_auc <- (1/10)^mouse_alpha_seq_auc
mouse_alpha_seq_auc <- c(0.05, mouse_alpha_seq_auc)

# Iterate over human clusters and mouse alpha values
df_auc <- expand_grid(k = 1:nk_human,
                      alpha = mouse_alpha_seq_auc,
                      auc = 0)
for (i in 1:nrow(df_auc)) {
  
  # Human cluster
  k <- df_auc[[i, "k"]]
  
  # Human pathway values used to predict the mouse pathways
  predictor <- list_human_pathways_match[[k]] %>% 
    filter(str_detect(cluster_id, "H")) %>% 
    arrange(pathway) %>% 
    pull(adj.P.Val)
  
  # Mouse pathway ground truth at alpha
  outcome <- list_human_pathways_match[[k]] %>% 
    filter(str_detect(cluster_id, "M")) %>% 
    mutate(pass = adj.P.Val < df_auc[[i, "alpha"]]) %>% 
    arrange(pathway) %>% 
    pull(pass)
  
  # Compute AUC
  df_auc[[i, "auc"]] <- auc(outcome, predictor, quiet = TRUE)[1]
}

# Generate cluster IDs
df_auc <- df_auc %>% 
  mutate(cluster_id = paste(nk_human, k, sep = "-"),
         cluster_id = factor(cluster_id))

# x-labels for AUC plot
fig2_pathways_roc_auc_xlabs <- -log10(mouse_alpha_seq_auc)
fig2_pathways_roc_auc_xlabs <- round(fig2_pathways_roc_auc_xlabs, 2)

# Convert mouse alpha values from ROC plots to NLQ
mouse_NLQ_seq <- -log10(mouse_alpha_seq)

# Plot AUC over mouse alpha values
fig2_pathways_roc_auc <- ggplot(df_auc, aes(x = -log10(alpha), 
                                            y = auc, 
                                            col = cluster_id)) + 
  annotate(geom = "rect",
           xmin = mouse_NLQ_seq - 0.2,
           xmax = mouse_NLQ_seq + 0.2,
           ymin = -Inf, 
           ymax = Inf,
           alpha = 0.5,
           fill = "grey60") + 
  geom_line(size = 0.3) + 
  geom_point(size = 0.75) + 
  coord_cartesian(xlim = c(1.0, 10),
                  ylim = c(0.5, 1.0)) +
  scale_x_continuous(breaks = fig2_pathways_roc_auc_xlabs,
                     expand = expansion(add = 0.3)) + 
  scale_color_manual(values = pathways_human_palette) + 
  labs(x = "-log10(q)",
       y = "AUC") + 
  theme_bw() + 
  theme(panel.grid.minor.x = element_blank(),
        legend.position = "none",
        plot.margin = margin(t = 4, unit = "bigpts"))
```


# Figure

```{r fig2-build}
# Combine similarity and dx plots using patchwork
fig2_sim_dx <- (fig2_sim_heatmap / fig2_dx) +
  plot_layout(heights = c(1, 2)) &
  theme(axis.text = element_text(size = font_size, family = font_family),
        axis.title = element_text(size = font_size, family = font_family),
        legend.text = element_text(size = font_size-1, family = font_family),
        legend.title = element_text(size = font_size, family = font_family),
        legend.margin = margin(l = 5, r = 5, t = 0, b = 0, unit = "bigpts"))
fig2_sim_dx_grob <- patchworkGrob(fig2_sim_dx)

# Combine ROC and AUC plots using patchwork
fig2_roc <- (fig2_pathways_roc / fig2_pathways_roc_auc) +
  plot_layout(heights = c(2, 1)) &
  theme(axis.text = element_text(size = font_size-1, family = font_family),
        axis.title = element_text(size = font_size, family = font_family),
        axis.ticks = element_line(size = 0.3))
fig2_roc_grob <- patchworkGrob(fig2_roc)

# Width of similarity and dx panels
fig2_sim_dx_width_pt <- fig2_width_pt - fig2_ss_width_pt

# Dimensions of polar plot panel
fig2_polar_padding_pt <- 5
fig2_polar_width_pt <- (fig2_ss_width_pt - fig2_polar_padding_pt)/2
fig2_polar_height_pt <- fig2_polar_width_pt
fig2_polar_legend_height_pt <- 26

# Figure 2 dimensions
fig2_widths <- c(fig2_polar_width_pt, fig2_polar_padding_pt, fig2_polar_width_pt, fig2_sim_dx_width_pt)
fig2_heights <- c(fig2_ss_height_pt, fig2_polar_padding_pt, fig2_polar_height_pt, fig2_polar_legend_height_pt)

# Figure 2 layout
fig2_layout <- rbind(c(01, 01, 01, 02),
                     c(03, 03, 03, 03),
                     c(04, 05, 06, 07),
                     c(08, 09, 10, 07))

# Figure 2 grob
fig2_grob <- arrangeGrob(fig2_ss_grob, 
                         fig2_sim_dx_grob,
                         zeroGrob(),
                         fig2_pathways_mouse_grob,
                         zeroGrob(),
                         fig2_pathways_human_grob,
                         fig2_roc_grob,
                         fig2_pathways_mouse_legend_grob,
                         zeroGrob(),
                         fig2_pathways_human_legend_grob,
                         layout_matrix = fig2_layout,
                         widths = unit(fig2_widths, "bigpts"),
                         heights = unit(fig2_heights, "bigpts"))

# Figure 2 dimensions
fig2_width_pt <- sum(fig2_widths)
fig2_height_pt <- sum(fig2_heights)

# Export
outfile <- paste0(output_plot_prefix, ".pdf")
outfile <- file.path(output_dir, outfile)
export_pdf(x = fig2_grob, 
           width = fig2_width_pt,
           height = fig2_height_pt,
           units = "bigpts",
           file = outfile)
```


# Supplementary

```{r fig2-supp-pathways-roc-plots, eval = FALSE}
# Sequence of alpha thresholds
nalpha <- 1000
alpha_seq <- seq(0, 1, length.out = nalpha) 

# Sequence of alpha values for mouse ground truth
# NOTE: ROC analysis can't be completed for -log10(12) and above
alpha_mouse <- 1:10
alpha_mouse <- (1/10)^alpha_mouse
for (alpha in alpha_mouse) {
  
  # Iterate over human clusters and generate ROC curve
  list_pathways_roc <- vector(mode = "list", length = length(list_human_pathways_match))
  names(list_pathways_roc) <- names(list_human_pathways_match)
  for (k in 1:length(list_pathways_roc)) {
    
    # Mouse ground truth for human cluster k
    mouse_pass <- list_human_pathways_match[[k]] %>% 
      filter(str_detect(cluster_id, "M")) %>% 
      mutate(pass = adj.P.Val < alpha) %>% 
      arrange(pathway) %>% 
      pull(pass)
    
    # Generate ROC curve data
    df_roc <- tibble(alpha = alpha_seq,
                     fpr = 0,
                     tpr = 0)
    for (i in 1:nrow(df_roc)) {
      
      # Human pathway predictions at alpha threshold
      human_pass <- list_human_pathways_match[[k]] %>% 
        filter(str_detect(cluster_id, "H")) %>% 
        mutate(pass = adj.P.Val <= df_roc[[i, "alpha"]]) %>% 
        arrange(pathway) %>% 
        pull(pass)
      
      # Compute TPR and FPR
      df_roc[[i, "tpr"]] <- sum(human_pass & mouse_pass)/sum(mouse_pass)
      df_roc[[i, "fpr"]] <- sum(human_pass & !mouse_pass)/sum(!mouse_pass)
      
    }
    
    list_pathways_roc[[k]] <- df_roc
    
  }
  
  # Combine ROC data for both human clusters
  df_pathways_roc <- bind_rows(list_pathways_roc, .id = "cluster_id")
  
  # Plot ROC curves at given mouse alpha
  fig2_supp_pathways_roc <- ggplot(df_pathways_roc,
                                   aes(x = fpr, y = tpr, 
                                       col = cluster_id)) + 
    annotate(geom = "segment",
             x = 0, xend = 1,
             y = 0, yend = 1,
             size = 0.4,
             linetype = "dashed",
             col = "black") +
    geom_line() +
    coord_equal() + 
    scale_color_manual(values = pathways_human_palette) + 
    labs(x = "False positive rate (1 - specificity)",
         y = "Sensitivity",
         col = "Cluster",
         title = paste("-log10(alpha)", "=", -log10(alpha))) +
    theme_bw() +
    theme(axis.text = element_text(size = font_size),
          axis.title = element_text(size = font_size),
          legend.title = element_text(size = font_size),
          legend.text = element_text(size = font_size),
          plot.title = element_text(size = font_size))
  
  outfile <- paste(output_plot_prefix, "supp", "pathways",
                   "ROC", -log10(alpha), 
                   sep = "_")
  outfile <- paste0(outfile, ".pdf")
  outfile <- file.path(output_dir, outfile)
  pdf(file = outfile,
      width = 3,
      height = 2.5)
  print(fig2_supp_pathways_roc)
  dev.off()
  
}
```

```{r fig2-supp-pathways-roc-auc, eval = FALSE}
# Iterate over human clusters and mouse alpha values
df_auc <- expand_grid(k = 1:nk_human,
                      alpha = alpha_mouse,
                      auc = 0)
for (i in 1:nrow(df_auc)) {
  
  # Human cluster
  k <- df_auc[[i, "k"]]
  
  # Human pathway values used to predict the mouse pathways
  predictor <- list_human_pathways_match[[k]] %>% 
    filter(str_detect(cluster_id, "H")) %>% 
    arrange(pathway) %>% 
    pull(adj.P.Val)
  
  # Mouse pathway ground truth at alpha
  outcome <- list_human_pathways_match[[k]] %>% 
    filter(str_detect(cluster_id, "M")) %>% 
    mutate(pass = adj.P.Val < df_auc[[i, "alpha"]]) %>% 
    arrange(pathway) %>% 
    pull(pass)
  
  # Compute AUC
  df_auc[[i, "auc"]] <- auc(outcome, predictor, quiet = TRUE)[1]
}

# Generate cluster IDs
df_auc <- df_auc %>% 
  mutate(cluster_id = paste(nk_human, k, sep = "-"),
         cluster_id = factor(cluster_id))

# Plot AUC over mouse alpha values
fig2_pathways_roc_auc <- ggplot(df_auc, aes(x = -log10(alpha), y = auc, col = cluster_id)) + 
  geom_line() + 
  geom_point() + 
  coord_cartesian(ylim = c(0.5, 1)) +
  scale_x_continuous(breaks = -log10(alpha_mouse)) + 
  labs(y = "AUC",
       col = "Human cluster") + 
  theme_bw() + 
  theme(panel.grid.minor.x = element_blank())

# Export plot
outfile <- paste0("figure2_supp_pathways_ROC_AUC.pdf")
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = unit(5, "in"),
    height = unit(3, "in"))
print(fig2_pathways_roc_auc)
dev.off()
```

```{r fig2-pathways-enrichment-20, eval = FALSE}
# pathway_palette_cols <- c("white", brewer.pal(n = 9, name = "OrRd")[3:9])
pathway_palette_cols <- brewer.pal(n = 9, name = "OrRd")
pathway_palette <- colorRampPalette(colors = pathway_palette_cols)(255)

E_threshold <- 30

p_pathways_match_1 <- list_human_pathways_match[[1]] %>% 
  mutate(E = ifelse(E > E_threshold, E_threshold, E)) %>% 
  ggplot(mapping = aes(x = cluster_id, y = pathway, fill = E)) + 
  geom_tile(col = "grey50") +
  scale_x_discrete(expand = expansion(), position = "top") + 
  scale_y_discrete(expand = expansion()) + 
  labs(x = NULL,
       y = "Pathway module",
       fill = "Enrichment") +
  theme_bw() +
  theme()

p_pathways_match_2 <- list_human_pathways_match[[2]] %>% 
  mutate(E = ifelse(E > E_threshold, E_threshold, E)) %>% 
  ggplot(mapping = aes(x = cluster_id, y = pathway, fill = E)) + 
  geom_tile(col = "grey50") +
  scale_x_discrete(expand = expansion(), position = "top") + 
  scale_y_discrete(expand = expansion()) + 
  labs(x = NULL,
       y = NULL,
       fill = "Enrichment") +
  theme_bw() +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank())

p_pathways_match <- (p_pathways_match_1 | p_pathways_match_2) / guide_area() +
  plot_layout(guides = "collect", heights = c(0.8, 0.2)) &
  scale_fill_gradientn(colors = pathway_palette,
                       limits = c(0, E_threshold),
                       guide = guide_colourbar(title.position = "bottom",
                                               barheight = unit(0.05, "npc"),
                                               barwidth = unit(0.35, "npc")))  &
  theme(axis.text = element_text(size = font_size-1),
        axis.ticks = element_blank(),
        axis.ticks.length = unit(0, "bigpts"),
        axis.title = element_text(size = font_size-1,
                                  family = font_family),
        legend.position = "bottom",
        legend.direction = "horizontal",
        # legend.background = element_rect(colour = "black"),
        legend.margin = margin(),
        legend.title = element_text(angle = 0,
                                    hjust = 0.5,
                                    size = font_size-1,
                                    family = font_family),
        legend.text = element_text(size = font_size-1,
                                   family = font_family),
        plot.margin = margin(r = 1.5, t = 0, b = 0, l = 1.5))

# legend.position = c(1, 0.5),
# legend.justification = c("left", "center"),
# legend.margin = margin(l = 4, r = 0, unit = "bigpts"),
# legend.title = element_text(angle = 90,
#                             hjust = 0.5,
#                             size = font_size,
#                             family = font_family),
# legend.text = element_text(size = font_size-1,
#                            family = font_family),

# Pathways plot dimensions in bigpts
fig2_pathways_match_width_pt <- 170
fig2_pathways_match_height_pt <- 175

# Pathways plot dimensions in inches
fig2_pathways_match_width_in <- unit(fig2_pathways_match_width_pt/pt_per_in, "in")
fig2_pathways_match_height_in <- unit(fig2_pathways_match_height_pt/pt_per_in, "in")

# Export pathways plot
outfile <- "figure2_pathways_match_enrichment_20.pdf"
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = fig2_pathways_match_width_in,
    height = fig2_pathways_match_height_in)
print(p_pathways_match)
dev.off()
```

```{r fig2-pathways-significance-20, eval = FALSE}
p_pathways_match_1 <- list_human_pathways_match[[1]] %>% 
  mutate(significant = ifelse(adj.P.Val < 0.05, TRUE, FALSE)) %>% 
  ggplot(mapping = aes(x = cluster_id, y = pathway, fill = significant)) + 
  geom_tile(col = "grey50") +
  scale_x_discrete(expand = expansion(), position = "top") + 
  scale_y_discrete(expand = expansion()) + 
  scale_fill_manual(values = c("white", pathway_palette_cols[length(pathway_palette_cols)])) + 
  labs(x = NULL,
       y = "Biological pathway module",
       fill = "Significant") +
  theme_bw()

p_pathways_match_2 <- list_human_pathways_match[[2]] %>% 
  mutate(significant = ifelse(adj.P.Val < 0.05, TRUE, FALSE)) %>% 
  ggplot(mapping = aes(x = cluster_id, y = pathway, fill = significant)) + 
  geom_tile(col = "grey50") +
  scale_x_discrete(expand = expansion(), position = "top") + 
  scale_y_discrete(expand = expansion()) + 
  scale_fill_manual(values = c("white", pathway_palette_cols[length(pathway_palette_cols)])) + 
  labs(x = NULL,
       y = NULL,
       fill = "Significant") +
  theme_bw() +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank())

p_pathways_match <- (p_pathways_match_1 | p_pathways_match_2) +
  plot_layout(guides = "collect")

outfile <- "figure2_pathways_match_significance_20.pdf"
outfile <- file.path(output_dir, outfile)
pdf(file = outfile,
    width = unit(8, "in"),
    height = unit(6, "in"))
print(p_pathways_match)
dev.off()
```
