---
title: "Supplementary Figures"
subtitle: "Clustering Autism"
author: "Antoine Beauchamp"
date: "2023-12-18"
output: html_document
---

# Initialization

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r packages}
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(grid))
suppressPackageStartupMessages(library(gridExtra))
suppressPackageStartupMessages(library(RMINC))
suppressPackageStartupMessages(library(MRIcrotome))
suppressPackageStartupMessages(library(SNFtool))
suppressPackageStartupMessages(library(cluster))
suppressPackageStartupMessages(library(ggalluvial))
suppressPackageStartupMessages(library(patchwork))
suppressPackageStartupMessages(library(RColorBrewer))
```

```{r functions}
source("../src/utils.R")
source("../src/processing.R")
source("../src/analysis.R")

#Function to estimate cluster metrics over a range of solutions
estimate_cluster_metrics <- function (W, NUMC = 2:5){
  if (min(NUMC) == 1) {
    warning("Note that we always assume there are more than one cluster.")
    NUMC <- NUMC[NUMC > 1]
  }
  W <- (W + t(W))/2
  diag(W) <- 0
  if (length(NUMC) <= 0) {
    warning(paste("Invalid NUMC provided, must be an integer vector", 
                  "with atleast one other number than 1.", "Using default NUMC=c(2,3,4,5)", 
                  sep = ""))
    NUMC <- 2:5
  }
  degs <- rowSums(W)
  degs[degs == 0] <- .Machine$double.eps
  D <- diag(degs)
  L <- D - W
  Di <- diag(1/sqrt(degs))
  L <- Di %*% L %*% Di
  eigs <- eigen(L)
  eigs_order <- sort(eigs$values, index.return = T)$ix
  eigs$values <- eigs$values[eigs_order]
  eigs$vectors <- eigs$vectors[, eigs_order]
  eigengap <- abs(diff(eigs$values))
  quality <- list()
  for (c_index in 1:length(NUMC)) {
    ck <- NUMC[c_index]
    UU <- eigs$vectors[, 1:ck]
    EigenvectorsDiscrete <- SNFtool:::.discretisation(UU)[[1]]
    EigenVectors <- EigenvectorsDiscrete^2
    temp1 <- EigenVectors[do.call(order, lapply(1:ncol(EigenVectors), 
                                                function(i) EigenVectors[, i])), ]
    temp1 <- t(apply(temp1, 1, sort, TRUE))
    quality[[c_index]] <- (1 - eigs$values[ck + 1])/(1 - 
                                                       eigs$values[ck]) * sum(sum(diag(1/(temp1[, 1] + .Machine$double.eps)) %*% 
                                                                                    temp1[, 1:max(2, ck - 1)]))
  }
  
  out <- tibble(nk = NUMC,
                eigengap = eigengap[NUMC],
                rotation = unlist(quality))
  
  return(out)
}
```

```{r params}
#Output directory
output_dir <- "figure_supplementary"
if (!(dir.exists(output_dir))) {dir.create(output_dir, recursive = TRUE)}

# Plot file prefix
output_plot_prefix <- "figure_supp"

# Similarity pipeline
version <- "v2"
pipeline_dir <- "../data/cross_species/"
pipeline_dir <- file.path(pipeline_dir, version)

# Human parameters
human_resolution <- 0.8
human_es_method <- "normative-growth"
human_es_df <- 3
human_cluster_map_method <- "mean"

# Mouse parameters
mouse_resolution <- 0.2
mouse_cluster_map_method <- human_cluster_map_method

# Similarity parameters
metric <- "correlation"

# Fetch parameter set
metadata <- file.path(pipeline_dir, "metadata.csv")
params <- fetch_params_metadata(metadata = metadata,
                                human_resolution = human_resolution,
                                human_es_method = human_es_method,
                                human_es_df = human_es_df,
                                human_cluster_map_method = human_cluster_map_method,
                                metric = metric)
params
```


```{r paths}
# Parameter set ID
params_id <- 405

# Update pipeline directory with parameter set ID
pipeline_dir <- file.path(pipeline_dir, params_id)

# Jacobians
jacobians <- c("absolute", "relative")

# Human parameter set ID
human_params_id <- params %>% 
  filter(id == params_id) %>% 
  pull(human_id)

# Mouse parameter set ID
mouse_params_id <- params %>% 
  filter(id == params_id) %>% 
  pull(mouse_id)

# Max number of clusters
nk_max <- params %>% 
  filter(id == params_id) %>% 
  pull(human_cluster_nk_max)

# Human pipeline directory
human_pipeline_dir <- "../data/human/derivatives/"
human_pipeline_dir <- file.path(human_pipeline_dir, version, human_params_id)

# Human cluster directory
human_cluster_dir <- file.path(human_pipeline_dir, "clusters")
human_cluster_resolution <- params %>% 
  filter(id == params_id) %>% 
  pull(human_cluster_resolution)
human_cluster_resolution <- sprintf("%.1f", human_cluster_resolution)
human_cluster_dir <- file.path(human_cluster_dir, str_c("resolution_", human_cluster_resolution))

# Human cluster map directories
human_cluster_map_dirs <- file.path(human_pipeline_dir, "cluster_maps")
human_cluster_map_dirs <- file.path(human_cluster_map_dirs, str_c("resolution_", human_resolution))
human_cluster_map_dirs <- file.path(human_cluster_map_dirs, jacobians)
names(human_cluster_map_dirs) <- jacobians

# Mouse pipeline directory
mouse_pipeline_dir <- "../data/mouse/derivatives/"
mouse_pipeline_dir <- file.path(mouse_pipeline_dir, "v2", mouse_params_id)

# Mouse cluster directory
mouse_cluster_dir <- file.path(mouse_pipeline_dir, "clusters")

# Mouse cluster map directories
mouse_cluster_map_dirs <- file.path(mouse_pipeline_dir, "cluster_maps")
mouse_cluster_map_dirs <- file.path(mouse_cluster_map_dirs, str_c("resolution_", mouse_resolution))
mouse_cluster_map_dirs <- file.path(mouse_cluster_map_dirs, jacobians)
names(mouse_cluster_map_dirs) <- jacobians

# Mouse cluster map directories at 50um
mouse_cluster_map_dirs_50um <- file.path(mouse_pipeline_dir, "cluster_maps")
mouse_cluster_map_dirs_50um <- file.path(mouse_cluster_map_dirs_50um, "resolution_0.05")
mouse_cluster_map_dirs_50um <- file.path(mouse_cluster_map_dirs_50um, jacobians)
names(mouse_cluster_map_dirs_50um) <- jacobians
```

```{r graphical-params}
# Number of bigpts in an inch
pt_per_in <- 72

# Font family
font_family <- "Helvetica"

# Nature suggested font size: 5-7 pt
font_size <- 6

# Empty rectangle grob
# empty_rect_grob <- rectGrob(gp = gpar(fill = NA))

# Black rectangle grob
# black_rect_grob <- rectGrob(gp = gpar(fill = "black"))

# Rectangle with number in it
# rect_w_num <- function(n) {
#   out <- gTree(children = gList(empty_rect_grob,
#                                 textGrob(label = n)))
#   return(out)
# }

# Maximal figure dimensions in bigpts
fig_width_pt <- 510
fig_height_pt <- 481
```

# Supplementary Figure 1

```{r fig-supp-1-import}
#Human cluster assignments
human_cluster_file <- file.path(human_cluster_dir, "clusters.csv")
df_human_clusters <- read_csv(human_cluster_file, show_col_types = FALSE)

#Mouse cluster assignments
mouse_cluster_file <- file.path(mouse_cluster_dir, "clusters.csv")
df_mouse_clusters <- read_csv(mouse_cluster_file, show_col_types = FALSE)
colnames(df_mouse_clusters) <- c("ID", str_c("nk", 2:10))

#Human affinity matrix
human_affinity_file <- file.path(human_cluster_dir, "affinity.csv")
df_human_affinity <- read_csv(human_affinity_file, show_col_types = FALSE)
mat_human_affinity <- as.matrix(df_human_affinity)
rownames(mat_human_affinity) <- colnames(mat_human_affinity)

#Mouse affinity matrix
mouse_affinity_file <- file.path(mouse_cluster_dir, "affinity.RData")
load(mouse_affinity_file)
mat_mouse_affinity <- W
df_mouse_affinity <- as_tibble(mat_mouse_affinity)
```

```{r fig-supp-1}
#Max nk to examine
eigengap_nk_max <- 20

#Get human cluster metrics
df_human_cluster_metrics <- estimate_cluster_metrics(W = mat_human_affinity, NUMC = 2:eigengap_nk_max)
df_mouse_cluster_metrics <- estimate_cluster_metrics(W = mat_mouse_affinity, NUMC = 2:eigengap_nk_max)
df_cluster_metrics <- bind_rows(
  df_human_cluster_metrics %>% 
    mutate(species = "Human"),
  df_mouse_cluster_metrics %>% 
    mutate(species = "Mouse")
)

#Plot of eigengap distributions
fig_supp_1 <- ggplot(df_cluster_metrics,
                     aes(x = nk, y = eigengap, col = species)) + 
  geom_line(size = 0.4) + 
  geom_point(size = 1) +
  coord_cartesian(xlim = c(2, eigengap_nk_max),
                  ylim = c(0, 0.1)) + 
  scale_x_continuous(breaks = seq(0, eigengap_nk_max, by = 1)) +
  scale_y_continuous(breaks = seq(0, 0.1, by = 0.01)) + 
  labs(x = "Number of clusters (K)",
       y = "Eigengap",
       col = "Species") +
  theme_bw() + 
  theme(axis.title = element_text(size = font_size+1,
                                  family = font_family),
        axis.text = element_text(size = font_size,
                                 family = font_family),
        legend.title = element_text(size = font_size+1,
                                    family = font_family),
        legend.text = element_text(size = font_size,
                                   family = font_family),
        panel.grid.minor.x = element_blank())

# Figure dimensions
fig_supp_1_width_pt <- fig_width_pt
fig_supp_1_height_pt <- fig_width_pt/3

# Export
outfile <- paste(output_plot_prefix, 1, sep = "_")
outfile <- paste0(outfile, ".pdf")
outfile <- file.path(output_dir, outfile)
export_pdf(x = ggplotGrob(fig_supp_1),
           width = fig_supp_1_width_pt,
           height = fig_supp_1_height_pt,
           units = "bigpts",
           file = outfile)
```

# Supplementary Figure 2

```{r fig-supp-2-ss-files}
# Human anatomy
human_anat_file <- "../data/human/registration/v2/reference_files/model_0.8mm.mnc"
human_anat <- mincGetVolume(human_anat_file)
human_anat_vol <- mincArray(human_anat)

# Cropped human images along sagittal and transverse planes
human_slices_dim_1 <- 25:200
human_slices_dim_3 <- 25:220
human_anat_vol_cropped <- human_anat_vol[human_slices_dim_1,,human_slices_dim_3]

# Human mask
human_mask_file <- "../data/human/registration/v2/reference_files/mask_0.8mm.mnc"
human_mask <- mincGetVolume(human_mask_file)

# Image threshold method
threshold <- params %>% 
  filter(id == params_id) %>% 
  pull(threshold)

# Image threshold value
threshold_value <- params %>% 
  filter(id == params_id) %>% 
  pull(threshold_value)

# Image threshold symmetric option
threshold_symmetric <- params %>% 
  filter(id == params_id) %>% 
  pull(threshold_symmetric)

# Cluster solutions to visualize
nk_human <- 2
```

```{r fig2-ss-human-import}
# Iterate over jacobians  
list_human_centroids <- vector(mode = "list", length = length(jacobians))
names(list_human_centroids) <- jacobians
for (j in jacobians) {
  
  # Iterate over clusters in nk solution
  list_human_centroids[[j]] <- vector(mode = "list", length = nk_human)
  names(list_human_centroids[[j]]) <- paste(nk_human, 1:nk_human, sep = "-")
  for (k in 1:nk_human) {
    
    # Import centroid image for specific cluster using threshold
    img_human <- import_cluster_map(imgdir = human_cluster_map_dirs[[j]],
                                    mask = human_mask_file,
                                    nk = nk_human, k = k,
                                    threshold = threshold,
                                    threshold_value = threshold_value,
                                    threshold_symmetric = threshold_symmetric)
    
    # Crop image to remove black space
    img_human <- mincArray(img_human)
    img_human <- img_human[human_slices_dim_1,,human_slices_dim_3]
    list_human_centroids[[j]][[k]] <- img_human
    
  }
}
```

```{r fig2-ss-human-thresholds}
# Data frame to store human image thresholds
df_human_thresholds <- tibble(nk = rep(nk_human, nk_human),
                              k = 1:nk_human) %>% 
  unite(col = "cluster_id", nk, k, sep = "-", remove = FALSE) %>% 
  mutate(threshold_min = 0, 
         threshold_max = 0)

# Get min/max thresholds for each human image
for (i in 1:nrow(df_human_thresholds)) {
  human_img_abs <- abs(list_human_centroids[["relative"]][[i]])
  human_img_abs <- human_img_abs[human_img_abs > 0]
  df_human_thresholds[[i, "threshold_max"]] <- max(human_img_abs)
  df_human_thresholds[[i, "threshold_min"]] <- min(human_img_abs)
}
```

```{r fig2-ss-params}
# Number of slices per ss
ss_nslices <- 8

# Human slices
# human_slices <- c(61, 105, 127, 152, 214)
human_slices <- floor(seq(60, 220, length.out = ss_nslices))

# Human anatomy thresholds
human_anat_low <- 3
human_anat_high <- 10

# Overlay thresholds from previous code chunk
overlay_low <- 0.19
overlay_high <- 1.0
```

```{r}
for (k in 1:nk_human) {
  
  fig_supp_2_grob <- sliceSeries(nrow = ss_nslices, ncol = 1, begin = 60, end = 220) %>% 
    anatomy(human_anat_vol_cropped, low = human_anat_low, high = human_anat_high) %>% 
    overlay(list_human_centroids[["absolute"]][[k]], low = 0.2, high = 1.0, symmetric = TRUE) %>% 
    sliceSeries() %>% anatomy() %>% 
    overlay(list_human_centroids[["relative"]][[k]], low = 0.2, high = 1.0, symmetric = TRUE) %>%   
    legend() %>% 
    grobify()
  
  fig_supp_2_width_pt <- fig_width_pt/(3)
  fig_supp_2_height_pt <- (fig_supp_2_width_pt/3)*ss_nslices
  
  outfile <- paste(output_plot_prefix, 2, nk_human, k, sep = "_")
  outfile <- paste0(outfile, ".pdf")
  outfile <- file.path(output_dir, outfile)
  export_pdf(x = fig_supp_2_grob,
             file = outfile,
             width = fig_supp_2_width_pt,
             height = fig_supp_2_height_pt,
             units = "bigpts")
  
}
```



# Supplementary Figure 3

```{r fig2-ss-files}
# Mouse anatomy
mouse_anat_file <- "../data/mouse/atlas/DSURQE_CCFv3_average_50um.mnc"
mouse_anat <- mincGetVolume(mouse_anat_file)
mouse_anat_vol <- mincArray(mouse_anat)

# Mouse mask
mouse_mask_file <- "../data/mouse/atlas/coronal_50um_coverage_bin0.8.mnc"
mouse_mask <- mincGetVolume(mouse_mask_file)

# Image threshold method
threshold <- params %>% 
  filter(id == params_id) %>% 
  pull(threshold)

# Image threshold value
threshold_value <- params %>% 
  filter(id == params_id) %>% 
  pull(threshold_value)

# Image threshold symmetric option
threshold_symmetric <- params %>% 
  filter(id == params_id) %>% 
  pull(threshold_symmetric)

# Cluster solutions to visualize
nk_mouse <- 4
```

```{r fig2-ss-mouse-resample}
# Mouse images need to be resampled to 50um
run <- FALSE
if (run) {
  for (j in jacobians) {
    
    indir <- mouse_cluster_map_dirs[[j]]
    outdir <- mouse_cluster_map_dirs_50um[[j]]
    
    for (k in 1:nk_mouse) {
      
      infile <- paste0("cluster_map_nk_", nk_mouse, "_k_", k, ".mnc")
      outfile <- infile
      
      infile <- file.path(indir, infile)
      outfile <- file.path(outdir, outfile)
      
      cmd_mincresample <- paste("mincresample", "-clobber",
                                "-like", mouse_anat_file,
                                infile, outfile)
      system(command = cmd_mincresample)
      
    }
  }
}
```

```{r fig2-ss-mouse-import}
# Iterate over jacobians  
list_mouse_centroids <- vector(mode = "list", length = length(jacobians))
names(list_mouse_centroids) <- jacobians
for (j in jacobians) {
  
  # Iterate over clusters in nk solution
  list_mouse_centroids[[j]] <- vector(mode = "list", length = nk_mouse)
  names(list_mouse_centroids[[j]]) <- paste(nk_mouse, 1:nk_mouse, sep = "-")
  for (k in 1:nk_mouse) {
    
    # Import centroid image for specific cluster using threshold
    img_mouse <- import_cluster_map(imgdir = mouse_cluster_map_dirs_50um[[j]],
                                    mask = mouse_mask_file,
                                    nk = nk_mouse, k = k,
                                    threshold = threshold,
                                    threshold_value = threshold_value,
                                    threshold_symmetric = threshold_symmetric)
    
    list_mouse_centroids[[j]][[k]] <- mincArray(img_mouse)
    
  }
}
```

```{r fig2-ss-mouse-thresholds}
# Data frame to store mouse image thresholds
df_mouse_thresholds <- tibble(nk = rep(nk_mouse, nk_mouse),
                              k = 1:nk_mouse) %>% 
  unite(col = "cluster_id", nk, k, sep = "-", remove = FALSE) %>% 
  mutate(threshold_min = 0, 
         threshold_max = 0)

# Get min/max thresholds for each mouse image
for (i in 1:nrow(df_mouse_thresholds)) {
  mouse_img_abs <- abs(list_mouse_centroids[["relative"]][[i]])
  mouse_img_abs <- mouse_img_abs[mouse_img_abs > 0]
  df_mouse_thresholds[[i, "threshold_max"]] <- max(mouse_img_abs)
  df_mouse_thresholds[[i, "threshold_min"]] <- min(mouse_img_abs)
}
```

```{r fig2-ss-params}
# Mouse anatomy thresholds
mouse_anat_low <- 800
mouse_anat_high <- 2000

# Overlay thresholds from previous code chunk
overlay_low <- 0.19
overlay_high <- 1.0
```

```{r}
for (k in 1:nk_mouse) {
  
  fig_supp_3_grob <- sliceSeries(nrow = ss_nslices, ncol = 1, begin = 20, end = 200) %>% 
    anatomy(mouse_anat_vol, low = mouse_anat_low, high = mouse_anat_high) %>% 
    overlay(list_mouse_centroids[["absolute"]][[k]], low = 0.2, high = 1.0, symmetric = TRUE) %>% 
    sliceSeries() %>% anatomy() %>% 
    overlay(list_mouse_centroids[["relative"]][[k]], low = 0.2, high = 1.0, symmetric = TRUE) %>%   
    legend() %>% 
    grobify()
  
  fig_supp_3_width_pt <- fig_width_pt/(2.5)
  fig_supp_3_height_pt <- (fig_supp_3_width_pt/3)*ss_nslices
  
  outfile <- paste(output_plot_prefix, 3, nk_mouse, k, sep = "_")
  outfile <- paste0(outfile, ".pdf")
  outfile <- file.path(output_dir, outfile)
  export_pdf(x = fig_supp_3_grob,
             file = outfile,
             width = fig_supp_3_width_pt,
             height = fig_supp_3_height_pt,
             units = "bigpts")
  
}
```

# Supplementary Figure 4

```{r fig2-pathways-mouse-import}
# Enrichment database versions
stringdb_version <- "12.0"
bader_version <- "2023"
stringdb_score <- 950

# Base directory for pathway data files
mouse_pathways_dir <- "../data/mouse/enrichment/"
mouse_pathways_dir <- file.path(mouse_pathways_dir, 
                                paste("StringDB", stringdb_version, 
                                      "Bader", bader_version, 
                                      sep = "_"))
mouse_pathways_dir <- file.path(mouse_pathways_dir, "NeighbourhoodEnrichment")
mouse_pathways_dir <- file.path(mouse_pathways_dir, stringdb_score)

if (length(list.files(mouse_pathways_dir)) == 0) {
  stop("No files in specified directory")
}

# Prefix for pathway data files
mouse_pathways_file_prefix <- "NewBader_enrichment_clusterneighbourhood_vs_brain_all"

# Pathway IDs for a prior pathway set
if (bader_version == "2020") {
  pathway_ids <- c("ADHERENS JUNCTIONS INTERACTIONS%REACTOME%R-HSA-418990.2",
                   "AXON GUIDANCE%REACTOME DATABASE ID RELEASE 71%422475",
                   "CA2+ PATHWAY%REACTOME DATABASE ID RELEASE 71%4086398",
                   "CHROMATIN ORGANIZATION%REACTOME DATABASE ID RELEASE 71%4839726",
                   "GAP JUNCTION TRAFFICKING AND REGULATION%REACTOME%R-HSA-157858.1",
                   "GENE EXPRESSION (TRANSCRIPTION)%REACTOME DATABASE ID RELEASE 71%74160",
                   "GENERIC TRANSCRIPTION PATHWAY%REACTOME%R-HSA-212436.9",
                   "LONG-TERM POTENTIATION%REACTOME DATABASE ID RELEASE 71%9620244",
                   "MAPK FAMILY SIGNALING CASCADES%REACTOME DATABASE ID RELEASE 71%5683057",
                   "MTOR SIGNALLING%REACTOME%R-HSA-165159.5",
                   "PROTEIN-PROTEIN INTERACTIONS AT SYNAPSES%REACTOME DATABASE ID RELEASE 71%6794362",
                   "SIGNALING BY ERBB2%REACTOME DATABASE ID RELEASE 71%1227986",
                   "SIGNALING BY ERBB4%REACTOME DATABASE ID RELEASE 71%1236394",
                   "SIGNALING BY HEDGEHOG%REACTOME DATABASE ID RELEASE 71%5358351",
                   "SIGNALING BY GPCR%REACTOME%R-HSA-372790.4",
                   "SIGNALING BY NOTCH%REACTOME DATABASE ID RELEASE 71%157118",
                   "SIGNALING BY VEGF%REACTOME DATABASE ID RELEASE 71%194138",
                   "SIGNALING BY WNT%REACTOME%R-HSA-195721.5",
                   "TIGHT JUNCTION INTERACTIONS%REACTOME DATABASE ID RELEASE 71%420029",
                   "TRANSMISSION ACROSS CHEMICAL SYNAPSES%REACTOME%R-HSA-112315.5")
} else if (bader_version == "2023") {
  pathway_ids <- c("ADHERENS JUNCTIONS INTERACTIONS%REACTOME DATABASE ID RELEASE 38%418990",
                   "AXON GUIDANCE%REACTOME%R-HSA-422475.7",
                   "CA2+ PATHWAY%REACTOME%R-HSA-4086398.4",
                   "CHROMATIN ORGANIZATION%REACTOME DATABASE ID RELEASE 38%4839726",
                   "GAP JUNCTION TRAFFICKING AND REGULATION%REACTOME%R-HSA-157858.2",
                   "GENE EXPRESSION (TRANSCRIPTION)%REACTOME%R-HSA-74160.8",
                   "GENERIC TRANSCRIPTION PATHWAY%REACTOME%R-HSA-212436.12",
                   "LONG-TERM POTENTIATION%REACTOME DATABASE ID RELEASE 38%9620244",
                   "MAPK FAMILY SIGNALING CASCADES%REACTOME%R-HSA-5683057.4",
                   "MTOR SIGNALLING%REACTOME%R-HSA-165159.7",
                   "PROTEIN-PROTEIN INTERACTIONS AT SYNAPSES%REACTOME DATABASE ID RELEASE 38%6794362",
                   "SIGNALING BY ERBB2%REACTOME DATABASE ID RELEASE 38%1227986",
                   "SIGNALING BY ERBB4%REACTOME DATABASE ID RELEASE 38%1236394",
                   "SIGNALING BY GPCR%REACTOME DATABASE ID RELEASE 38%372790",
                   "SIGNALING BY HEDGEHOG%REACTOME DATABASE ID RELEASE 38%5358351",
                   "SIGNALING BY NOTCH%REACTOME%R-HSA-157118.6",
                   "SIGNALING BY VEGF%REACTOME%R-HSA-194138.3",
                   "SIGNALING BY WNT%REACTOME DATABASE ID RELEASE 38%195721",
                   "TIGHT JUNCTION INTERACTIONS%REACTOME DATABASE ID RELEASE 38%420029",
                   "TRANSMISSION ACROSS CHEMICAL SYNAPSES%REACTOME%R-HSA-112315.7")
} else {
  stop()
}

# Iterate over cluster solutions and import mouse pathway enrichment files
list_mouse_pathways <- vector(mode = "list", length = nk_max-1)
names(list_mouse_pathways) <- 2:nk_max
for (nk in 2:nk_max) {
  
  # Iterate over cluster number
  list_mouse_pathways[[as.character(nk)]] <- vector(mode = "list", length = nk)
  for (k in 1:nk) {
    pathways_file <- paste(mouse_pathways_file_prefix, nk, k, stringdb_score, sep = "_")
    pathways_file <- paste0(pathways_file, ".csv")
    pathways_file <- file.path(mouse_pathways_dir, pathways_file)
    list_mouse_pathways[[as.character(nk)]][[k]] <- read_csv(pathways_file, show_col_types = FALSE)  
    
    # Fix mouse enrichment p-values and q-values
    list_mouse_pathways[[as.character(nk)]][[k]] <- list_mouse_pathways[[as.character(nk)]][[k]] %>%
      mutate(NLQ = -log10(adj.P.Val))
  }
  
  # Combine clusters per solution
  list_mouse_pathways[[as.character(nk)]] <- list_mouse_pathways[[as.character(nk)]] %>% 
    reduce(.f = bind_rows) %>% 
    rename(pathway = Title,
           k = cluster) %>% 
    filter(ID %in% pathway_ids) %>% 
    mutate(nk = nk) %>% 
    unite(col = "cluster_id", nk, k, 
          sep = "-", remove = FALSE)
  
}

# Reduce list of pathways to a data frame
df_mouse_pathways_all <- list_mouse_pathways %>% 
  bind_rows() %>% 
  filter(ID %in% pathway_ids)
```

```{r fig2-pathways-info}
# Extract pathway ID and name
df_pathway_info <- df_mouse_pathways_all %>% 
  select(ID, pathway) %>% 
  distinct() %>% 
  arrange(pathway)

# # Create pathway acronyms
# df_pathway_info[["acronym"]] <- c(
#   "Adherens junction", "Axon guid.",
#   "Ca2+", "Chromatin",
#   "Gap junction", "Gene expr.",
#   "Transcription", "LTP",
#   "Mapk", "Mtor",
#   "Prot-prot int.", "erbb2",
#   "erbb4", "gpcr",
#   "hedgehog", "notch",
#   "vegf", "wnt", 
#   "Tight junction", "Trans. synapses"
# )

# Create pathway acronyms
df_pathway_info[["acronym"]] <- c(
  "AJI", "AG", "Ca2+", "CO",
  "GJTR", "GE", "GTP", "LTP",
  "MAPK", "MTOR", "PPIS", "ERBB2",
  "ERBB4", "GPCR", "HEDGEHOG", "NOTCH",
  "VEGF", "WNT", "TJI", "TACS"
)
```

```{r fig2-pathways-mouse-clust}
# Filter for cluster solutions with nk >= 4
df_pathways_nk_gt4 <- df_mouse_pathways_all %>% 
  filter(nk >= 4)

# Filter for desired pathways
# Compute normalized enrichment and NLQ per pathway
df_pathways_nk_gt4_subset <- df_pathways_nk_gt4 %>% 
  filter(pathway %in% df_pathway_info[["pathway"]]) %>% 
  group_by(pathway) %>% 
  mutate(NLQ_norm = NLQ/max(NLQ)) %>% 
  ungroup() %>% 
  mutate(NLQ_norm = ifelse(is.nan(NLQ_norm), 0, NLQ_norm))

# Convert pathway data frame into matrix 
mat_pathways_nk_gt4_subset <- df_pathways_nk_gt4_subset %>% 
  select(pathway, cluster_id, NLQ_norm) %>% 
  pivot_wider(id_cols = pathway, 
              names_from = cluster_id, 
              values_from = NLQ_norm) %>% 
  column_to_rownames("pathway") %>% 
  as.matrix()

# Hierarchical clustering of the pathways
pathway_hc <- hclust(d = dist(mat_pathways_nk_gt4_subset, 
                              method = "euclidean"))

# Extract pathway order according to clustering
pathway_lvls <- pathway_hc[["labels"]]
pathway_order <- pathway_hc[["order"]]
pathway_lvls_clustered <- pathway_lvls[pathway_order]

# Order pathway acronyms according to clustering
pathway_label_lvls_clustered <- df_pathway_info %>%
  mutate(pathway = factor(pathway, levels = pathway_lvls_clustered)) %>%
  arrange(pathway) %>%
  pull(acronym)
```

```{r}
# Convert mouse clusters to long format
df_mouse_clusters_long <- df_mouse_clusters %>% 
  pivot_longer(cols = -ID, names_to = "nk_name", values_to = "k") %>% 
  mutate(nk = str_remove(nk_name, "nk"),
         nk = as.numeric(nk))
```

```{r}
NLQ_threshold <- 30

df_mouse_pathways_alluvial <- df_mouse_pathways_all %>% 
  select(-ID) %>% 
  right_join(df_mouse_clusters_long, by = c("nk", "k")) %>% 
  mutate(nk = factor(nk),
         k = factor(k),
         pathway = factor(pathway, levels = pathway_lvls_clustered),
         NLQ = ifelse(NLQ > NLQ_threshold, NLQ_threshold, NLQ),
         E = ifelse(E > 30, 30, E))

fig_supp_4 <- ggplot(df_mouse_pathways_alluvial, 
       aes(x = nk, 
           stratum = k,
           fill = NLQ,
           alluvium = ID)) + 
  geom_flow(stat = "alluvium", aes.flow = "forward") + 
  geom_stratum(size = 0.15) + 
  facet_wrap(~pathway, ncol = 3, nrow = 7) + 
  scale_fill_gradientn(colors = brewer.pal(n = 9, name = "OrRd")[3:9],
                       limits = c(0, 30),
                       guide = guide_colourbar(title.position = "top",
                                               title.hjust = 0.5)) + 
  labs(x = "Number of clusters (K)",
       y = "Number of models",
       fill = "Enrichment (-log10(q))") + 
  theme_bw() + 
  theme(panel.grid.major.x = element_blank(),
        panel.spacing = unit(2, "bigpts"),
        axis.title = element_text(size = font_size, family = font_family),
        axis.text = element_text(size = font_size-1, family = font_family),
        strip.background = element_rect(fill = "grey90"),
        strip.text = element_text(size = font_size-1, family = font_family, 
                                  margin = margin(t = 1, b = 1, unit = "bigpts")),
        legend.title = element_text(size = font_size, family = font_family),
        legend.text = element_text(size = font_size, family = font_family),
        legend.position = c(0.85, 0.072),
        legend.direction = "horizontal",
        legend.margin = margin(),
        plot.margin = margin())

# Figure dimensions
fig_supp_4_width_pt <- fig_width_pt
fig_supp_4_height_pt <- fig_height_pt

# Export
outfile <- paste(output_plot_prefix, 4, sep = "_")
outfile <- paste0(outfile, ".pdf")
outfile <- file.path(output_dir, outfile)
export_pdf(x = ggplotGrob(fig_supp_4),
           width = fig_supp_4_width_pt,
           height = fig_supp_4_height_pt,
           units = "bigpts",
           file = outfile)
```


