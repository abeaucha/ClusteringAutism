# ----------------------------------------------------------------------------
# normative_growth_model.R
# Author: Antoine Beauchamp
# Created: February 16th, 2023
#
# Calculate voxel-wise effect sizes for human patients using voxel-wise
# normative growth modelling.

# Description
# -----------
# This script computes effect sizes for human study participants. A normative
# growth model is first evaluated on a voxel-wise basis using the study
# controls. The effect sizes are then generated by evaluating voxel-wise
# z-scores against the normative models for each study participant.

# Packages -------------------------------------------------------------------

suppressPackageStartupMessages(library(optparse))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(splines))
suppressPackageStartupMessages(library(RMINC))


# Command line arguments -----------------------------------------------------

option_list <- list(
  make_option("--imgdir",
              type = "character",
              help = paste("Path to directory containing the images (.mnc) to",
                           "use to compute the effect sizes.")),
  make_option("--demographics",
              type = "character",
              help = "Path to file (.csv) containing the demographics data."),
  make_option("--mask",
              type = "Path to the mask file (.mnc)."),
  make_option("--outdir",
              type = "character",
              help = paste("Path to directory in which to save the effect",
                           "size images.")),
  make_option("--key",
              type = "character",
              default = "file",
              help = paste("Primary key between demographics data and",
                           "constructed voxel matrix. [default %default]")),
  make_option("--df",
              type = "numeric",
              default = 3, 
              help = paste("Degrees of freedom to use in normative model",
                           "natural splines. [default %default]")),
  make_option("--batch",
              type = "character",
              help = paste("Variables to use in normalization prior to",
                           "modelling.")),
  make_option("--nproc",
              type = "numeric",
              help = "Number of processors to use in parallel."),
  make_option("--verbose",
              type = "character",
              default = "true",
              help = "Verbosity [default %default]")
)


# Functions ------------------------------------------------------------------

# Processing functions
source("src/processing.R")


#' Fit and predict normative model
#'
#' @param y (numeric vector) Voxel values across study participants.
#' @param demographics (data.frame) Demographics information for study 
#' participants.
#' @param batch (character scalar) Batch variable to residualize.
#' @param df (numeric scalar) Degrees of freedom in natural spline 
#' model.
#'
#' @return (data.frame) Model predictions for test participants.
fit_predict_model <- function(y, demographics, batch = NULL, df = 3) {
  
  if (length(y) != nrow(demographics)) {
    stop()
  }
  
  # Residualize using batch variable if specified
  if (!is.null(batch)) {
    batch <- demographics %>% 
      select(all_of(batch)) %>% 
      unite(col = batch) %>% 
      pull(batch)
    y <- residuals(lm(y ~ batch))
    names(y) <- NULL
  }
  
  # Filters for train and test sets
  ind_fit <- demographics[["DX"]] == "Control"
  ind_pred <- !ind_fit
  
  # Training data frame
  df_fit <- demographics[ind_fit, c("Age", "Sex")]
  df_fit[["y"]] <- y[ind_fit] 
  
  # Test data frame
  df_pred <- demographics[ind_pred, c("Age", "Sex")]
  df_pred[["y"]] <- y[ind_pred]
  
  # Fit model and predict on test set
  model_fit <- lm(y ~ Sex + ns(Age, df = df), data = df_fit)
  model_pred <- predict(model_fit, 
                        newdata = df_pred, 
                        interval = "prediction",
                        level = pnorm(q = 1) - pnorm(q = -1))
  
  # Extract model parameters of interest
  df_pred <- df_pred %>% 
    mutate(y_pred = model_pred[,"fit"],
           y_lwr = model_pred[,"lwr"],
           y_upr = model_pred[,"upr"],
           y_sd = y_pred - y_lwr)
  
  return(df_pred)
  
}


#' Compute z-score
#'
#' @param x (data.frame) Data frame containing normative growth 
#' model outputs. 
#'
#' @return (data.frame) Input data frame with new column containing 
#' z-scores.
zscore <- function(x){
  
  cols_check <- c("y", "y_pred", "y_sd")
  if (any(!(cols_check %in% colnames(x)))){
    stop()
  }
  x <- mutate(x, z = (y - y_pred)/y_sd)
  return(x)  
}


#' Compute normative z-score for a voxel
#'
#' @param y (numeric vector) Voxel values across study participants.
#' @param demographics (data.frame) Demographics information for study 
#' participants.
#' @param batch (character scalar) Batch variable to residualize.
#' @param df (numeric scalar) Degrees of freedom in natural spline 
#' model.
#'
#' @return (numeric vector) Voxel normative z-scores
compute_normative_zscore <- function(y, demographics, batch = NULL, df = 3) {
  
  y_pred <- fit_predict_model(y = y, demographics = demographics,
                              batch = batch, df = df)
  z <- pull(zscore(y_pred), "z")
  
  return(z)
}


# Main -----------------------------------------------------------------------

# Parse command line args
args <- parse_args(OptionParser(option_list = option_list))
imgdir <- args[["imgdir"]]
demographics <- args[["demographics"]]
mask <- args[["mask"]]
key <- args[["key"]]
df <- args[["df"]]
batch <- args[["batch"]]
outdir <- args[["outdir"]]
nproc <- args[["nproc"]]
verbose <- ifelse(args[["verbose"]] == "true", TRUE, FALSE)

# Check nproc
if (is.null(nproc)) {
  stop("Specify the number of processors to use in parallel.")
}

# Import demographics data
if (verbose) {message("Importing demographics information...")}
demographics <- as_tibble(data.table::fread(demographics, header = TRUE))

# Check existence of key column in demographics
if (!(key %in% colnames(demographics))) {
  stop(paste("demographics data is missing key column:", key))
}

# Remove entries with missing diagnosis, age, or sex
demographics <- demographics %>%
  filter(!is.na(DX),
         !is.na(Age),
         !is.na(Sex),
         !is.na(Site),
         !is.na(Scanner))

# Check existence of batch columns
if (!is.null(batch)) {
  batch <- str_split(batch, pattern = "-")[[1]]
  batch_check <- batch %in% colnames(demographics)
  if (!all(batch_check)) {
    stop("Batch columns not found in demographics:\n", str_flatten(batch, collapse = "\n"))
  }
}

# Image files
imgfiles <- list.files(imgdir, full.names = TRUE)

# Match image files to demographics
if (verbose) {message("Matching image files to demographics...")}
imgs_in_demographics <- basename(imgfiles) %in% demographics[[key]]
imgfiles <- imgfiles[imgs_in_demographics]
row_match <- match(basename(imgfiles), demographics[[key]])
demographics <- demographics[row_match,]

# Run normative growth modelling
if (verbose) {message("Evaluating normative growth models...")}
sink(nullfile())
voxels <- mcMincApply(filenames = imgfiles, 
                      fun = compute_normative_zscore,
                      demographics = demographics,
                      batch = batch,
                      df = df,
                      mask = mask,
                      cores = nproc, 
                      return_raw = TRUE)
voxels <- simplify_masked(voxels[["vals"]])
gc()
sink(NULL)

# Export images
if (verbose) {message("Exporting normalized images...")}
if (!file.exists(outdir)) {dir.create(outdir, recursive = TRUE)}
outfiles <- demographics[demographics[["DX"]] != "Control", key][[1]]
outfiles <- file.path(outdir, outfiles)
matrix_to_images(x = voxels, outfiles = outfiles, mask = mask,
                 margin = 2, nproc = nproc)
